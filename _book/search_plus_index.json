{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 项目介绍 "},"doc/appsflyer/appsflyer_instruction.html":{"url":"doc/appsflyer/appsflyer_instruction.html","title":"AppsFlyer","keywords":"","body":"AppsFlyer instruction Appsflyer 是主流的广告归因平台。它是一家以色列的公司，市场占有率在 70%以上，提供的服务有移动归因、深度链接、全面的安全防护等。 appsflyer 也可以进行数据打点！ 我们以在 facebook 投放广告为例： 1）投放团队投放广告 2）用户点击广告，到达落地页。记录并告诉 AF source 和 campaign 信息。 3）用户在落地页点击按钮跳转（跳转链接是按一定规则拼接，包好 source\\campaign 等必要信息）到应用商店。实际上，点击跳转实际上是经过 AF 中专之后再跳转的应用商店的。在中专的过程中 AF 完成一次记录。并在本地存储了必要信息。 4）点击下载按钮。记录一次！ 5）安装，第一次打开。客户端从本地查询之前存储的信息，之后向 AF 发送一个请求将用户涞源信息记录下来。 所谓的归因，其实就是指营销人员根据投放广告结果依照一定规则进行分析，然后将结果归功分配给各个资源(source: facebook, google advs 等)和广告活动（campaign）。归因的目的是更好更精确的给出反馈，从后对之后的投放作出调整。 "},"doc/appsflyer/appsflyer_web.html":{"url":"doc/appsflyer/appsflyer_web.html","title":"Web 端集成方案","keywords":"","body":"AppsFlyer web 集成方案 幻灯 自定义归因链接 移动落地页归因 移动落地页归因指南 介绍 落地页是数字营销人员非常常用的技术。他们使营销人员可以捕获潜在客户的详细信息以进行再营销，即使这些用户最初并未进行转化也是如此。 但是，对于获取移动用户而言，着陆页策略有其优点和缺点。 优点： 最终可以安装的潜在客户应与该应用更多地互动。 较复杂的服务（例如金融服务）需要更多说明来转换其潜在客户，这需要登录页面来启用。 缺点： 漏斗越长，转换的线索的最终数量就越少。 归因于技术上更具挑战性。 挑战 不同的媒体来源需要使用不同的方法 来使用正确的归因数据来完成目标网页方案。 如果目标网页具有自己的归因链接，则最终点击归因模型可能会导致失去正确的归因。 除非目标网页具有自己的归因链接，否则直接网站访问者会被记录为自然访问者。 桌面访问者会被记录为自然访问者，除非登录页面具有将其转化记录为移动用户的方法。 解决方案 要解决上述着陆页归因问题，您需要在着陆页中实现 javascript 流。我们提供了您可以使用的示例脚本实现。确保调整脚本以符合您的要求。 在某些情况下，您还需要对广告系列进行一些调整。 以下方案涵盖了所有可能的媒体源案例的要求。 落地页方案 请按照以下实施说明进行操作，以获取所有媒介资源 发送到您的目标网页。 Facebook：跨平台归因 描述： Facebook 是 SRN，它不使用外部归因链接。 首次启动应用程序时，AppsFlyer 会查询 Facebook 用户是否先前（过去 28 天内）与该应用程序的广告互动。 如果用户与广告商的 Facebook 广告互动，Facebook 会进行自我归因。 Facebook 还归因于跨平台，这意味着用户可以在任何平台上与任何类型的活动（无论是否移动）进行交互，以由 Facebook 自行分配。 结论： 如果在落地页面上记录了新的点击，则从 Facebook 到达落地页面的潜在客户将失去对 Facebook 的正确归属。 因此，Facebook 的目标网页不应包含归因链接。 说明： 在您的 Facebook 帐户上，创建一个 启用了移动设备归因的“链接点击”广告系列，将潜在客户发送到您的目标网页 登陆页面 Android 下载按钮-直接链接到 Google Play 着陆页 iOS 下载按钮-直接链接到 iTunes（或 带设备 ID 的属性链接） 脚本做什么 落地页脚本未做任何更改。该脚本旨在检测来自 Facebook 的用户。如果可以，那么它什么也不会做。它将着陆页直接链接到应用程序商店。这样可以避免记录可能影响点击率的其他点击。 在脚本中，查找名为 isFacebook（）的方法以了解有关用户来自 Facebook 时脚本的功能的更多信息。 落地页 Javascript 您可以在下面找到 javascript 的代码实现，该代码实现了在目标网页方案中对媒体来源和广告系列进行归因的全部范围。如果您想要其他数据，例如广告集和广告 ID，则应在脚本中进行必要的调整。 为了方便起见，您还可以下载随附的登录页面示例。 在代码下方，您可以找到将其适应目标网页需求的说明。 The script: //在执行脚本之前，请考虑一下事项： // 1）该脚本仅作为示例提供。它涵盖了归因流程的通用目标网页。修改脚本以符合您的要求。 // 2）该脚本在着陆页网址中查找特定参数，例如媒体源，广告系列，关键字等。如果要添加更多参数，例如网站ID和广告集，则需要相应地修改脚本。 //返回页面URL中存在的参数值，如果不存在则返回''。 function getParameterFromURL(name, url) { if (!url) url = window.location.href; name = name.replace(/[\\[\\]]/g, \"\\\\$&\"); var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"), results = regex.exec(url); if (!results) return null; if (!results[2]) return \"\"; return decodeURIComponent(results[2].replace(/\\+/g, \" \")); } function isMobileDevice() { return typeof window.orientation !== \"undefined\" || navigator.userAgent.indexOf(\"IEMobile\") !== -1; } function getMobileOperatingSystem() { var userAgent = navigator.userAgent || navigator.vendor || window.opera; if (userAgent) { if (/android/i.test(userAgent)) { return \"Android\"; } // iOS 检测来自: http://stackoverflow.com/a/9039885/177710 if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) { return \"iOS\"; } } return \"unknown\"; } function isAFLink() { return getParameterFromURL(\"af_redirect\"); } function isFacebook() { if (document.referrer && document.referrer != \"\") { return document.referrer.toLowerCase().includes(\"facebook\"); } else { return false; } } //根据页面访问者的来源，generateUrl 返回落地页上iOS和Android“下载”按钮后面要使用的URL。 //默认情况下，这些按钮应直接指向iTunes和Google Play上的应用页面。 //如果这些链接应保持不变，则generateUrl返回''。 //否则，generateUrl返回将在两个按钮下使用的URL（在这种情况下，也可以使用单个应用程序下载按钮）。 //参数：isDebug-如果为true，则针对每种情况发出警报，否则不发出警报。 function generateUrl(isDebug) { var oneLinkURL = \"https://yourapp.onelink.me/abcd\"; // **** 替换成自己的基本 OneLink URL **** var webFormURL = \"https://yoursite.com/webform.html\"; // **** 用您自己的Web表单URL替换，以获取用户的电子邮件或SMS **** var finalURL = \"\"; var partnerIDParam = \"?pid=\"; //媒体渠道名称 var campaignValue; if (getParameterFromURL(\"af_c\")) { campaignValue = getParameterFromURL(\"af_c\"); } else if (getParameterFromURL(\"utm_campaign\")) { campaignValue = getParameterFromURL(\"utm_campaign\"); } else if (document.getElementsByTagName(\"title\")[0]) { campaignValue = document.getElementsByTagName(\"title\")[0].innerText; } else { campaignValue = \"unknown\"; } var campaignParam = \"&c=\"; var gclidParam = \"&af_sub1=\"; //订阅者参数 1 var gclidValue = getParameterFromURL(\"gclid\"); var kwParam = \"&af_keywords=\"; //广告活动关键词 var pidValue; var kwValue = getParameterFromURL(\"keyword\"); if (getParameterFromURL(\"af_pid\")) { pidValue = getParameterFromURL(\"af_pid\"); } else if (getParameterFromURL(\"utm_source\")) { pidValue = getParameterFromURL(\"utm_source\"); } //禁止使用真实的SRN名称。完成脚本测试后，请删除此部分。 var SRNs = [\"twitter_int\", \"facebook_int\", \"snapchat_int\", \"doubleclick_int\", \"yahoogemini_int\", \"yahoojapan_int\"]; if (SRNs.includes(pidValue)) { alert( \"DO NOT USE NAMES OF SRNS IN af_pid or utm_source - use the names listed in Other SRNs: Add Parameter section in the landing page article\\nhttps://support.appsflyer.com/hc/en-us/articles/360000677217#other-srns-add-parameter\" ); return; } // 桌面用户 if (!isMobileDevice()) { return webFormURL; } //使用AppsFlyer归因链接上的af_r参数重定向了用户 if (isAFLink()) { if (isDebug) { alert( \"This user comes from AppsFlyer by redirection and is ready to be attributed. \\nKeep direct app store links.\" ); } return; //在这种情况下，安装按钮中的原始商店链接保持不变 /* 如果您想在同时提供iOS和Android的落地页面中使用一个安装按钮，请取消注释以下代码 该代码标识操作系统，并将相关的直接链接返回到Google Play或iTunes if (getMobileOperatingSystem() === 'Android') { return 'direct link to Google Play'; } if (getMobileOperatingSystem() === 'iOS') { return 'direct link to iTunes'; } */ } // Google Ads if (gclidValue) { partnerIDParam += \"google_lp\"; campaignParam += campaignValue; gclidParam += gclidValue; if (!kwValue) { finalURL = oneLinkURL + partnerIDParam + campaignParam + gclidParam; if (isDebug) { alert(\"This user comes from Google AdWords\\n \" + finalURL); } return finalURL; } else { //带有KW的Google Ads kwParam += kwValue; finalURL = oneLinkURL + partnerIDParam + campaignParam + gclidParam + kwParam; if (isDebug) { alert(\"This user comes from Google AdWords - there is a keyword associated with the ad\\n \" + finalURL); } return finalURL; } // 其他SRN和自定义网络 } else if (pidValue) { campaignParam += campaignValue; partnerIDParam += pidValue; finalURL = oneLinkURL + partnerIDParam + campaignParam; if (isDebug) { alert(\"This user comes the SRN or custom network \" + pidValue + \"\\n\" + finalURL); } return finalURL; } else if (isFacebook()) { if (isDebug) { alert(\"This user comes from a paid Facebook ad - don't do anything. \\nKeep direct app store links.\"); } return \" \"; } else { // organic mobile user campaignParam += campaignValue; partnerIDParam += \"website\"; //**** 对于适用于Android和iOS的一键式解决方案，请改用以下代码 **** finalURL = oneLinkURL + partnerIDParam + campaignParam; if (isDebug) { alert( \"This user comes from an unknown mobile source.\\n The user would be attributed to media source 'website' and to the campaign \" + campaignParam + \"\\n\" + finalURL ); } return finalURL; } } 落地页 html: Landing Page Landing Page --> window.onload = function() { var url = generateUrl(true); // onelink is generated 生成一个链接 if (url) { document.getElementById(\"andrd_link\").setAttribute(\"href\", url); document.getElementById(\"ios_link\").setAttribute(\"href\", url); } //否则，如果未生成onelink，则意味着用户已重定向 //和按钮中的商店链接保持不变 /* 对于适用于Android和iOS的一键式解决方案，请改用以下代码 document.getElementById('store_link').setAttribute('href', url); */ }; Tip: 您可以使用 Google 跟踪代码管理器来实现 javascript 代码段。Google 跟踪代码管理器使您可以更轻松地控制何时何地应使用着陆页 javascript。 使用说明 1、在您网站上任何页面的页面加载时激活 generateUrl 脚本，访问者可以直接访问该脚本，并且您的移动应用程序具有“下载”按钮。 重点：默认情况下，“下载”按钮应直接指向 iTunes 和 Google Play 上的应用程序页面。 如果这些链接保持不变（即来自 AF 归因链接或 Facebook 的访问者），generateUrl 将返回''。 否则，它将返回要与两个 下载 按钮一起使用的 URL（在这种情况下，也可以使用单个下载按钮来覆盖具有 OneLink 的两个应用程序）。 2、用与占位符 https://yourapp.onelink.me/abcd 完全相同的格式，用您自己的基本 OneLink URL 替换 oneLinkURL 参数值。 必须将所有 SRN（Facebook 付费广告除外）的访客和移动自然访客归因于访客。 3、用您自己的 Web 表单链接替换 webFormURL 参数值。 该网络表单应该能够获取用户的电子邮件或 SMS，并向用户的移动设备发送一条消息，该消息带有 OneLink URL，用于下载该应用程序。 必须指定桌面访问者。 4、如果您希望将移动自然用户归因于“网站”以外的其他媒体来源，请替换 partnerIDParam 参数值。 5、默认情况下，除非在着陆页 URL（＆c = {CAMPAIGN_NAME}）中指定了另一个广告系列名称，否则，用户将在单击 “下载” 按钮时归属于他们所在的网页。 要更改该值，请替换 campaignParam 参数值的值。 对于所有方案都是可选的，Facebook 付费广告除外。 查看结果 与任何媒体源一样，您可以在应用程序的仪表板上，原始数据或通过 AppsFlyer 的 API 查看着落地页结果。 如果您的移动营销渠道始终指向您的目标网页，则这些媒体资源表示以下内容： source description organic 未浏览目标网页或未参与目标网页的用户。或者，确实参与但由于各种原因（例如，在启动应用之前，通过归因回溯窗口。 website 有机移动用户访问您的目标网页/网站并随后进行安装 facebook ads 用户来自付费 Facebook 广告 fbpost_lp 用户来自病毒性无偿 Facebook 帖子 google_lp 用户来自 Google ads [SRN]_lp 其他 SRN 的用户，例如 Twitter（twitter_lp），Snapchat（snapchat_lp），Doubleclick（doubleclick_lp）或 Oath（oath_lp） Integrated partner ID 用户来自使用 AppsFlyer 的归因链接的集成合作伙伴的广告。例如：inmobi_int，tapjoy_int desktop 桌面用户填写 Web 表单，然后单击随后发送到其移动设备的 SMS 或电子邮件后完成安装 Other sources 来自拥有媒体资源的用户，这些媒体资源使用 AppsFlyer 的归因链接。例如：电子邮件，短信，blog_post 等 OneLink 落地页解决方案 OneLink™ 是独特的 AppsFlyer 归因链接，用于设备检测和重定向或深层链接。 着陆页解决方案要求广告客户具有基本的 OneLink URL，该 URL 可以检测用户的设备类型并相应地重定向到正确的应用程序商店。 如果您尚未为应用程序实现 OneLink： 配置OneLink 模板 根据模板创建OneLink URL 在脚本中，用您的 OneLink 网址替换'https://yourapp.onelink.me/abcd' "},"doc/appsflyer/SRN_explain.html":{"url":"doc/appsflyer/SRN_explain.html","title":"什么是 SRN?","keywords":"","body":"Self-reporting networks (SRNs) explained https://support.appsflyer.com/hc/en-us/articles/360001546905-Self-reporting-networks-SRNs-explained#introduction 什么是 SRN？ 自我报告网络（SRN），也称为自我归因网络，例如 Facebook，Google Ads 和 Twitter，不使用外部公司的归因链接。 相反，每个网络都有自己的方法和 API，AppsFlyer 使用这些方法和 API 来传达新安装，应用内事件等。 谁是 SRN？ 与 AppsFlyer 集成的 SRN Facebook Google Ads Snapchat Twitter "},"doc/appsflyer/OneLink.html":{"url":"doc/appsflyer/OneLink.html","title":"OneLink 概述","keywords":"","body":"OneLink™ 是独一无二的 AppsFlyer 归因链接，广告商可以使用它来通过一个操作项利用 5 个主要功能。 设备检测和重定向 单击时，OneLink 可以检测到设备类型，然后将用户重定向到匹配的目标。 例如，Android 用户重定向到 Google Play，iOS 用户重定向到 iTunes，桌面用户重定向到网页等等。 使用电子邮件或 SMS 广告活动，网站横幅等自有媒体时，此功能特别有用。 若要进行此配置，请按照《 OneLink 重定向设置指南》中的说明进行操作。 深层连结 (Deep linking) 如果已经安装了广告的移动应用程序，则 OneLink 可以在单击 URL 之后启动该应用程序，并为用户提供个性化内容。 借助 OneLink，无需打开应用程序的默认活动，而是可以将用户定向到应用程序内的特定活动，或进行特殊促销，从而改善用户体验。 有关更多详细信息，请转到《 OneLink 深度链接指南》。 延迟深层连结 (Deferred deep linking) OneLink 能深层链接，服务个性化的内容的用户，即使广告的移动应用程序还没有安装，应用安装之后。 为此，应用程序开发人员需要访问 AppsFlyer 归因/转换数据，该数据具有源/归因链接中的所有参数和值。 有关更多信息，请访问此处。 OneLink API 通过AppsFlyer，您可以轻松地为要运行的任何广告系列创建OneLink。 但是，有时您想一次缩放并运行多个广告系列，或者运行包含数千个广告和广告素材的广告系列。 您可以使用OneLink API，而不是为每个广告系列或广告创意手动创建每个OneLink。 OneLink API使您可以快速，轻松地创建数千个OneLink，从而节省了时间和精力，而将精力集中在广告系列和市场营销工作上。 请参阅我们的 OneLink API指南 以了解更多信息。 最佳实践 避免广告客户使用深层链接遇到的典型问题，并查看有关 深层链接的最佳做法指南。 "},"doc/appsflyer/people_based_attribution.html":{"url":"doc/appsflyer/people_based_attribution.html","title":"基于人的归因概述","keywords":"","body":" 介绍 许多广告客户分别针对移动应用和网络广告系列衡量广告系列的效果。但是，基于人的归因（PBA）将来自网络和移动应用广告系列的数据汇总在一起。合并的数据可帮助您分析跨平台的用户旅程以及用户从 Web 到移动应用的过渡。 下面我们按照需要解决和设置的顺序列出了 PBA 的所有方面。浏览清单并阅读各节中链接的文章，以了解如何充分利用 PBA。 品牌捆绑 品牌捆绑是您将同一个品牌的应用捆绑在一起的方式，例如 Android 应用，iOS 应用和网站。 通过创建捆绑包，您可以使 AppsFlyer 收集，合并和分析与捆绑的应用程序中的安装，转换，收入和总体用户活动有关的数据。 要了解更多信息，请参阅我们的品牌捆绑指南。 Web SDK 创建品牌包后，就可以将 Web SDK 添加到您的网站了。 Web SDK 允许 AppsFlyer 记录来自网站上的活动和用户活动的数据。 然后，将这些数据与移动数据合并，从而为您提供整个品牌的营销绩效的整体视图。 要了解更多信息，请参阅有关将 Web SDK 添加到您的网站的指南。 基于人的分析 将 SDK 添加到您的网站后，它将开始收集有关广告系列和用户活动的数据。 然后可以使用基于人员的分析工具查看和分析此数据。 基于人的分析提供了跨平台，设备和营销渠道的用户获取和转化流的完整情况。 基于人员的分析页面包括一个表格，其中包含有关广告系列和转化的所有数据。 它使您可以专注于特定指标，并根据位置，设备类型，媒体来源，广告系列等对数据进行过滤或分组。 要了解更多信息，请参阅我们的基于人员的分析指南。 web-to-app 分析 网络到应用程序是基于人员的分析的一部分，用于分析网络流量如何促进应用程序安装。 如果您的营销目标之一是将用户从网络转换为应用程序，则网络到应用程序分析可帮助您分析转换率和媒体来源贡献。 这种类型的分析可帮助您了解潜在的应用程序用户来自何处。此外，它还可以帮助您分析网络营销活动的结果，以了解应该在哪里投资资源以扩大移动用户群。 要了解更多信息，请参阅我们的web-to-app 分析指南。 PBA 原始数据 一切准备就绪，数据流到仪表板后，您就可以开始分析原始数据以获得更深入的见解。 有关网站访问和用户活动的所有数据都记录在原始数据报告中。 您可以将它们与您喜欢的 BI 工具一起使用，以获得更多见解。 您还可以将它们与移动应用程序的原始数据报告合并。 要了解更多信息，请参阅我们的PBA 原始数据报告指南。 Tip: 基于人的归因是如何工作的，主要策略和用例是什么，GDPR 和 CCPA 对其有何影响？在这里阅读。 "},"doc/appsflyer/手动归因中媒体源和广告系列映射.html":{"url":"doc/appsflyer/手动归因中媒体源和广告系列映射.html","title":"手动归因中媒体源和广告系列映射","keywords":"","body":"概览：媒体源映射在基于人员的归因（PBA）中的工作方式。 介绍 媒体源映射决定哪种媒体源获得了将用户带到网站的功劳。它还将媒体源与媒体类型相关联。 PBA中的媒体源映射与移动设备中的媒体源映射不同。移动设备中的媒体源映射需要SRN或归因链接的答复，而PBA将更多因素纳入媒体源映射。 防止自我归因 PBA中媒体源映射的第一个方面是防止自我归因。自我归因是指网站本身被视为媒体来源。 例如，如果用户单击来自example.com的链接，该链接指向about.example.com，则媒体源为example.com。 理想的结果是网站example.com不被视为媒体来源。为此，PBA使用引荐排除列表。创建品牌包时，请指定网站域。PBA将此域排除为媒体源。 确定媒体来源 PBA使用查询参数和引荐来源网址来确定媒体源。PBA在Web SDK的帮助下做到了这一点。请参阅PBA用于媒体源映射的以下方法。 确定媒体源类型 PBA 还确定媒体源类型。媒体源类型显示在PBA原始数据中，但不显示在PBA分析页面中。 对于网络广告系列，营销人员通常将媒体来源分为三类： 付费-广告系列（展示横幅，视频，搜索广告等） 拥有-来自拥有媒体的营销活动，即电子邮件活动，社交帖子，博客等。 获利-来自搜索引擎，引荐的直接或自然流量，或实际直接流量。 请参阅PBA用于确定媒体类型的以下方法。 通过 pid 如果URL具有 pid 参数，则PBA会将媒体类型确定为 paid。想法是，该 pid 代表您为广告网站而支付的广告网络或广告来源。pid参数具有最高优先级 如果 pid 的值是自定义媒体源，则PBA会将媒体类型确定为 owner。自定义媒体源是AppsFlyer建议与移动自定义链接一起使用的媒体源。请参阅以下列表： 社交Facebook 社交推特 电子邮件 短信 博客 如果这些媒体源中的任何一个显示为 pid 参数值，则PBA会将媒体类型确定为owner。 通过 click ID 如果URL具有单击ID，则PBA会将媒体类型确定为已付费。点击ID的优先级第二高。如果URL上没有pid，则Web SDK会尝试查找点击ID。SDK查找的点击ID为： gclid-这是一个 Google点击ID。Google并未正式支持或推荐GCLID解决方案。如果Google弃用了GCLID参数，则映射逻辑将更改以适应该参数。 dclid-这是DoubleClick点击ID。 msclkid-这是 Bing点击ID。 确定 campaign PBA通过以下两个参数之一确定广告系列名称： C utm_campaign 每个参数都有其配对的媒体源参数： 媒体源参数 campaign参数 pid C utm_source utm_campaign 不可能将两者混合搭配。例如，不可能使用 pid 指定媒体源，而使用 utm_campaign 指定广告系列。 如果URL上存在 pid，则PBA将查找 c 以确定广告系列。如果URL上存在 utm_source，则PBA将查找 utm_campaign。如果找不到，则会将广告活动视为没有。 "},"doc/appsflyer/人工分析.html":{"url":"doc/appsflyer/人工分析.html","title":"人工分析","keywords":"","body":" 翻译：People-based-analysis 基于人的分析提供了跨平台、设备和营销渠道的用户获取和转换流程的完整图景。 您可以看到品牌的完整而逼真的表现。 基于人的分析页面 你可以通过下面两种方式之一打开这个页面： 在任何应用程序的仪表板上，单击左侧菜单中的 基于人员的分析 在任何应用程序的仪表板上，单击 品牌捆绑。单击您选择的组合中 操作 下的三个点，然后选择 基于人员的分析。 "},"doc/appsflyer/手动归因VS谷歌分析.html":{"url":"doc/appsflyer/手动归因VS谷歌分析.html","title":"手动归因 VS 谷歌分析","keywords":"","body":" 翻译：People-based attribution VS. Google Analytics 概览：解释基于人员的归因与 Google Analytics（分析）之间的区别。 展开查看 System.out.println(\"Hello to see U!\"); --> 介绍 基于人的归因（PBA）和 Google Analytics（分析）都是网络分析和转化衡量解决方案。 但是，每一个都专注于不同的测量方面。PBA 还提供其他好处。 那有什么区别呢？ PBA 是一个独立的，公正的归因机构，专注于归因评估。PBA 将转化和收入归功于将用户吸引到您的网站的媒体来源和广告系列。 Google Analytics（分析）更加关注网络分析。它收集，分析和汇总与用户行为有关的数据。 借助 Google Analytics（分析），您可以分析用户行为，渠道，网络事件等。 与 Google Analytics（分析）相比，PBA 的优势 以下是 PBA 相对于 Google Analytics（分析）的优势： PBA 提供 Web 到应用程序的测量。此指标告诉您有多少用户从您的网站转移到您的应用程序。它还会告诉您哪些媒体来源和广告系列将用户带到您的网站，然后最终安装您的应用程序。 PBA 还提供 有关转换和事件的原始数据，您可以将其引入自己的 BI 系统。这使您具有运行分析的能力。 差异的原因 如果您比较 PBA 和 Google Analytics（分析）中的数据，请参阅以下数据差异原因。 SDK 实施 实施 PBA 和 Google Analytics（分析）的方式可能会影响数据收集。 仪表盘设定 时区和数据过滤器等仪表盘设置可能会影响数据向您呈现的方式。 转换和事件 不同的归因模型，回溯窗口，事件发送方式以及 cookie 设置都会影响数据的收集和处理。 "},"doc/appsflyer/手动归因的原始数据报告.html":{"url":"doc/appsflyer/手动归因的原始数据报告.html","title":"手动归因的原始数据报告","keywords":"","body":" 翻译：Raw data reports for people-based attribution 到达您网站的用户会携带有价值的信息。此信息包括用户访问您网站的旅程（接触点）以及他们在网站上执行的操作（网络事件）。使用此信息，您可以洞悉如何优化广告系列以增加转化次数和收入。 PBA数据显示在以下报告中： Web接触点-包含有关您的网站每次访问（接触点）的信息。该信息可以是： 与广告活动相关：广告活动名称，媒体类型等 与用户相关：地理位置，设备类型等 网络事件-用户在您的网站上执行的操作，例如购买或订阅 PBA报告可在数据柜中使用。请参阅设置和下载PBA报告。 PBA数据的用例 以下用例说明了如何使用PBA报告来获得有关您在Web和移动设备上的营销工作的见解。 Web接触点报告的用例 使用 web接触点 信息可以衡量广告活动（campaigns）的曝光度和参与度。 接触点信息分析使您能够比较哪些广告活动将更多的用户吸引到该网站。 使用地理位置数据，您可以根据位置比较广告活动影响的差异。 web事件报告的用例 web 事件 是用户在您的网站上执行的操作，例如购买或订阅。 AppsFlyer 将 web 事件归因于最后一个非直接接触点。 最后一个非直接接触点与广告活动、广告、媒体来源和其他参数相关联。 这些参数可帮助您分析广告系列的效果，以优化营销。 Web 事件报告的一个用例是分析每个媒体源的用户行为。 您可以查看用户执行的事件集，并了解他们转换之前所经过的路径。 然后，您可以匹配路径模式，并将其与特定的媒体来源、广告系列和广告相关联。 另一个用例是查看哪些用户执行操作但不进行转换。 然后，您可以确定将未转化用户吸引到您的网站的广告系列，广告和媒体来源。 确定了这些广告系列，广告和媒体来源之后，您就可以开始调查它们为什么会产生非转化用户并进行相应的优化。 手动归因和移动 用户可能会同时使用您的移动应用程序和网站。 这带来了将数据汇总在一起的挑战。 可以通过组合Web和移动数据来克服这一问题。 结合使用移动报告和Web报告有两种方法： 合并有关客户用户ID的报告 - 如果您同时设置了移动用户和网络用户的客户用户ID，则可以合并有关客户用户ID字段的报告。 基于人员的归因跨平台用户标识 - 基于人员的归因可以确定Web用户和移动用户是同一个人。发生这种情况时，基于人的归因会在网络报告中包括移动广告ID（例如Android广告ID，iOS IDFA或Amazon广告ID）。然后，您可以在移动广告ID上合并移动报告和网络报告。 PBA和移动设备的用例 通过组合移动数据和Web数据，您可以查看跨平台和设备的用户活动。这些合并的数据可以帮助您执行以下操作： 查看整个品牌的用户历程 分析每个平台中的用户行为 查看哪个平台显示出更多的用户参与度 查看哪个平台产生更多转化 衡量您将用户从网络切换到移动的努力 报告结构和字段 以人为本的归因领域 手动归因的特定字段 设置和下载PBA报告 配置PBA报告 将PBA相关字段添加到报告中 下载报告 "},"doc/ga_introduction.html":{"url":"doc/ga_introduction.html","title":"Google Analytics","keywords":"","body":"What GA 就是 Google 分析工具。别用来记录用户打点信息，它为不同设备提供相应的 SDK, 并且管理员可以直接在页面分析获取的数据。 "},"doc/aws_introduction.html":{"url":"doc/aws_introduction.html","title":"AWS","keywords":"","body":""},"doc/aws_invalidation.html":{"url":"doc/aws_invalidation.html","title":"aws 使缓存失效","keywords":"","body":" 什么是 Amazon CloudFront？ create-invalidation "},"doc/web_awake_app.html":{"url":"doc/web_awake_app.html","title":"Web 唤起 App","keywords":"","body":"摘要 背景 三种唤醒方式 url scheme iframe chrome intent Universal Link (ios) appLink (android) 总结 参阅 背景 今天另外一个组的同学问了一个落地页的问题，落地页的功能就一个 —— 中转跳转，如果安装了 App 直接打开，否则跳转的应用商店下载页。对方直接将 h5 代码扔了过来，看着感觉没有什么问题但是却折腾了一个下午。主要卡在跳转打不开 app, 也就是说代码能够执行到 就是跳转无效，但是手动点击或者控制台执行操作是可以奏效的。接着想到通过 js 模拟用户点击的方式，结果还是无法跳转。最后总结过来就是，通过 Scheme 方案试图打开本地安装的 App 必须要手动操作，js 自动执行或者模拟点击都是无效的。 所以，今天晚上试图梳理记录一下几种最常见的 web 唤醒 App 的方法操作。 五种唤醒方案 URL Scheme 组成结构： [scheme:][//authority][path][?query] 比如：tuyasmart://home?test=1 URL Schemes 可以理解为一种特殊的 URL 用来定位一个应用以及应用内的某个功能，类比网页链接便很容易理解。 通过 URL Schemes, 我们就可以像定位一个网页一样，定位一个应用甚至应用内的某个具体的功能。而定位是哪个应用的，就是 Schemes 部分。比如短信应用的 Schemes 就是： sms 注意： 应用是否支持 URL Schemes 要看 App 开发者有没有写那部分的代码了 - URL Schemes 不唯一 使用： 使用方式十分简单，就像我们去打开一个链接一样，你可以通过下面方式使用它： location.href a 标签 iframe 优点： 最常见的一种唤醒方式。 缺点： 唤醒时会弹出一个对话框提示用户是否打开，一旦用户选择了“取消“， 就可能以后再也唤醒不了了。 常见问题： 可能会被 app 禁掉，比如微信，qq 等 ios9+ 禁止掉了 iframe 方式。 ios 及部分安卓浏览器会提示用户是否打开 App，并且 ios 在未安装对应 App 的时候，会提示“打不开网页，因为该网址无效” h5 无法感知是否唤醒成功 大部分浏览器需要用户手动触发链接，js 自动触发无效 解决方案： 针对被 app 禁止掉的情况，通常会判断是否微信等 app 环境，然后提示用户浏览器内打开。 针对 ios9+ iframe 被禁掉的情况，判断下 ios 版本 针对 h5 无法感知是否唤醒成功的解决办法是，一段时间之后自动跳转下载页，或者是依赖 setTimeout 在浏览器进入后台后进程切换导致的时间延迟判断。 iframe chrome intent 安卓的原生谷歌浏览器从 chrome25 版本之后就不能通过 URL Schemes 唤醒安卓应用。要使用谷歌官方提供的 intent:预发， 如果唤醒失败，则会跳转到谷歌的应用市场。语法与 URL Schemes 及其相似，相当于谷歌定制版的 URL Schemes。 根据 Chrome 官方说明文档，语法如下： intent: HOST/URI-path // Optional host #Intent; package=[string]; action=[string]; category=[string]; component=[string]; scheme=[string]; end; 所以，判断出浏览器类型和版本之后： // 在 js 中控制跳转 window.location.href = \"intent://path/to-page/#Intent;scheme=yourapp;package=com.yourapp.package.name;end\"; 打开app 缺点： 必须要用户手势点击才会跳转有效，直接 js 启动是无效的。 Universal Link (IOS) 优点： 1）苹果自家的解决方案。 2）没有提示用户是否访问的提示框。 缺点： 配置相对麻烦一些，需要 Native、web、server 一起配置，据说很多 ios 开发同学都搞不清楚它。 使用： 还没体验过，待续！👉官方文档 appLink (Android) 出现背景： 为了优化用户体验，因为在使用 Scheme 唤醒时会弹出一个对话提示框提示用户是否打开，并且一旦用户勾选了“取消”， 可能之后就再也唤醒不了了。 使用： 还没体验过，待续！👉官方文档 安卓 App Link 的流程和 iosUniversal link 的类似，iOS 中需要配置的 app-support.test.com/apple-app-site-association 文件在安卓中叫做 app-support.test.com/.well-known/assetlinks.json，只能放在.well-known 下面 第三方服务 Appsflyer // https://cdn.yourstorypaths.com/default/webpage/updatesweb/BillionaireLove/index.html?utm_source=facebook&utm_medium=cpc&utm_campaign=Updates_US_Ying_20191129_All_17%2B_Billionaire%20Love_web http://10.0.24.34:5500/index.html?utm_source=facebook&utm_medium=cpc&utm_campaign=Updates_US_Ying_20191129_All_17%2B_Billionaire%20Love_web branch Branch 和 Appsflyer 类似都提供第三方归因服务，这里 我们将 Branch 当成是唤醒 App 的第三方 SDK 来用，会用到 Branch 的深度链接，使用很简单只需注册一个账号然后然后创建一个深度链接，然后使用归因链接做跳转就可以来。 总结 目前对文中所有方案还没有全部都实际操作一遍，后续使用到了会补充完整。 参阅 Deep Linking：H5 页面调起 App H5 唤醒 App 方式汇总 H5 唤起 APP 进行分享的尝试 h5 页面点击判断是否安装 app 并打开，否则跳转下载页面 "},"doc/git/pages/1.git理论基础.html":{"url":"doc/git/pages/1.git理论基础.html","title":"git理论基础","keywords":"","body":"Git 记录的是什么？ 如果，你有使用 SVN 等其他版本控制系统的经验，你应该知道它们的 工作原理是记录每一次的变动。 SVN记录的是每一次版本迭代时变动的内容： 每一次版本迭代，SVN 记录的是文件的变化内容。通常如果是让我们自己来写一个版本管理工具的话也会首选这样的思维吧？就像写小说一样，每次就增加一个章节，修改若干错别字，最终装订成册……没必要为每次的修改都拷贝一整本书！这种存储方式也是有名堂的，叫 增量文件系统（Delta Storage systems）。 而 Linus 童鞋这次却决定剑走偏锋，以一种看似“异端”的方式来处理版本迭代。 Git则是将每个版本单独保存起来: 如上，如果每个版本中有文件发生变动，Git 会将整个文件复制并保存起来。这种设计看似会多消耗更多的空间，但在分支管理时却是带来了很多的益处和便利（分支管理我们后边会讲，不急）。 突然想到了一句话：普通的程序员是把很多的时间放在写代码和调 Bug 上，而优秀的程序员是将更多的精力放在设计上…… 三棵树 你的本地仓库由 Git 维护的三棵“树”组成，这是 Git 的核心框架。这三棵树分别是：工作区域、暂存区域和 Git 仓库。 工作区域（Working Directory）： 就是你平时存放项目代码的地方。 暂存区域（Stage）： 用于临时存放你的改动，事实上它只是一个文件，保存即将提交的文件列表信息。 Git 仓库（Repository）： 就是安全存放数据的位置，这里边有你提交的所有版本的数据。其中，HEAD 指向最新放入仓库的版本（这第三棵树，确切的说，应该是 Git 仓库中 HEAD 指向的版本）。 OK，Git 的工作流程一般是酱紫： 在工作目录中添加、修改文件； 将需要进行版本管理的文件放入暂存区域； 将暂存区域的文件提交到 Git 仓库。 因此，Git 管理的文件有三种状态：已修改（modified）、已暂存（staged）和 已提交（committed），依次对应上边的每一个流程。 为什么需要暂存区？ 可能你会问：“Git 仓库用于存放每次的版本迭代，我可以理解。但为何还要多增加一个暂存区域呢？” 我这里打个比方：像某些厂家开发一个产品，一般他们都留有一手，不会把该产品的所有特性一次性发布。通过产品的迭代，每年秋季你就可以开开心心地买到又有一两项新功能的“新”产品了。 So，有时你并不想把工作目录中所有的新功能都提交到最新版本，你就可以先添加一些本次需要提交的文件到暂存区，然后从暂存区中提交它们……所以暂存区在江湖中有个外号叫“索引”（Index）。 "},"doc/git/pages/2.git查看状态和历史提交记录.html":{"url":"doc/git/pages/2.git查看状态和历史提交记录.html","title":"查看工作状态以及历史提交","keywords":"","body":"查看当前工作状态 —— git status git status命令用于查看当前工作目录的状态。如：新增文件、修改的文件、删除的文件。 文件名颜色： 红色：本地项目修改了文件。 绿色：存在暂存区的文件（还没有提交到远端仓库）。 如果你向暂存区提交了文件，但是出于某种原因，希望更新到之前的”模样“， 可通过下面的命令实现。 git reset HEAD # 将最近一次提交恢复为尊村区域 git reset HEAD 文件/文件夹 # 只恢复指定的文件或者文件夹 查看历史提交 —— git log 执行git log命令查看所有提交记录， 它的顺序是按时间书序由近到远排列的。 "},"doc/git/pages/3.回到过去.html":{"url":"doc/git/pages/3.回到过去.html","title":"回到过去","keywords":"","body":"首先，这里是张图： 上面这张图片，展示了add、commit、reset、checkout四个命令在三棵树之间操作的作用。 add 命令将本地代码提交到暂存区。 commit 命令将暂存区的代码提交到仓库中。 reset 命令将仓库中的代码恢复到暂存区。 checkout 命令将暂存区的代码恢复到本地。 Tip： reset命令和checkout命令不仅仅只有上面说的这两个功能，实际上它们是git里面功能最复杂的两个命令，它们还要很多其他功能。 这篇文章里面主要讲的是reset命令的用法。 git reset命令 git reset --mixed HEAD~ #移动HEAD的指向，回滚指向上一个快照 # 上面的命令等价于 git reset HEAD~ #也就是说--mixed是默认的 可以不写 这条命令实际上做了两项操作： 移动HEAD的指向，将其指向上一个快照。 将HEAD移动后指向的快照回滚到暂存区域。 git reset --soft HEAD~ 这条命令做的操作是： 移动HEAD指针，将其指向上一个快照。 git reset --hard HEAD~ 这条命令做的操作是： 移动HEAD指针，将其指向上一个快照。 将HEAD移动后指向的快照回滚到暂存区域。 将暂存区域的文件还原到工作目录 Tip： 这条命令是有危险的，因为它会将我们本地工作目录中最新的文件给覆盖掉。 reset命令回滚快照三部曲 移动HEAD的指向（--soft）。 将快照回滚到暂存区域([--mixed], 默认)。 将暂存区域还原到工作目录（--hard）。 "},"doc/git/pages/4.版本对比.html":{"url":"doc/git/pages/4.版本对比.html","title":"版本对比","keywords":"","body":"比较暂存区域和工作目录 要比较暂存区和工作目录可以使用git diff命令。 diff命令是linux上一个非常重要的命令，因为比较文件内容 它本身在linux上就有这个命令。从前在没有git工具时，前辈们就是通过linux上带的这个diff 命令来比较两个版本的文件不同的。 接下来我们继续讲git的diff命令用法。在工作目录下执行git diff命令，就能看到暂存区域和工作目录对比的详细信息了。 另外，几个配合使用的命令： # 执行git diff命令后 # # 因为信息太多，窗口太小的缘故，在窗口最底部会有个“：” # 通过键入一下命令可以以不同进入查看信息 j # 向下移动一行 k # 向上移动一行 f # 一页一页往下移 b # 一页一页往上移 g # 跳到第一行 G # 跳到最后一行 3g # 跳到第三行 7g # 跳到第7行 # 搜索，匹配的会被高亮显示 /console.log #从上往下搜索“console.log” ?console.log #从下往上搜索“console.log” n # 下一个 N # 上一个 # ========================================== h # 显示帮助文档 q # 退出 比较两个历史快照 git diff 快照ID1 快照ID2 Tip： 今天学到一个小技巧，git commit -am 'xxxxx' 即一次性添加到暂存区域并提交。。哈哈，偷学了赚到了 可能你会问什么是快照 id？ 怎么获取？ 执行命令git log, 其中暗黄色的部分去除前面“commit”剩下的就是快照id。在这里比较两个历史快照时并不需要我们把连个快照id完完整整输入，实际上输入前面4~6位字符就ok了。 比较当前工作目录和git仓库中的快照 我们可以通过命令 git diff 快照ID1 比较当前工作目录和git仓库中的快照。而且，同样快照id输入前几位就可以了。 这里说个比较特殊的，就是在比较当前工作目录和最近一次提交快照时，我们可以像下面这样： git diff HEAD 比较暂存区域和git仓库快照 通过命令 git diff --cache 快照id 来比较比较暂存区域和git仓库快照。 git diff --cache #比较暂存区域和最近一次提交快照 一张图 最后，附上一张图帮助去理解这篇文章所说的内容。 "},"doc/git/pages/5.删除文件和重命名文件.html":{"url":"doc/git/pages/5.删除文件和重命名文件.html","title":"删除文件和重命名文件","keywords":"","body":"1. 删除文件 git checkout -- 文件名 # 将暂存区域的文件更新到工作目录 要删除一个已经提交到仓库的文件可以通过下面两行命令来完成。 git rm 文件名 # 删除工作目录和暂存区域的文件 git reset --soft HEAE~ # 回到过去，修改仓库里的HEAD指针 如果，要删除的文件在本地工作目录中和暂存区的不一样（不一致）的话，上面的命令就不好使了。怎么办呢？ git rm 文件名 -f # 对，后面加上-f, 暴力的删除 如果，只想删除暂存区域的文件，而工作目录中的文件保留，可以执行下面命令： git rm --cached 文件名 2. 重命名文件 git mv 旧文件名 新文件名 "},"doc/git/pages/6.创建、切换、查看、合并和删除分支.html":{"url":"doc/git/pages/6.创建、切换、查看、合并和删除分支.html","title":"创建、切换、查看、合并以及删除分支","keywords":"","body":" 为什么需要创建分支？ 当我们一个版本已经发布到生产环境给用户使用了，但是呢后面新版本开发中要添加新的功能，这个时候就需要创建分支了。 创建分支 —— git branch # 创建一个名为haha的分支 > git branch haha 切换分支 —— git checkout > git checkout haha # 切换到新创建的haha分支 Switched to branch 'haha' > git checkout master # 切换回主分支 # 切换 + 创建 分支 > git checkout -b 查看分支 git branch命令会列出所有分支，当前分支前面会标一个*号。 > git branch # --decorate选项 是让git打印每次提交的指向 (即HEAD的指向) > git log --decorate commit 8606e1cb9c3552a346c39e7e986e92e1638a9c10 (HEAD -> master, origin/master, origin/HEAD) ... # --oneline选项是--decorate的精简版本，也就是一行显示一个快照 > git log --decorate --oneline 8606e1c (HEAD -> master, origin/master, origin/HEAD) debug 769ba35 build 46ee1d2 修改了样式 938adaa debug d185863 build # --graph 选项 是以图形化的方式显示 # --all 选项 显示所有分支 > git log --decorate --oneline --graph --all 合并分支：git merge > git branch # 查看当前所在分支 haha * master > git merge haha #将haha分支合并到当前分支上，也就是合并到master分支上 git merge 命令用于合并指定分支到当前分支。注意这里是切换到了master主分支，将指定分支haha合并过来。合并后，可以发现master主分支的内容和haha分支的最新提交是完全一样的。 删除分支：git branch -d > git branch -d haha Deleted branch haha (was 8606e1c). 建议：因为创建、合并及删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，其实这和直接在master分支上工作效果是一样的，但过程更安全。 "},"doc/git/pages/gitbook配置.html":{"url":"doc/git/pages/gitbook配置.html","title":"gitbook 配置","keywords":"","body":"常用插件 插件 描述 highlight 默认的代码高亮插件，通常会使用 prism 来替换。 anchor-navigation-ex-toc 给主内容区自动生成目录、和一个返回顶部的按钮。 theme-comscore search 默认搜索组件 Prism 基于 Prism 的代码高亮 jsfiddle 插入 jsFiddle 组件 jsBin 插入 jsBin 组件 ook-summary-scroll-position-saver 自动保存左侧目录区域导航条的位置。 disqus 使用评论插件 splitter 在左侧目录和右侧内容之间添加一个可以拖拽的栏，用来调整两边的宽度。 Gitbook默认带有5个插件： highlight search sharing font-settings livereload 如果要去除自带的插件， 可以在插件名称前面加 -: \"plugins\": [ \"-search\" ] "},"doc/html_css/":{"url":"doc/html_css/","title":"Introduction","keywords":"","body":"Introduction "},"doc/html_css/pages/1. html基础.html":{"url":"doc/html_css/pages/1. html基础.html","title":"HTML基础","keywords":"","body":"HTML 发展历史 超文本标记语言，即HTML（Hypertext Markup Language），是用于描述网页文档的一种标记语言。 XHTML 1.0——发布于2000年1月26日，是W3C推荐标准，后来经过修订于2002年8月1日重新发布。 XHTML 1.1, 于2001年5月31日发布 HTML 4.0 同样也加入了很多特定浏览器的元素和属性，但是同时也开始“清理”这个标准，把一些元素和属性标记为过时的，建议不再使用它们。HTML的未来和CSS结合会更好。 HTML5 草案的前身名为 Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的 HTML 工作团队。 声明 用处 声明帮助浏览器正确地显示网页。Web 世界中存在许多不同的文档。只有了解文档的类型，那么浏览器才能正确地显示文档。HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 的用处。 它不是 HTML 标签。声明它只是给浏览器提供一个信息，即当前网页HTML 是用的哪一个版本的。 不同版本HTML 声明 HTML 5 HTML 4.01 XHTML 1.0 HTML 5 语义标签 语义化标签使得页面的内容结构化，见名知义 标签 描述 定义页面或区段的头部 定义页面或区段的尾部； 定义页面或区段的导航区域； 定义菜单列表。当希望列出表单控件时使用该标签。注意与nav的区别，menu专门用于表单控件。 页面的逻辑区域或内容组合； 定义正文或一篇完整的内容； 定义补充或相关内容, 不重要的内容、侧边栏； 定义一个画布。 用于描述文档或文档某个部分的细节 标签包含 details 元素的标题 定义对话框，比如提示框 hgroup 表示对整个页面或页面中的一个内容区块的标题进行组合。 figure 表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。使用figcaption元素为figure元素组添加标题。 time 表示时间值。 progress 用来表示进度。 video 视频标签, 用于在播放视频，电影。 audio 音频标签, 可以实现播放声音，音乐功能。 embed 用来嵌入内容(包括各种媒体)。 meter 表示特定范围内的数值，可用于工资、数量、百分比等 max表示最大值，min表示最小值，value代表当前值。 增强型表单 HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。 输入类型 描述 color 主要用于选取颜色 date 从一个日期选择器选择一个日期 datetime 选择一个日期（UTC 时间） datetime-local 选择一个日期和时间 (无时区) email 包含 e-mail 地址的输入域 month 选择一个月份 number 数值的输入域 range 一定范围内数字值的输入域 search 用于搜索域 tel 定义输入电话号码字段 time 选择一个时间 url URL 地址的输入域 week 选择周和年 HTML5 也新增以下表单元素： 新增表单元素 描述 元素规定输入域的选项列表, 使用元素的list属性与 元素的 id 绑定 提供一种验证用户的可靠方法, 标签规定用于表单的密钥对生成器字段。 用于不同类型的输出, 比如计算或脚本输出 HTML5 新增的表单属性: 新增表单属性 描述 placehoder 简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。 required 是一个 boolean 属性。要求填写的输入域不能为空 pattern 描述了一个正则表达式用于验证元素的值。 min、max 设置元素最小值与最大值 step 为输入域规定合法的数字间隔。 height、 width 用于 image 类型的 标签的图像高度和宽度。 autofocus 是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。 multiple 是一个 boolean 属性。规定元素中可选择多个值。 HTML5中 废弃的标签 能用CSS代替的元素：包含basefont、big、center、font、s、strike、tt、u。这些元素纯粹是为页面展示用的，表现的内容应该由css完成。 frame框架： 包含frameset、frame、noframes。HTML5中不支持frame框架，只支持iframe框架，或者用服务器方创建的由多个页面组成的符合页面的形式，删除以上这三个标签。 只有部分浏览器支持的元素： 包含applet、bgsound、blink、marquee等标签。 阅读： https://www.cnblogs.com/vicky1018/p/7705223.html "},"doc/html_css/pages/2. css基础.html":{"url":"doc/html_css/pages/2. css基础.html","title":"CSS基础","keywords":"","body":"css Cascading style sheet 层叠样式表 层叠： 样式是可以叠加、覆盖的。 选择器 浏览器的解析css方式是从右向左的。这么做事出于性能考虑、为了高效、加快解析css速度。 更快速确认哪些元素。 选择器分类 通用选择器 *{} 元素选择器 a{} ID选择器 #id 类选择器 .link{} 伪类选择器 :hover{} 伪元素选择器 ::before{} 属性选择器 [type=radio]{} 组合选择器 [type=checkbox] + label{} 否定选择器 :not(.link){} 选择器权重 ID选择器 #id{} + 100 类 属性 伪类 + 10 元素 伪元素 + 1 其他选择器 + 0 或： 内联样式表的权值为1000 ID选择器的权值为100 class类选择器的权值为10 HTML标签选择器的权值为1 另外： !important 权重最高 元素属性 优先级高 相同权重 后写的生效 非样式布局 hack 我之前了解过，甚至大学时还整理出来过一个表。但是，我只能说我实在是用不到啊，至少到今我一次都没用到过。既然是这样的话，我觉得对于这种东西我们应该有个原则：实际生产中很少用到 基本上用不到的东西，那么没必要记住它！我知道有这个东西就行了，如果工作中需要用到它 并且是没它不行的话，那我就上网搜一下它的用法就ok了。另外，对于这么少见、并且到今天来看有点奇葩的技术实现，我们最好的办法是 能不用则不用。用它，对于日后项目代码维护可能也是一种麻烦。 "},"doc/html_css/pages/3. CSS 布局.html":{"url":"doc/html_css/pages/3. CSS 布局.html","title":"CSS布局","keywords":"","body":"布局方式 table 布局 （简单） float 布局 + margin inline-block 布局 flexbox布局 背景知识 盒模型 宽度: width 高度: margin 占用空间的宽度： width + padding 2 + boder 2; 占用空间的高度： height + padding 2 + boder 2; display / position 确定元素的显示类型 block/inline/inline-block 确定元素的位置 static/relative/absolute/fixed flexbox布局（弹性盒子） 现代布局方式。 弹性盒子 盒子本来就提供并列的 指定宽度即可 float（浮动） 布局 整个CSS属性中，最不好理解最麻烦的一个属性。 元素“浮动” 脱离文档流 但不脱离文本流 inline-block 布局 像文本一样来排列block元素 没有清除浮动的元素 需要处理间隙 响应式布局 主流网站上使用的布局 国内： float + margin 国外： flexbox布局 "},"doc/html_css/flexbox/flexbox.html":{"url":"doc/html_css/flexbox/flexbox.html","title":"Flexbox 布局","keywords":"","body":"参考 Flex 布局语法教程 | w3c Flexbox 布局的最简单表单 Flexbox布局详解 图解CSS Flexbox布局 10分钟学会基本的 Flexbox 布局 "},"doc/html_css/pages/4. Css效果.html":{"url":"doc/html_css/pages/4. Css效果.html","title":"CSS效果","keywords":"","body":"box-shadow text-shadow border-radius background clip-path D3-transform "},"doc/html_css/pages/5. Css 动画.html":{"url":"doc/html_css/pages/5. Css 动画.html","title":"CSS动画","keywords":"","body":"动画简介 transition 动画 keyframes 动画 逐帧动画 首先，我们指出几个概念： 转换：是使元素改变形状、尺寸和位置的一种效果。 过渡：是元素从一种样式逐渐改变为另一种的效果。（可以对一个或多个属性进行改变） 动画 : 是使元素从一种样式逐渐变化为另一种样式的效果。（可以改变任意多的样式任意多的次数。） 一、CSS 3 过渡 —— transition CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。 要实现这一点，必须规定两项内容： 规定您希望把效果添加到哪个 CSS 属性上 规定效果的时长 实例： div { transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */ } div:hover { width:300px; } 注释：如果时长未规定，则不会有过渡效果，因为默认值是 0。 效果开始于指定的 CSS 属性改变值时。CSS 属性改变的典型时间是鼠标指针位于元素上时： 再看一个例子： div { transition: width 1s linear 2s; /* Firefox 4 */ -moz-transition:width 1s linear 2s; /* Safari and Chrome */ -webkit-transition:width 1s linear 2s; /* Opera */ -o-transition:width 1s linear 2s; } 速度曲线 速度曲线的默认值是：ease 二、转换 转换是使元素改变形状、尺寸和位置的一种效果。css3转换分为2D转换和3D转换两种。通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。 2.1 2D转换 2.2 3D转换 CSS3 允许您使用 3D 转换来对元素进行格式化。 在本章中，您将学到其中的一些 3D 转换方法： rotateX()：使元素围绕其 X 轴以给定的度数进行旋转。 rotateY()：使元素围绕其 Y 轴以给定的度数进行旋转。 div { transform: rotateX(120deg); -webkit-transform: rotateX(120deg); /* Safari 和 Chrome */ -moz-transform: rotateX(120deg); /* Firefox */ } div { transform: rotateY(130deg); -webkit-transform: rotateY(130deg); /* Safari 和 Chrome */ -moz-transform: rotateY(130deg); /* Firefox */ } 三、动画 —— @keyframes 规则 + animation属性 @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 div { animation: myfirst 5s; -moz-animation: myfirst 5s; /* Firefox */ -webkit-animation: myfirst 5s; /* Safari 和 Chrome */ -o-animation: myfirst 5s; /* Opera */ } @keyframes myfirst { from {background: red;} to {background: yellow;} } @-moz-keyframes myfirst /* Firefox */ { from {background: red;} to {background: yellow;} } @-webkit-keyframes myfirst /* Safari 和 Chrome */ { from {background: red;} to {background: yellow;} } @-o-keyframes myfirst /* Opera */ { from {background: red;} to {background: yellow;} } 当您在 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长 对于上面动画实例： div: 就是动画选择器 myfirst: 动画名 请用百分比来规定变化发生的时间，或用关键词 \"from\" 和 \"to\"，等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 实例-2： 改变背景色和位置。 @keyframes myfirst { 0% {background: red; left:0px; top:0px;} 25% {background: yellow; left:200px; top:0px;} 50% {background: blue; left:200px; top:200px;} 75% {background: green; left:0px; top:200px;} 100% {background: red; left:0px; top:0px;} } @-moz-keyframes myfirst /* Firefox */ { 0% {background: red; left:0px; top:0px;} 25% {background: yellow; left:200px; top:0px;} 50% {background: blue; left:200px; top:200px;} 75% {background: green; left:0px; top:200px;} 100% {background: red; left:0px; top:0px;} } @-webkit-keyframes myfirst /* Safari 和 Chrome */ { 0% {background: red; left:0px; top:0px;} 25% {background: yellow; left:200px; top:0px;} 50% {background: blue; left:200px; top:200px;} 75% {background: green; left:0px; top:200px;} 100% {background: red; left:0px; top:0px;} } @-o-keyframes myfirst /* Opera */ { 0% {background: red; left:0px; top:0px;} 25% {background: yellow; left:200px; top:0px;} 50% {background: blue; left:200px; top:200px;} 75% {background: green; left:0px; top:200px;} 100% {background: red; left:0px; top:0px;} } 实例-3： div { animation: myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation: myfirst 5s linear 2s infinite alternate; /* Safari 和 Chrome: */ -webkit-animation: myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation: myfirst 5s linear 2s infinite alternate; } 四、过渡和动画的区别在哪？ 我觉得，动画与过渡之间最大的区别在于，动画可以在动画开始和结束之间进行任意的控制。也就是可以改变任意多的样式任意多的次数。开发人员可以更随意的定义动画各阶段的效果。所以，动画就是添加了过程细化定制的过渡。 面试题 写一个动画，一个div旋转着从左边一道右边 div { width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /*Safari and Chrome*/ } @keyframes mymove { from {left:0px;} to {left:500px; transform: rotate(360deg) } } @-webkit-keyframes mymove /*Safari and Chrome*/ { from {left:0px;} to {left:500px; transform: rotate(360deg)} } animation和tansition的区别 animation 更好，因为他能让我们更精确的控制动画过程。 "},"doc/html_css/pages/6. 预处理器.html":{"url":"doc/html_css/pages/6. 预处理器.html","title":"预处理器","keywords":"","body":"介绍 什么是css预处理器 Css预处理器 是一种编程语言，它为css 增加了一些编程特性，将css作为目标生成文件。然后，开发者只要使用这种语言进行编码工作。 Css存在的问题： 语法不够强大 比如纯css是无法嵌套书写的，导致模块化开发中书写很多重复的选择器。 没有变量和合理的样式复用机制 是的逻辑上相关的属性值必须以字面量的形式重复输出，导致项目样式部分代码难以维护； 所以，我们需要预处理器提供纯 css 缺失的样式层复用机制、减少多余代码、提高样式代码的可维护性； Less 嵌套 变量 mixin extend loop import Sass 嵌套 变量 mixin extend loop import stylus stylus中文文档 预处理器框架 "},"doc/html_css/pages/7. Bootstrap.html":{"url":"doc/html_css/pages/7. Bootstrap.html","title":"Bootstrap","keywords":"","body":"简介 基本用法 JS 组件 响应式布局 定制化 "},"doc/html_css/pages/8. CSS 工程化方案.html":{"url":"doc/html_css/pages/8. CSS 工程化方案.html","title":"Css工程化方案","keywords":"","body":""},"doc/html_css/pages/9-1 vue中使用css.html":{"url":"doc/html_css/pages/9-1 vue中使用css.html","title":"Vue中的Css","keywords":"","body":""},"doc/html_css/重点思考/如何减少重写和重绘.html":{"url":"doc/html_css/重点思考/如何减少重写和重绘.html","title":"如何减少重排和重绘","keywords":"","body":"什么是重排？什么是重绘？ 重排：是引起DOM树重新计算的行为 重绘：一个元素外观的改变（如color）所触发的浏览器行为 一个页面由两部分组成 DOM：描述该页面的结构 render：描述 DOM 节点 (nodes) 在页面上如何呈现 当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 重绘repaint。 如果变化涉及 元素尺寸 重新计算 , 浏览器则抛弃 原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 重排reflow。 重绘不会带来重新布局，并不一定伴随重排; 但是重排一定会引起浏览器的重绘 常见的触发重排操作： DOM树的结构变化，如节点的增减、移动； DOM元素的几何属性变化，如外边距、内边距、边框厚度、宽高、等几何属性)； 窗口属性的获取和尺寸改变，如offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)； 什么是回流？ 和重排之间的关系？ 回流 === 重排，两种说法而已，指的是同一个意思 如何减少重排重绘的影响范围？ 1. 分离读写操作; 2. 样式集中改变; 3. 使用absolute脱离文档流; 4. 使用 display:none； 1、分离读写操作,如： var curLeft=div.offsetLeft; var curTop=div.offsetTop; div.style.left=curLeft+1+'px'; div.style.top=curTop+1+'px'; 2、 将多次改变样式属性的操作合并成一次操作 3、 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 4、 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 5、 在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。 6、 在需要经常取那些引起浏览器重排的属性值时，要缓存到变量，如窗口的offsetTop、offsetLeft事先缓存 参考 前端性能优化：细说浏览器渲染的重排与重绘 从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ 面试汇总——重绘和重排的区别 html-什么是重排和重绘？如何减少影响的范围 "},"doc/html_css/重点思考/浏览器兼容性.html":{"url":"doc/html_css/重点思考/浏览器兼容性.html","title":"浏览器兼容性","keywords":"","body":""},"doc/html_css/重点思考/flex布局面试题.html":{"url":"doc/html_css/重点思考/flex布局面试题.html","title":"Flex 布局面试","keywords":"","body":""},"doc/html_css/重点思考/动画.html":{"url":"doc/html_css/重点思考/动画.html","title":"css3动画","keywords":"","body":"参考 vue使用css3实现无限旋转动画——面试 50道CSS基础面试题（附答案） "},"doc/html_css/面试题/html.html":{"url":"doc/html_css/面试题/html.html","title":"html 篇","keywords":"","body":"doctype是什么？有哪些类型？ doctype用于声明文档类型； HTML4的doctype有三种：过渡的（不严格）//严格的（不允许使用任何表现层的表示和属性）//框架的 input有哪些新类型？简要说明其用法。 email || url || number || range || Date || pickers (date, month, week, time, datetime, datetime-local) || search || color ==大多数浏览器不支持== 对web标准化(或网站重构)知道哪些相关的知识,简述几条你知道的Web标准? 网页主要有三部分组成：结构（Structrue）、表现（presentation）和行为（Behavior）。对应的网站标准也分为三方面： 结构化标准语言，主要包括XHTML和XML； 表现标准主要包括css 行为标准主要包括对象模型（如W3C DOM）、ECMAScript等 说几条XHTML规范的内容(至少3条) 所有的标记都必须有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的xml标记都必须合理嵌套 所有的属性值都必须用引号“”括起来 所有的 给所有属性赋一个值 简述DIV元素和span元素的区别 div是一个块级元素，span是内嵌元素。 块元素相当于内嵌元素在前后各加了一个换行。 其实，块元素和行内元素也不是一成不变的，只要给块元素定义display：inline，块元素就变成了内嵌元素，同样的，给内嵌元素定义了display：block就变成了块元素了。 HTML5 html5有哪些新特性、移除了那些元素？ 新特性： canvas video和audio标签 本地存储：localStorage和sessionStorage 语义化新标签：article、footer、header、nav、section 表单控件新类型 地理定位Geolocation 移除的元素： big/center/tt/u/s/frame/frameset/noframes 如何处理HTML5新标签的浏览器兼容问题？ 如何区分 HTML 和 HTML5？ DOCTYPE声明\\新增的结构元素\\功能元素 多终端页面适配是怎样实现的？ 1.使用淘宝的rem.js，基本原理是根据通过dpr设置缩放比，实现布局视口大小，然后通过js动态计算font-size 2.根据设计稿的大小，设置一个参考值计算font-size "},"doc/html_css/面试题/css.html":{"url":"doc/html_css/面试题/css.html","title":"css 篇","keywords":"","body":"css 选择器 CSS选择器有哪些？哪些属性可以继承？ CSS选择符： id选择器(#myid) 类选择器(.myclassname) 标签选择器(div, h1, p) 相邻选择器(h1 + p) 子选择器（ul > li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=\"external\"]） 伪类选择器（a:hover, li:nth-child） 可继承的属性：font-size, font-family, color 不可继承的样式：border, padding, margin, width, height 优先级（就近原则）： !important > [ id > class > tag ] !important > 比内联优先级高 CSS 选择器优先级算法如何计算？ 元素选择符： 1 class选择符： 10 id选择符：100 元素标签：1000 !important声明的样式优先级最高，如果冲突再进行计算。 如果优先级相同，则选择最后出现的样式。 继承得到的样式的优先级最低 选择器权重计算 布局 实现两列布局，左边自适应，右边固定宽度 removeProp demo *{margin:0; padding:0;} html,body{height:100%;width:100%;overflow: hidden;} div{height:100%;position:absolute;} .box1{width:300px;background: pink;} .box2{width:100%;background: #0f0;left:300px;} [浏览器打开](file:///Users/g-dragon/MyBook/html_css_book/example/%E5%B8%83%E5%B1%80_%E5%B7%A6%E8%BE%B9%E8%87%AA%E9%80%82%E5%BA%94-%E5%8F%B3%E8%BE%B9%E5%9B%BA%E5%AE%9A.html) --> 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度 外层div使用position：relative；高度要求自适应的div使用position: absolute; top: 100px; bottom: 0; left: 0 一个满屏品字布局如何设计? 第一种真正的品字： 三块高宽是确定的； 上面那块用margin: 0 auto;居中； 下面两块用float或者inline-block不换行； 用margin调整位置使他们居中。 第二种全屏的品字布局: 上面的div设置成100%， 下面的div分别宽50%，然后使用float或者inline使其不换行。 如何实现水平垂直居中 [浏览器打开](file:///Users/g-dragon/MyBook/html_css_book/example/%E5%B8%83%E5%B1%80_%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html) --> 1、使用定位 .parent{ position:relative; } .child{ position:absolute; top: 50%; transform: translateY(-50%); left: 50%; transform: translateX(-50%); } 2、使用css3 的flex .parent{ display: flex; justify-content:center; align-items: center; } 3、 将子元素转为inline-block, 利用父元素可以设置行内元素水品那个居中的text-align:center来进行水平居中； 在html中再创造出一个与子元素同级的行内元素，利用vertical-align:center进行垂直居中。 hello .parent { width: 300px; height: 400px; text-align: center; border: 1px solid #000; } .child { display: inline-block; vertical-align: middle; } .parent span { width: 0; height: 100%; vertical-align: middle; display: inline-block; } float 用三种方法清除浮动 在父级末尾添加空div，并设css样式clear:both; 父级使用伪类after,具体如下：.parent:after { position: absolute; display: block; height: 0; content: \"\"; clear: both; } .parent { zoom:1;//兼容IE } 父级设置height 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？ 浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。 浮动带来的问题： 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。 清除浮动的方式： 父级div定义height 最后一个浮动元素后加空div标签 并添加样式clear:both。 包含浮动元素的父标签添加样式overflow为hidden或auto。 父级div定义zoom 设置元素浮动后，该元素的display值是多少？ 设置元素浮动后，该元素的display值是多少？ block ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 ::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。 :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after display display有哪些常用属性值，各是什么意思？ 属性值 描述 nline（默认） 内联 none 隐藏 block 块显示，独占一行 table 表格显示 list-item 项目列表 inline-block 行内块级元素，实际宽度根据内容决定 display:none与visibility：hidden的区别？ display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）; visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）; display:inline-block 什么时候会显示间隙？ 有空格时候会有间隙 解决：移除空格 margin正值的时候 解决：margin使用负值 使用font-size时候 解决：font-size:0、letter-spacing、word-spacing position position 有哪些属性值，各表示什么意思？ 属性值 描述 static（默认） 按照正常文档流进行排列； relative（相对定位） 不脱离文档流，参考自身静态位置(通过 top, bottom, left, right)定位； absolute(绝对定位) 参考距其它最近的一个不为static的父级元素（通过top, bottom, left, right)定位； fixed(固定定位) 它的参照对像是固定的，即可视窗口 position为absolute、relative、fixed的定点位置。 absolute：相对与除了static定位的父集元素; relative：相对于自身原来的起点位置; fixed：相对于可视窗口 position跟display、overflow、float这些特性相互叠加后会怎么样？ display属性规定元素应该生成的框的类型； position属性规定元素的定位类型； float属性是一种布局方式，定义元素在哪个方向浮动。类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。 position:fixed; 在android下无效怎么处理？ 其他 用css画一个三角形 triangle .box1{ width:0; height:0; border:50px solid rgba(0,0,0,0); border-bottom-color:#f00; } 用纯CSS创建一个三角形的原理是什么？ 首先，需要把元素的宽度、高度设为0。然后设置边框样式。 width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid transparent; border-right: 40px solid transparent; border-bottom: 40px solid #ff0000; style标签写在body后与body前有什么区别 页面加载自上而下 当然是先加载样式。 写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题） CSS属性overflow属性定义溢出元素内容区的内容会如何处理? 属性值 描述 scroll 必会出现滚动条 auto 子元素内容大于父元素时出现滚动条 visible 溢出的内容出现在父元素之外 hidden 溢出隐藏 阐述一下CSS Sprites 将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position 的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？ png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。 jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。 gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果. webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符, 这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 解决方法： 可以将代码全部写在一排 浮动li中float：left 在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px 让页面里的字体变清晰，变细用CSS怎么做？ -webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。 你对line-height是如何理解的？ 行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。 单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。 多行文本垂直居中：需要设置display属性为inline-block。 视差滚动效果？ 视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。 CSS3实现 优点：开发时间短、性能和开发效率比较好， 缺点: 不能兼容到低版本的浏览器 jQuery实现 通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。 优点：能兼容到各个版本的，效果可控性好。 缺点：开发起来对制作者要求高。 插件实现方式 例如：parallax-scrolling，兼容性十分好。 全屏滚动的原理是什么？用到了CSS的哪些属性？ 原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现 overflow：hidden；transition：all 1000ms ease； 对BFC规范(块级格式化上下文：block formatting context)的理解？ BFC规定了内部的Block Box如何布局。 定位方案： 内部的Box会在垂直方向上一个接一个放置。 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。 每个元素的margin box 的左边，与包含块border box的左边相接触。 BFC的区域不会与float box重叠。 BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算BFC的高度时，浮动元素也会参与计算。 满足下列条件之一就可触发BFC: 根元素，即html float的值不为none（默认） overflow的值不为visible（默认） display的值为inline-block、table-cell、table-caption position的值为absolute或fixed 上下margin重合的问题 在重合元素外包裹一层容器，并触发该容器生成一个BFC。 .aside { margin-bottom: 100px; width: 100px; height: 150px; background: #f66; } .main { margin-top: 100px; height: 200px; background: #fcc; } .text { /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/ overflow: hidden; /*此时已经触发了BFC属性。*/ } CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？ 当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。 chrome中，使用collapse值和使用hidden没有区别。 firefox，opera和IE，使用collapse值和使用display：none没有什么区别。 在网页中的应该使用奇数还是偶数的字体？为什么呢？ 使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。 Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。 margin和padding分别适合什么场景使用？ 何时使用margin： 需要在border外侧添加空白 空白处不需要背景色 上下相连的两个盒子之间的空白，需要相互抵消时。 何时使用padding： 需要在border内侧添加空白。 空白处需要背景颜色。 上下相连的两个盒子的空白，希望为两者之和。 兼容性的问题： 在IE5 IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display：inline解决。 padding百分比是相对于父级宽度还是自身的宽度 margin,padding的百分比是相对与父元素的宽度来进行计算 元素竖向的百分比设定是相对于容器的高度吗？ 当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。 link和@import引入css的区别 除了写法上面的区别之外，最大的区别在于link会和dom结构一同加载渲染，而@import只能能dom结构加载完成以后才能渲染页面 CSS优化、提高性能的方法有哪些？ 避免过度约束 避免后代选择符 避免链式选择符 使用紧凑的语法 避免不必要的命名空间 避免不必要的重复 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么 避免！important，可以选择其他选择器 尽可能的精简规则，你可以合并不同类里的重复规则 浏览器是怎样解析CSS选择器的？ CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。 这两种匹配规则 性能差别是很大的，因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。 而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的 Attachment过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。 盒模型相关 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？ 标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin 低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin box-sizing属性？ 用来控制元素的盒子模型的解析模式，默认为content-box context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽 border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽 属性值 描述 box-sizing:content W3C 标准盒模型 box-sizing: border-box; IE盒模型（怪异） css3 CSS3新增伪类有那些? p:first-of-type 选择属于其父元素的首个元素 p:last-of-type 选择属于其父元素的最后元素 p:only-of-type 选择属于其父元素唯一的元素 p:only-child 选择属于其父元素的唯一子元素 p:nth-child(2) 选择属于其父元素的第二个子元素 :enabled :disabled 表单控件的禁用状态。 :checked 单选框或复选框被选中。 CSS3有哪些新特性？ RGBA和透明度 background-image background-origin(content-box/padding-box/border-box) background-size background-repeat word-wrap（对长的不可分割单词换行）word-wrap：break-word 文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色） font-face属性：定义自己的字体 圆角（边框半径）：border-radius 属性用于创建圆角 边框图片：border-image: url(border.png) 30 30 round 盒阴影：box-shadow: 10px 10px 5px #888888 媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性 动画 如果需要手动写动画，你认为最小时间间隔是多久，为什么？ 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。 响应式设计 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。 基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。 页面头部必须有meta声明的viewport。 移动端的布局用过媒体查询吗？ 通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。 里边 CSS : @media only screen and (max-device-width:480px) {/css样式/} 流式布局如何实现，响应式布局如何实现 流式布局：按照百分比来适配浏览器网页，有很大的缺陷：不同的屏幕下面，元素宽高是不一样的，但是问题、图片依旧是以px为单位不会变的，看起来会有不协调的情况 响应式布局： 根据css3的媒体查询技术，media query 是响应式设计的核心，他能和浏览器进行提前的沟通，给到浏览器适合的布局 flexbox 请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？ 该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。 在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。 试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。 bootstrap bootstrap 特点 网格系统（Grid System），用于页面布局。 丰富的布局组件。（如：下拉菜单、分页、导航栏） 一些插件 移动端 移动端布局方案 使用用rem布局.：rem是css的单位，是根据根元素即html元素的的字体的font-size的值来等比计算的。 预处理器 使用 CSS 预处理器吗？ Less sass CSS常见兼容性问题 不同浏览器的标签默认的margin和padding不一样。 * { margin: 0; padding: 0; } 或者，对样式重置。重置代码网上很多。 请介绍一下margin “塌陷”问题。 IE6双边距bug 块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性 很简单，给浮动的元素加上display: inline; Div居中问题 问题：IE7、IE8、IE9在设置了margin-left和margin-right为auto后，并不能使div居中显示，其他行。 解决：设定body居中，定义text-algin: center。 对齐文本和文本输入 问题：当input元素在设置了高时，在IE7、IE8、IE9下会出现文本和文本输入框不能对齐的现象，其他正常，包括opera 解决：vertical-align:middle; IE盒模型 和 w3c的标准盒模型 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型： 从上图可以看到 标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 从上图可以看到 IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。 网页中的盒子模型；我们常常要控制盒子模型的宽度width: w3c中的盒子模型的宽: 包括 margin + border + padding + width; width:margin*2+border*2+padding*2+width; height:margin*2+border*2+padding*2+height; IE中的盒子模型的width: 也包括 margin + border + padding + width; 上面的两个宽度相加的属性是一样的。不过在 IE 中 content 的宽度包括 padding 和 border 这两个属性； 例如一个盒子模型如下： div { margin: 20px; border: 10px; padding: 10px; width: 200px; height: 50px; } 如果用w3c盒子模型解释，那么这个盒子模型占用的 宽度为：20*2 + 10*2 + 10*2 + 200 = 280px; 高度：20*2 + 10*2 + 20*2 + 50 = 130px; 盒子的实际宽度大小为: 10*2 + 10*2 + 200 = 240px; 实际高度：10*2 + 10*2 + 50 = 90px; 用ie的盒子模型解释 ： 盒子在网页中占据的大小为: 20*2 + 200 = 240px; 高：20*2 + 50 = 90px; 盒子的实际大小为：宽度:200px, 高度:50px; 我们常常理解的盒子模型是w3c这样的盒子模型 CSS3中-moz、-ms、-webkit和-o分别代表什么意思 -moz-：代表FireFox浏览器私有属性 -ms-：代表IE浏览器私有属性 -webkit-：代表safari、chrome浏览器私有属性 -o-：代表opera浏览器私有属性 什么是媒介查询？ 怎么写？ 媒介类型？ CSS3 没接查询@media 也称为媒体查询。 通过@media 媒介查询，可以对不同媒体类型设置特定样式。 写法 /* 如果文档宽度小于 300 像素则修改背景颜色 */ @media screen and (max-width: 300px) { body { background-color:lightblue; } } /* 手机等小屏幕手持设备 */ @media screen and (min-width: 320px) and (max-width: 480px) { body { background: yellow; } } /* 平板之类的宽度 1024 以下设备 */ @media only screen and (min-width: 321px) and (max-width: 1024px) { body { background: blue; } } /* PC客户端或大屏幕设备: 1028px 至更大 */ @media only screen and (min-width: 1029px) { body { background: green; } } /* 竖屏 */ @media screen and (orientation:portrait) and (max-width: 720px) { 对应样式 } /* 横屏 */ @media screen and (orientation:landscape) { 对应样式 } Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 怎么让Chrome支持小于12px 的文字？ p { font-size: 10px; -webkit-transform: scale(0.8); //0.8是缩放比例 } 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。 解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {} "},"doc/js/part1/1.1 课程简介.html":{"url":"doc/js/part1/1.1 课程简介.html","title":"1.1 课程简介","keywords":"","body":" 1、课程简介 2、前言 3、几个面试题 4、如何搞定所有的面试题 "},"doc/js/part1/1.5 JS-Web-API（上）.html":{"url":"doc/js/part1/1.5 JS-Web-API（上）.html","title":"1.5 JS-Web-API（上）","keywords":"","body":"从基础到JSWebAPI 常说的JS(浏览器中执行的Js), 包括两部分： JS基础知识（ECMA262标准） JS-Web-API (w3c标准) DOM DOM本质 DOM本质是html字符串，通过浏览器对html结构化得到DOM树，以方便JS识别和操作。 DOM节点操作 获取元素、元素集合 通过js获取的Dom还js对象或者js对象集合。 getElementById(); //元素 getElementsByTagName(); //元素集合 getElementsByClassName(); //元素集合 querySelector(); //元素集合 获取属性——property 获取属性、添加属性 —— getAttribute() 解答——几个思考 DOM是哪种基本的数据结构？ 树 DOM操作常用的API有哪些？ 获取DOM节点，以及节点的property和Attribute。 获取父节点、子节点 新增节点、删除节点 DOM节点的Attribute和property有啥不同？ propery 是针对一个JS节点对象属性修改 获取。 Attribute 是针对html标签属性的修改 获取。 BOM 题目 如何检测浏览器类型 // navigator var ua = navigator.userAgent; var isChrome = ua.indexOf('chrome'); console.log( isChrome ); // screen console.log( screen.width ); console.log( screen.height ); 拆解url各个部分 // location location.href; location.protocol; location.pathname; location.search; location.has; //history history.back(); history.forward(); 知识点 navigator screen location history BOM节点操作 Browser Object Model "},"doc/js/part1/1.6 JS-Web-API（下）.html":{"url":"doc/js/part1/1.6 JS-Web-API（下）.html","title":"1.6 JS-Web-API（下）","keywords":"","body":"事件 题目 编写一个通用的事件监听函数 看 知识点 ==> 通用事件绑定 描述事件冒泡过程 DOM树形结构，一层一层网上冒泡 事件冒泡 阻止事件冒泡 事件冒泡应用 对于一个无线下拉加载图片的页面，如何给每个图片添加绑定事件。 使用事件代理 知识点 通用事件绑定 // 常规绑定方法 var elem = document.getElementById('div1'); elem.addEventListener('click', function (event) { // .. }) // 封装一个通用方法 function bindEvent(elem, type, fn) { elem.addEventListener(type, fn); } // 使用 var a = document.getElementById('linka'); bindEvent(a, 'click', function() { // .... }); 完善通用事件绑定函数 function bindEvent(elem, type, selector, fn) { if (fn == null) { fn = selector; selector = null; } elem.addEventListener(type, function(e) { if (selector) { var target = e.target; if (target.matches( selector )) { fn.call(target, e); } } else { fn(e); } }) } // 使用代理 var div1 = document.getElementById('div1'); bindEvent(div1, 'click', 'a', function(e) { console.log(this.innerHTML); }); // 不使用代理 var a = document.getElementById('a1') bindEvent(a, 'click', function(e) { console.log(a.innerHTML); }); 事件冒泡 激活 取消 取消 取消 取消 取消 var p1 = document.getElementById('p1'); var body = document.body; bindEvent(p1, 'click', function(e) { e.stopPropagation(); //阻止事件冒泡 alert('激活') }); bindEvent(body, 'click', function(e){ alert('取消'); }); 事件代理 a1 a2 a3 a4 var div1 = document.getElementsByClassName('div1'); div1.addEventListener('click', function(e) { var target = e.target; if (target.nodeName == 'A') { alert(target.innerHTML); } }); 为什么使用代理 代码简洁 减少浏览器内存占用 关于IE低版本的兼容性 IE低版本使用attachEvent绑定事件，和w3c标准不一样。 IE低版本使用量非常少，很多网站都已经不支持。 建议对于IE低版本兼容性：了解即可，无需深究。 如果遇到对于IE低版本要求苛刻的公司描述，果断放弃。 Ajax 题目 手动编写一个Ajax, 不依赖第三方库 跨域的几种实现方式 知识点 XMLHttpRequest var xhr = new XMLHttpRequest(); xhr.open('POST', '/api', false); xhr.onreadystatechange = function() { // 这里函数使用异步执行 if (xhr.readyState == 4) { if (xhr.status == 200) { alert( xhr.responseText ); } } } xhr.send( null ); IE兼容性问题 在IE低版本上使用ActiveXObject, 和w3c标准不一样。 状态码说明 readyState 0 - (未初始化)还没有调用send()方法 1 - (载入)已经调用send()， 正在发送请求 2 - (载入完成)send()方法执行完成，已经接受到全部响应内容 3 - (交互)正在解析响应内容。 4 - (完成)响应内容解析完成，可以在客户端调用了。 status 2xx 表示成功处理请求 3xx 需要重定向，浏览器直接跳转 4xx 客户端请求错误 5xx 服务器端错误 跨域 什么是跨域 浏览器有一个同源策略，不允许ajax访问其他域接口 跨域条件 协议、域名、端口，有一个不一样就算跨域。 三个可跨域标签 有三个标签是可以跨域的。 三个标签场景： 可以用于打点统计，统计网站可能是其他域。 可以使用CDN, CDN也是其他域。 可以用于JSONP. 跨域注意事项 所有的跨域请求都必须经过信息提供方允许 如果未经允许即可获取，那么浏览器同源策略出现漏洞。 存储 "},"doc/js/part1/1.7 开发环境.html":{"url":"doc/js/part1/1.7 开发环境.html","title":"1.7 开发环境","keywords":"","body":"IDE git 网络git服务有： coding: https://coding.net/ github: https://github.com/ 码云: https://gitee.com/ git 常用命令： git add ./文件 # 将修改过的 or 新增的东西全部提交 git add . # 只提交特定文件 or 文件夹 git add 文件名/文件夹 # 还原 如：发现改错了，我要把它还原回去 git checkout xxx # 提交到本地仓库，缓存区 git commit -m 'xxx' # 提交到远程仓库 git push origin master # 将远端最新代码更新到本地 git pull origin master 模块化 AMD CommonJS 构建工具 安装nodejs 安装配置webpack 安装webpack: npm i webpack -save-dev 在项目根目录下，新建一个名为webpack.config.js的文件。 import path from 'path' import webpack from 'webpack' // 定义一个模块 module.exports = { // 配置 源码位置 context: path.resolve(__dirname, './src') // 入口文件 entry: { app: './app.js' }, // 输出配置 output: { path: path.resolve(__dirname, './dist'); //输出的目录，没有的话会创建 filename: 'bundle.js' //输出的文件名 } } 最后，在html页面引入打包后的文件。 使用jQuery // 安装 npm i jquery --save // 使用: 在需要用的js文件中 或者组件中引入后即可使用 import $ from 'jqery' 压缩JS 直接在webpack的配置文件中，添加一个js压缩创建即可。 修改后的webpack.config.js文件: import path from 'path' import webpack from 'webpack' // 定义一个模块 module.exports = { // 配置 源码位置 context: path.resolve(__dirname, './src') // 入口文件 entry: { app: './app.js' }, // 输出配置 output: { path: path.resolve(__dirname, './dist'); //输出的目录，没有的话会创建 filename: 'bundle.js' //输出的文件名 }, plugins: [ new webpack.optimize.UglifyJsPlugin() ] } 上线滚回 —— 上线滚回流程 上线回滚 —— linux基础命令 "},"doc/js/part1/1.8 运行环境.html":{"url":"doc/js/part1/1.8 运行环境.html","title":"1.8 运行环境","keywords":"","body":"本章知识点 页面加载的过程 性能优化 安全性 页面加载 渲染过程 几个示例 解答 性能优化 优化策略 几个示例 安全性 XSS XSRF 面试技巧 "},"doc/js/重点思考/循环与迭代.html":{"url":"doc/js/重点思考/循环与迭代.html","title":"循环与迭代","keywords":"","body":"写在前面： 几个概念理解 循环(loop) ： 最基础的概念, 所有重复的行为 递归(recursion)：在函数内调用自身, 将复杂情况逐步转化成基本情况 (数学)迭代(iterate)： 在多次循环中逐步接近结果 (编程)迭代(iterate)： 按顺序访问线性结构中的每一项 遍历(traversal)： 按规则访问非线性结构中的每一项 这些概念都表示“重复”的含义, 彼此互相交叉, 在上下文清晰的情况下, 不必做过于细致的区分. for...of for...of 语句在 可迭代的对象(包括Array, Map, Set, 参数对象（ arguments） 等等) 上创建了一个循环。 对象 不是可迭（iterable）代对象。 注意： for...of遍历的结果时元素的值。 for...in 注意： for...in 循环遍历的结果是数组元素的下标 "},"doc/js/重点思考/this指向.html":{"url":"doc/js/重点思考/this指向.html","title":"this 指向","keywords":"","body":"this 指向问题总结 首先看一道面试题： var a = 10; var foo = { a: 20, b: function() { var a = 30; return this.a; }, c: () => { var a = 40; return this.a; } }; var d = { a: 50 }; console.log(a); console.log(foo.b()); console.log(foo.c()); console.log(foo.b.bind(d)()); console.log(foo.c.bind(d)()); // 10 // 20 // 10 // 50 // 10 先说结论 纯粹的函数调用，this代表的是全局对象。即浏览器中this就是window。（严格模式下，这种情况this的值是undefined)。 作为对象方法的调用，this指向是 上一级 的对象。// 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 var o = { a: 10, b: { // a:12, fn: function() { console.log(this.a); //undefined } } } o.b.fn(); // undefined 作为构造函数调用 this就指这个新的对象实例。 apply、call 调用 this指的就是这第一个参数。（注意：如果参数为空，this指向的是全局对象） Es6中 Es6 中this指向 箭头函数和普通函数不一样的地方就是，它是没有自己的上下文环境的，所以它的this取决于包含它的 `最近的上下文环境` 箭头函数没有自己的this，他的this是继承来的，默认指向在定义他时所在的对象。 看下面代码: var s2 = 10; function Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() => this.s1++, 1000); //箭头函数，没有上下文环境，所以这里 this的指向为 Timer // 普通函数 setInterval(function () { //普通函数，有上下文环境，这里 this是函数调用里面的上下文环境，也就是全局对象 this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() => console.log('s1: ', timer.s1), 3100); // s1: 3, timer中的 s1增加了 setTimeout(() => console.log('s2: ', timer.s2), 3100); // s2: 0, timer中的 s2还是 0 setTimeout(() => console.log('s2: ', window.s2), 3100); // s3: 13, 全局对象的 s2增加了 再看一个例子： var obj2 = { name:'obj2', birth: 1990, getAge: function () { var b = this.birth; // 1990 return () => { var c='hehe'; console.log(this);//obj2 return () => { console.log(this) //obj2 箭头函数this始终指向最外层obj2； } } } }; obj2.getAge()()(); // 箭头函数中，this指向的始终是定义时所在的对象 function Fn2(name,age){ this.name=name; this.age=age; console.log(this); //obj2 return () => { console.log(this) //obj2 return () => { console.log(this) //obj2 } } } // var obj2=new Fn2('张飞','14'); //this指向obj2 // obj2(); //this指向obj2 // Fn2()()()；//如果构造函数直接当做普通函数来执行，那么全部指向最初的window //通过对比可以发现总结一下箭头函数很好的解决了this原来在函数内部指向不合理的情况。你只要记住箭头函数会继承最初 //最外层定义的this 改变 this 指向 call()、apply()、bind() Function​.prototype​.call() | MDN Function​.prototype​.apply() | MDN Function​.prototype​.bind() | MDN 面试题 1：call、apply的区别？ 只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 面试题 2：使用原生 Js 模拟实现一个 bind() 考察：bind()方法使用熟悉程度，以及call()、apply()使用区别以及选择。 JS bind()方法、JS原生实现bind() js系列十三：手写call，apply，bind及面试题解析 面试官问：能否模拟实现JS的bind方法 参考 JavaScript 的 this 原理 | 阮一峰 Javascript 的 this 用法 | 阮一峰 面试官问：JS的this指向 JavaScript中的this指向 & 更改指向 "},"doc/js/重点思考/作用域与作用域链.html":{"url":"doc/js/重点思考/作用域与作用域链.html","title":"作用域与作用域链","keywords":"","body":"深入理解 JavaScript 作用域和作用域链的工作原理 什么是作用域 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。 在JavaScript中，变量的作用域有全局作用域和局部作用域两种，局部作用域又称为函数作用域。 作用域链（Scope Chain） 什么是作用域链 从最终效果或者结果来看，作用域链可以理解为一套规则，如我们要引用一个变量，怎么查找它呢？就是借助作用域链。 至于作用域链的工作原理的话，请继续往下看。 定义代码时 —— 内部属性（[[Scope]]） 在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。 函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]， 由ECMA-262标准第三版定义，该内部属性包含了函数创建的作用域中对象的集合（即定义代码时它所能访问到的对象集合，这个集合被称 为函数的作用域链，它决定了哪些数据能被函数访问。 作用域链 是在定义时就已经确定下来的。(否定) 执行代码时 —— 内部对象（运行期上下文） 在执行此函数时，会创建一个称为 “运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。 每个运行期上下文都有自己的作用域链，用于 标识符解析。 当运行期上下文被创建时，它的作用域链会被初始化为当前运行函数的 内部属性[[Scope]] 所包含的对象。 活动对象(activation object) 函数执行 => 运行期上下文 => [[Scope]] => 活动对象 这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫 “活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示： 在函数执行过程中，每遇到一个变量，都会经历一次 标识符解析 过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。 函数执行过程中，每个标识符都要经历这样的搜索过程。 参考 深入了解 JavaScript，从作用域链开始（1） JavaScript 开发进阶：理解 JavaScript 作用域和作用域链 "},"doc/js/重点思考/闭包.html":{"url":"doc/js/重点思考/闭包.html","title":"闭包","keywords":"","body":"彻底理解 闭包 什么是闭包 其实，闭包也是函数——闭包函数。作为内部函数保持着对外部函数变量的引用。最终总结一下，闭包就是能够引用其他函数内变量（作用域）的函数； 上面对闭包的定义都只是闭包的 现象（结果） 闭包就是能够引用其他函数内变量（作用域）的函数； 闭包就是能够将变量保存在内存当中 深入闭包 js执行 作用域与作用域链 事件循环 垃圾回收机制 从JS执行开始讲起 1、每个函数都是一个作用域（函数声明的时候，会生成一个独立的作用域） 2、同一作用域内的对象可以互相访问 3、作用域呈层级包含状态（嵌套的），形成作用域链，子作用域的对象可以访问父作用域的对象，反之不能；另外子作用域会使用最近的父作用域的对象 其实第二点才是真闭包，不过我们通常把“闭包”的概念扩大到上面3点之和。基于此3点，其它无论 用法 还是 问题 都可以推出来。 一个函数执行前后内存回收过程 去看 Js垃圾回收机制和内存泄漏 篇的介绍。 闭包形成原因 哪些浏览器会发生哪些不会发生 闭包导致的问题（副作用） 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题 如何解决闭包导致的问题 解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包有哪些用途 1、变量私有化 实际业务场景中使用闭包 参考 学习Javascript闭包（Closure） | 阮一峰 图解JS闭包形成的原因 | 阮一峰 用浏览器测试几种闭包占用内存的情况 当面试官问你闭包时，他究竟想听到些什么？ "},"doc/js/重点思考/原型与原型链.html":{"url":"doc/js/重点思考/原型与原型链.html","title":"原型与原型链","keywords":"","body":"原型与原型链 我操你妈 Function 和 Object为何都是 函数对象？ 在 JavaScript 的世界中，万物皆对象！ 但是这各种各样的对象其实具体来划分的话就 2 种：函数对象、普通对象。其中 Function 和 Object 为JS自带的 函数对象。（哎？ 等等， Function 为 函数对象 可以理解，为什么 Object也是函数对象呢？带着疑问我们继续往下看。 ） 【结论】 所有最终通过 new Function() 创建的对象都是函数对象。其他的 即为普通对象。 原型与原型链 之前总结的 原型和原型链——构造函数 1. prototype: 每个函数都有一个prototype属性。 2. __proto__: 每个JavaScript对象（除null外）都有一个__proto__属性(隐式原型)。这是属性指向该对象的原型。 3. constructor: 每个原型都有一个constructor属性指向关联的构造函数 注意： 三者之间的关系图： 原型 原型对象 即prototype, 并且每个函数都有一个prototype属性。 那么什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 原型链 原型链继承 类继承与原型继承的区别 参考 Javascript继承机制的设计思想 JavaScript 深入之从原型到原型链 《前端之路》之 JavaScript原型及原型链详解 "},"doc/js/重点思考/Js垃圾回收机制和内存泄漏.html":{"url":"doc/js/重点思考/Js垃圾回收机制和内存泄漏.html","title":"Js 垃圾回收机制和内存泄漏","keywords":"","body":"Js 垃圾回收机制 和 内存泄漏 内存泄漏 什么是内存泄漏？ 内存泄漏是指一块空间使用完没有被销毁一直占用空间，这就是内存泄漏。 所以，总结一下，不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 常见引起内存泄漏的原因： 全局变量引起的内存泄漏。 闭包引起的内存泄漏。 遗忘的DOM引用 Js 垃圾回收机制 上面我们知道了什么是内存泄漏了。 对于持续运行的服务进程（daemon），必须要及时释放不再用到的内存。否则，内存占用越来越高，轻点的话会影响系统性能，要是严重的话就会导致进程崩溃。 这很麻烦，所以大多数语言提供 自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"（garbage collector）。 垃圾回收机制怎么知道，哪些内存不再需要呢？ 现在各大浏览器通常采用的垃圾回收机制有两种方法：标记清除，引用计数。 标记清除 当变量进入到内存当中会加入一个标记，当脱离内存之后也会添加一个标记。每隔段时间后垃圾回收机制会扫一下内存空间， 有需要清除的变量会把他清掉。 js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为 \"进入环境\"。从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为 \"离开环境\"。 function test(){ var a = 10; //被标记\"进入环境\" var b = \"hello\"; //被标记\"进入环境\" } test(); //执行完毕后之后，a和b又被标记\"离开环境\"，被回收 垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。 最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是 标记清除 的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数 引用计数是引用一次计个1，释放一次减个1，当引用计数为0的时候才可以清掉。在IE低版本中引用计数也会造成内存泄露。 语言引擎有一张 \"引用表\"，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。 上图中，左下角的两个值，没有任何引用，所以可以释放。 如果, 一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。 const arr = [1,2,3,4]; console.log(\"hello world\"); 上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，但是它会持续占用内存。 如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。 let arr = [1,2,3,4]; console.log(\"hello world\"); arr = null; 上面代码中，arr重置为null，就解除了对[1，2，3，4]的引用，引用次数变成了0，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用 WeakMap WeakMap 是es6提供的一种新数据结构，我们可以使用它来手动管理内存，它可以让垃圾回收机制忽略定义在其中的资源。 参考 JavaScript 内存泄漏教程 | 阮一峰 "},"doc/js/重点思考/Js事件循环.html":{"url":"doc/js/重点思考/Js事件循环.html","title":"Js 事件循环","keywords":"","body":"事件循环 参考 什么是 Event Loop？ | 阮一峰 avaScript 运行机制详解：再谈Event Loop | 阮一峰 深入浅出Javascript事件循环机制(上) | 知乎 深入浅出Javascript事件循环机制(下) | 知乎 什么是浏览器的事件循环（Event Loop）？ 并发模型与事件循环 | MDN 浅谈对事件循环（Event Loop）| 百度前端 "},"doc/js/重点思考/Promise.html":{"url":"doc/js/重点思考/Promise.html","title":"Promise","keywords":"","body":"深入浅出 Promise Promise是一个立即执行函数，但是他的成功（或失败：reject）的回调函数resolve却是一个异步执行的回调。 手写实现一个promise 参考 Promise | MDN Promise 对象 | ECMAScript 6 入门 | 阮一峰 当面试官问你Promise的时候，他究竟想听到什么？ Promise和setTimeout执行顺序 面试题 面向面试题和实际使用谈promise Javascript异步编程的4种方法 30分钟，让你彻底明白Promise原理 "},"doc/js/重点思考/class与继承.html":{"url":"doc/js/重点思考/class与继承.html","title":"class 与继承","keywords":"","body":"Class 与 继承 Js中几种继承方式比较 参考 Javascript定义类（class）的三种方法 | 阮一峰 class - 类- JavaScript | MDN 深入理解 JavaScript 中的 class | segmentfault 经典面试题：js继承方式上 经典面试题：js继承方式下 一道简单的js继承面试题来查考你是否真的透彻的了解继承 "},"doc/js/重点思考/cookie和session.html":{"url":"doc/js/重点思考/cookie和session.html","title":"Cookie 和 Seesion","keywords":"","body":"cookie 和 Session 总结 参考 理解Cookie和Session机制 底理解cookie，session，token "},"doc/js/重点思考/Cookie、localStorage与sessionStorage.html":{"url":"doc/js/重点思考/Cookie、localStorage与sessionStorage.html","title":"Cookie、localStorage 与 sessionStorage","keywords":"","body":"Cookie、localStorage 与 sessionStorage webstorage webstorage 是本地存储，存储在客户端。包括localStorage和sessionStorage。 localStorage 生命周期：localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。 大小：存放数据大小一般为 5MB。 作用域：不同浏览器无法共享localStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）. 其他：仅在客户端（即浏览器）中保存，不参与和服务器的通信。 sessionStorage 生命周期：sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。 大小：存放数据大小为一般为 5MB。 作用域: 不同浏览器无法共享sessionStorage中的信息。且相同浏览器不同页面或标签页间也是无法共享sessionStorage中信息的。(但是，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的)。 其他：仅在客户端（即浏览器）中保存，不参与和服务器的通信。 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API： localStorage.setItem(\"key\",\"value\");//以“key”为名称存储一个值“value” localStorage.getItem(\"key\");//获取名称为“key”的值 localStorage.removeItem(\"key\");//删除名称为“key”的信息。 localStorage.clear();​//清空localStorage中所有信息 实例：仿京东官网顶部的广告弹窗关闭效果 仿一下京东官网顶部的广告关闭，效果为第一次进入官网会出现广告，然后点击关闭，刷新网页不会再显示广告，但是当清除localStorage存入的数据，刷新网页会再显示广告。 html代码： x css代码: .header{ width:100%; height:80px; background:#000; } .header-a{ width:1190px; margin:0 auto; position:relative; background:url(\"images/1.jpg\") no-repeat; } .header-a a{ width:100%; height:80px; display:block; } .close{ cursor:pointer; color:#fff; position:absolute; top:5px; right:5px; background:rgb(129, 117, 117); width: 20px; text-align: center; line-height: 20px; } js代码: //localStorage方法 function haxi(){ //判断localStorage里有没有isClose if(localStorage.getItem(\"isClose\")){ $(\".header\").hide(); }else{ $(\".header\").show(); } //点击关闭隐藏图片存取数据 $(\".close\").click(function(){ $(\".header\").fadeOut(1000); localStorage.setItem(\"isClose\", \"1\"); }) } haxi(); Cookie 生命周期：在设置的过期时间以前一直有效，即使窗口或浏览器关闭。 大小：存放数据大小(长度)为4K左右，否则会被截掉。 数量：有个数限制（各浏览器不同），一般不能超过20个。 其他：与服务器端通信时，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。 但Cookie需要程序员自己封装，源生的Cookie接口不友好(http://www.jb51.net/article/6... )。看下面代码： //Cookie方法 //Cookie函数自己封装引入 function haxi() { if(getCookie(\"isClose\")){ $(\".header\").hide(); }else{ $(\".header\").show(); } $(\".close\").click(function(){ $(\".header\").fadeOut(1000); setCookie(\"isClose\", \"1\",\"s10\"); }) } haxi(); cookie的优点：具有极高的扩展性和可用性 1.通过良好的编程，控制保存在cookie中的session对象的大小。 2.通过加密和安全传输技术，减少cookie被破解的可能性。 3.只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。 4.控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。 cookie的缺点： 1.cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉。 2.安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用。 3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。 "},"doc/js/重点思考/堆内存和栈内存.html":{"url":"doc/js/重点思考/堆内存和栈内存.html","title":"堆内存和栈内存","keywords":"","body":"Js 堆内存和栈内存 JavaScript中的变量分为基本类型 和 引用类型, 而在 js引擎 中对变量的存储主要有两种位置，堆内存 和 栈内存。 栈内存主要用于存储各种基本类型的变量，包括Boolean、Number、String、Undefined、Null, 以及对象变量的指针，这时候栈内存给人的感觉就像一个线性 而堆内存主要负责像对象Object这种变量类型数据的存储. 基本类型 是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问。 引用类型 是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用 结论: 栈内存 堆内存 存储基本数据类型 存储引用数据类型 先进后出 无序存储，可根据引用直接获取 按值访问 按引用访问 存储值的大小固定 存储值的大小不定，可动态调整 由系统自动分配内存空间 由代码进行指定分配 空间小，运行效率高 空间大，运行效率相对低 参考 JavaScript栈内存和堆内存 | segmentfault JavaScript栈内存与堆内存 | 慕课网 浅析JS中的堆内存与栈内存 | 慕课网 面试题 Q: 说说什么是堆内存？什么是栈内存？区别？ 栈内存存储的是基本类型数据，堆内存存储的是引用类型数据。 栈内存存储的数据时先进后出的，但是堆内存存储的数据时无序的，可以根据引用直接获取。 栈内存 是按值查找访问，而堆内存是按引用访问的。 栈内存 存储的数据大小固定，但是堆内存存储的数据大小不固定，可动态调整。 栈内存 是由系统自动分配内存空间，而堆内存 是由代码进行指定分配。 栈内存 空间小运行效率高，而堆内存空间大运行效率相对低。 Q：const定义的值能改么？ A: 可以改变。当定义的是基本类型时是不能改变的，执行修改操作会报错。但是如果定义的是引用类型那就可以改变。 // 看下面实例 const a = '123'; a = '456'; //报错 const b = { name: 'g-dragon' }; // 对 b 修改添加属性并不会报错 b.name = 'shigongyu'; b.age = 23; 请给出下面代码的输出 var a = new String('123') var b = String('123') var c = '123' console.log(a==b, a===b, b==c, b===c, a==c, a===c) // true false true true true false 请给出下面代码的输出 var a = new String('123'); var b = new String('123'); console.log(a==b, a===b); // false, false, 因为a b 分别存储的是两个不同的地址指针 "},"doc/js/重点思考/类型转换.html":{"url":"doc/js/重点思考/类型转换.html","title":"Js 类型转换","keywords":"","body":"类型转换 相等和不相等——先转换再比较 （==） 全等和不全等——仅比较而不转换 （===） Js 强制类型转换规则： 1. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1； 2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值。 3. 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前 面的规则进行比较(如果对象没有valueOf()方法，则调用 toString())。 4. null 和undefined 是相等的。 5. 要比较相等性之前，不能将null 和 undefined 转换成其他任何值。 6. 如果有一个操作数是NaN，则相等操作符返回 false ，而不相等操作符返回 true。(重要提示：即使两个 操作数都是NaN，相等操作符也返回 false了；因为按照规则， NaN 不等于 NaN。因为NaN 是:Not a number (不是一个数字的缩写)，既然不是一个数字 那么很好理解 'A'不是一个数字 ,'B'也不是一个数字， 那么既然他们两个都不是数字 ,难道'A' === 'B'吗? 显然不是)。 7. 如果两个操作数都是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作 符返回 true；否则， 返回false。 参考阅读 为什么 [ ] 是 false 而 !![ ] 是 true JS中鲜为人知的问题： [] == ![]结果为true，而 {} == !{}却为false 面试题 判断下面代码输出的是什么？ console.log([] == []); // false console.log([] === []); // false console.log(['1'] == ['2']); // false console.log({} == {}); // false console.log({} === {}); // false console.log([] != []); // true console.log([] == ![]); // true console.log({} != {}); // true console.log({} == !{}); // false JS中鲜为人知的问题： [] == ![]结果为true，而 {} == !{}却为false 思考下面这个问题，并给出你的解释 [] == false; //true // 那么，为什么对空数组去翻还是false [] == ![]; //false ![] //false // --------------------------- // 如果上面的数组改成变量呢 [] == false // Uncaught SyntaxError: Unexpected token == //为什么啊 !{} // false 思考下面代码输出什么？ [1] + [2] - [3] === 9; // true, 相当于“12”-3 ，先toString，然后'-'会调用toNumber [1] + [2] === \"12\"; //true [1] +- [2] === \"1-2\"; //true,这要使用到Symbol.toPrimitive，这儿我自己还没太搞明白，后续再补上 1 - [2] === -1; //true "},"doc/js/重点思考/面向对象与继承.html":{"url":"doc/js/重点思考/面向对象与继承.html","title":"面向对象与继承","keywords":"","body":"面向对象 面试题： 说说你对面向对象的理解？ 其实，在面试中，当面试官问到 Js 中是怎么实现继承的，其实是考察你对 Js 面向对象的理解。换过来，假如，面试官问到你面向对象的概念，你一定要往Js继承上去回答，即： 问继承 => 考察面向对象理解 => 先说面向对象，接着说Js继承（包括有几种继承方式，这个也可以等面试官提问）； 问面向对象 => 先回答面向对象，接着说道Js继承（包括有几种继承方式，这个也可以等面试官提问）； 这个问题的回答： 在我的理解，这个世界上所有的事物都可以分类，现实生活中的任何事物我们都可以把其归为某一类事物，而单个的个体都是所在类的实例。 面向对象是以对象为中心，以消息为驱动，所以`程序=对象+消息`； 面向对象三大特点：封装、继承、多态 1. 封装：就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化。 这样做使得代码的复用性更高。 2. 继承：就是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类--有父类的行为和属性，也有自 己特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复用性。 3. 多态：封装和继承是为了使代码重用，多态则是为了实现接口重用。 多态的一大作用就是为了解耦--为了解除父子类继承的耦合度。如果说继承中父子类的关系式IS-A的关系，那么接口和实现类之之间的关 系式HAS-A。简单来说，多态就是允许父类引用(或接口)指向子类(或实现类)对象。很多的设计模式都是基于面向对象的多态性设计的。 总结一下，如果说封装和继承是面向对象的基础，那么多态则是面向对象最精髓的理论。掌握多态必先了解接口，只有充分理解接口才能 更好的应用多态。 Js 里面如何实现面向对象 构造函数 + 原型继承 继承 原型链继承 function Super() { this.name = 'gaolong'; this.age = 23; this.friends = ['yanchao', 'axiang']; } function Sub() { // } // 原型继承，即将函数原型对象指向一个构造函数实例 // 这样函数对象就继承了该构造函数上的属性方法 Sub.prototype = new Super(); let sub1 = new Sub(); let sub2 = new Sub(); // 原型链继承的问题： // 1. 因为原型对象对所有实例时共享的，所以，一旦一个实例修改了原型对象，这种改变时作用在所有实例上的； // 2. 在创建子类行的实例的时候，没法向父类的构造函数传递参数。 sub1.friends.push('xiaoxiao'); console.log(sub1.friends); console.log(sub2.friends); 构造函数继承 优点： 解决了 原型链继承 中出现的两个问题： -（1）可以传递参数。 -（2）也没有了子类共享父类引用属性的问题。 缺点： 在父类原型中定义的方法，其实是对子类不可见的（直接new constructor 的话是可见的，但是这种不属于构造函数继承）。 function Super() { this.name = \"gaolong\"; this.age = 23; this.friends = [\"yanchao\", \"axiang\"]; } function Sub() { // console.log(this); //Sub {} Super.call(this); } var sub1 = new Sub(); var sub2 = new Sub(); sub1.name = '高龙' // console.log(sub1.name); //高龙 // console.log(sub2.name); //gaolong // console.log(sub1.__proto__ == Super.prototype); //false // console.log(sub2.__proto__ == Super.prototype); //false // console.log(sub1.__proto__ == Sub.prototype); //true // console.log(sub2.__proto__ == Sub.prototype); //true var super1 = new Super(); var super2 = new Super(); super1.name = 'hhhh'; console.log(super1.name); //hhhh console.log(super2.name); //gaolong super1.say(); //My name is hhhh sub1.say(); //TypeError: sub1.say is not a function 组合继承 原型链继承 + 构造函数继承 = 组合继承 function Super() { this.name = \"gaolong\"; this.age = 23; this.friends = [\"yanchao\", \"axiang\"]; } function Sub() { Super.call(this); //{2} } Sub.prototype = new Super(); //{1} // console.log(Sub.prototype.constructor); //[Function: Super], 这是因为子类没有constructor属性，于是就找到了父类的constructor, 所以指向的是父类 Sub.prototype.constructor = Sub; //{3} var sub = new Sub(); console.log(sub.name); //gaolong 寄生组合式继承 原型继承 与 Class 继承的区别 Js 原型继承与类继承的区别 参考 前端面试回顾（1）---javascript的面向对象 | segmentfault Javascript继承机制的设计思想 | 阮一峰 Javascript 面向对象编程（一）：封装 | 阮一峰 Javascript面向对象编程（二）：构造函数的继承 | 阮一峰 Javascript面向对象编程（三）：非构造函数的继承 | 阮一峰 基于阮一峰5种继承方式的总结 | segmentfault JavaScript面向对象的程序设计 | segmentfault ECMAScript 继承机制实现 | w3cschool 面向对象编程的模式 web前端开发必懂之一：JS继承和继承基础总结 "},"doc/js/重点思考/原型继承与类继承的区别.html":{"url":"doc/js/重点思考/原型继承与类继承的区别.html","title":"Js 原型继承与类继承的区别","keywords":"","body":"类继承的实现是建立在原型继承上的，但是，并不意味着二者具有相同的功能。 原型继承和类继承实际使用 参考 征服JavaScript面试系列：类继承和原型继承的区别 JS原型继承和类式继承 掌握JavaScript：类和原型继承之间有什么区别？ 从本质认识JavaScript的原型继承和类继承 从本质认识JavaScript的原型继承和类继承 【译】精通 JavaScript： 类继承和原型继承的区别？ "},"doc/js/重点思考/new一个对象的过程.html":{"url":"doc/js/重点思考/new一个对象的过程.html","title":"Js new 一个对象的过程","keywords":"","body":"new 对象： function Person(name, age) { this.name = name; this.age = age; } var person = new Person(\"Alice\", 23); new 一个对象的四个过程 // 1. 创建一个空的简单JavaScript对象（即{}); var obj = new Object(); // 2. 链接该对象（即设置该对象的构造函数）到另一个对象。设置原型链，将obj的__proto__成员指向了Person函数对象的prototype成员对象。 obj.__proto__ = Person.prototype; // 3. 将步骤1新创建的对象作为this的上下文; var result = Person.call(obj); // 4. 如果该函数没有返回对象，则返回this。 // 例如 var str = new String('123'); //String {\"123\"} 注意： 通过new关键字创建某构造函数的新实例对象，就是将原型链与实例的this联系起来，this指向这个新对象，同时也指向这个构造函数，并且this对象还是这个构造函数的实例。如果没有使用new操作符，直接用构造函数创建新实例对象，那么this对象就指向了window对象，不会指向这个新对象的，不管给这个新对象添加什么属性，都没有用，是直接添加到了window对象上了。 几个属性、方法 has​OwnProperty() : 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性 isPrototypeOf(): 被用来检查判断一个对象是否存在于另一个对象的原型链上。 Object.create(): 创建对象。 参考 new 运算符 | MDN 用关键字new创建对象 new都做了什么（随笔）| csdn Object​.prototype​.has​OwnProperty() | MDN Object​.prototype​.isPrototypeOf() | MDN "},"doc/js/重点思考/Js事件模型.html":{"url":"doc/js/重点思考/Js事件模型.html","title":"Js 事件模型","keywords":"","body":"Js 事件模型 javascript中有两种事件模型：DOM0，DOM2。 DOM0级事件模型是早期的事件模型，所有的浏览器都是支持的，而且其实现也是比较简单。 DOM2级事件模型 事件捕获 和 事件冒泡 注册事件 和 解除事件 在DOM2级中使用addEventListener和removeEventListener来注册和解除事件（IE8及之前版本不支持）。这种函数较之之前的方法好处是一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。 事件捕获 与 事件冒泡的区别 事件流描述的是从页面接收事件的顺序。 IE的事件是冒泡事件流， 而firefox的事件流是捕获事件流。 1.事件冒泡 IE的事件流叫做事件冒泡，即事件从最具体的元素到不具体的元素。 好比气泡从水底下一直向上冒泡，像dom树一样，一直到根元素。 2.事件捕获 即从不具体的元素到具体的元素。 作者：天下1202 来源：CSDN 原文：https://blog.csdn.net/boysky0015/article/details/73205301 版权声明：本文为博主原创文章，转载请附上博文链接！ "},"doc/js/重点思考/promise与setTimeout.html":{"url":"doc/js/重点思考/promise与setTimeout.html","title":"promise 与 setTimeout","keywords":"","body":"﻿ 参考 浅析setTimeout与Promise async await、Promise、setTimeout执行顺序 setTimeout 和 Promise 两个异步的区别 promise和setTimeout执行顺序的疑惑 | segmentfault "},"doc/js/重点思考/深入理解CDN.html":{"url":"doc/js/重点思考/深入理解CDN.html","title":"深入理解 CDN","keywords":"","body":"参考 前端面试题（六）之 什么是CDN，CDN对网站有什么意义，它有什么样的缺点？ https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265 https://baike.baidu.com/item/CDN "},"doc/js/重点思考/frontend_storage.html":{"url":"doc/js/重点思考/frontend_storage.html","title":"Web Storage","keywords":"","body":"摘要： - 为什么前端（浏览器）需要存储？ - 前端存储历史 - cookie -- 优点 -- 缺点 -- 出现背景 -- API - H5 Storage -- sessionStorage -- localStorage -- 出现背景 -- API -- localStorage VS sessionStorage -- 优点 -- 缺点 - IndexedDB -- 出现背景 -- API -- 优点 -- 缺点 - WebSQL -- 出现背景 -- 优点 -- 缺点 - 总结 - 参阅 程序员朋友 👬 一提到存储首先蹦到我们脑子里的就是数据库。但是，对于前端 dev 来说我们不需要太多关心数据库的东西，那是 backend 的活。我们前端只关心浏览器端的存储。 为什么浏览器需要存储？ 要回答这个问题，首先我们应该先明确一下到目前为止你使用过哪些浏览器存储，使用它们都做了什么。 cookie: 保存与后端联系相关的数据信息。 localStorage/sessionStorage: 通常会存储一些业务逻辑里面不那么重要的数据，这个也是目前为止我用的最多的一个； 从上面列举可以看出，对于现代 web 应用来说 web storage 已经变得必不可少了！但是我们还是花点时间从前端发展历史的角度看看这个问题： 前端存储发展历史 总结 参阅 - "},"doc/js/重点思考/Object.is与===的不同.html":{"url":"doc/js/重点思考/Object.is与===的不同.html","title":"Object.is() vs ”===“","keywords":"","body":"https://medium.com/coding-at-dawn/es6-object-is-vs-in-javascript-7ce873064719 摘要 两者不同的地方 === vs == Object.is() 真实事例 总结 参阅 🌘 "},"doc/js/重点思考/es6_symbol.html":{"url":"doc/js/重点思考/es6_symbol.html","title":"ES6 Symbol","keywords":"","body":"背景： 解决 ES5 给对象添加属性可能冲突的风险。使用 Symbol()生成对象属性的 key 就绝对不会有冲突的可能性了。 特性 Symbol 值是一种类字符串数据类型。 Symbol() 可以接收参数，但只作为描述使用，即仅仅为了方便区分不同的 Symbol 值。 Symbol() 返回完全不同的两个值。所以，连续两个相同的 Symbol()即便参数都一样生成的值会不一样。 Symbol 的值可以转成 String/boolean, 但是不能转成 Number 类型。 Symbol.prototype.description 此方法用于读取 Symbol 值的描述，于 ES2019提供！ 使用场景 作为对象属性 通过 [] 或 defineProperty()使用 Symbol 值。 用作常量 注意： Symbol 值作为属性名使用，该属性是公开属性，不是私有属性。 属性名遍历 内置的 Symbol 值 实例：模块的 Singleton 模式 "},"doc/js/part2/2.1 课程简介.html":{"url":"doc/js/part2/2.1 课程简介.html","title":"2.1 课程介绍","keywords":"","body":""},"doc/js/part2/2.3 原型.html":{"url":"doc/js/part2/2.3 原型.html","title":"2.3 原型","keywords":"","body":""},"doc/js/part2/2.4 异步.html":{"url":"doc/js/part2/2.4 异步.html","title":"2.4 异步","keywords":"","body":""},"doc/js/part2/2.8 hybrid.html":{"url":"doc/js/part2/2.8 hybrid.html","title":"2.8 hybrid","keywords":"","body":""},"doc/js/part2/2.9 事件循环.html":{"url":"doc/js/part2/2.9 事件循环.html","title":"2.9 事件循环","keywords":"","body":"深入理解 JavaScript 事件循环 什么是事件循环 Event Loop 指的是计算机系统的一种运行机制。 JavaScript 这门语言是单线程模型，为了解决单线程中一些问题，所以 Js 采用了下面这种事件循环机制。 js 是单线程的，只有一个进程，一次只能执行一个任务。如果是多个任务的话，那么只好排队，只好等前面的任务执行完了，再执行后面的任务。 推荐阅读 JavaScript 运行机制详解：再谈Event Loop 什么是事件循环？ "},"doc/js/part2/2.10 总结.html":{"url":"doc/js/part2/2.10 总结.html","title":"2.10 总结","keywords":"","body":""},"doc/js/part4/JS正则表达式.html":{"url":"doc/js/part4/JS正则表达式.html","title":"正则表达式语法总结","keywords":"","body":"什么是正则表达式 Regular Expression 使用单个字符串来描述 匹配一系列符合某个句法规则的字符串。 说简单了，就是按照某种规则去匹配复合条件的字符串。 开始 正则表达式图形化工具 https://regexper.com/#%2F%5Ba-z%5D%2F 总结 \\b 单词边界 \\d 数字 . 任意字符 \\ 转义字符 [] 或者，例如：[/-]表示/或者-。 ^ 开始 $ 结束 修饰符： g: global 全文搜索，不添加，搜索到第一个匹配停止。 i: ignore case 忽略大小写，默认大小写敏感。 m: mutiple lines 多行搜索。 元字符： \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 \\cX 与X对应的控制字符（Ctry + X） 边界： ^ 以.....开始 $ 以.....结束 \\b 单词边界 \\B 非单词边界 m 处理多行 预定义类: . [^\\r\\n] 除了回车符或者换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符（字母、数字下划线） \\W [^a-zA-Z_0-9] 非单词字符 量词： ？ 出现零次或者一次 + 出现一次或者多次 * 出现零次或者多次（人一次） {n} 出现n次 {n,m} 出现n到m次(注意，,与数字之间不要有空格) {n，} 至少出现n次 JS RegExp对象 JavaScript通过内置对象RegExp支持正则表达式 两种方式实例化RegExp对象：字面量、构造函数。 Js replace(正则表达式，替换后的字符传)，常被用来替换字符。 字面量法 var str = \"He is a boy, This is a dog. Where is she?\"; var reg = '/\\bis\\b/'; //只匹配第一个 str.replace(reg, 'IS'); //He IS a boy, This is a dog. Where is she? var reg2 = '/\\bis\\b/g'; //全部匹配 str.replace(reg2, 'IS'); //He IS a boy, This IS a dog. Where IS she? 构造函数写法 var str = \"He is a boy, This is a dog. Where is she?\"; var reg = new RegExp('/\\bis\\b/'); //只匹配第一个 str.replace(reg, 'IS'); //He IS a boy, This is a dog. Where is she? var reg2 = new RegExp('/\\bis\\b/', 'g'); //全部匹配 str.replace(reg2, 'IS'); //He IS a boy, This IS a dog. Where IS she? 修饰符 g: global 全文搜索，不添加，搜索到第一个匹配停止。 i: ignore case 忽略大小写，默认大小写敏感。 m: mutiple lines 多行搜索。 \"He is a boy, This Is a dog. Where is she?\".replace(/\\bis\\b/g, 0); // \"He 0 a boy, This Is a dog. Where 0 she?\" \"He is a boy, This Is a dog. Where is she?\".replace(/\\bis\\b/gi, 0); // \"He 0 a boy, This 0 a dog. Where 0 she?\" 元字符 正则表达式由两种基本字符类型组成： 原义文本字符： 如“a”, \"abc\"; 元字符： 如：\"\\b\"; 元字符 是正则表达式中有特殊含义的非字母字符 \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 \\cX 与X对应的控制字符（Ctry + X） 字符类 一般情况下，正则表达式一个字符对应字符串的一个字符。 但是，某些时候我们需要的是匹配满足一系列某个特征的字符，那么怎么办呢？对，这个时候就是用到字符类的时候了。 元字符[]构建一个简单的类; 所谓类，是指符合某些特性的对象，一个泛指，而不是特定某个字符; 表达式[abc]把字符a或者b或者c归为一类，表达式可以匹配这类字符。 'a1b2c3d4'.replace(/[abc]/g, 'X'); // \"X1X2X3d4\" 字符类取反 使用字符类^ 创建反向类/负向类 反向类的意义是指不属于某类的内容 表达式[^abc]表示不是字符a或者b或者c的内容。 'a1b2c3d4'.replace(/[^abc]/g, 'X'); // \"aXbXcXXX\" 范围类 我们可以使用[a-z]两个字符，从a到z的任意字符。 这是闭区间，也就是包含a和z。 'a1b2c3d4z5'.replace(/[a-z]/g, 'Q') // \"Q1Q2Q3Q4Q5\" // 同时匹配大小写 'a1b2c3d4z5'.replace(/[a-zA-Z]/g, 'Q') '2016-01-09'.replace(/[0-9]/g, 'A') // \"AAAA-AA-AA\" '2016-01-09'.replace(/[0-9-]/g, 'A') // \"AAAAAAAAAA\" 预定义类 正则表达式提供预定义类 来匹配常见的字符类 预定义类包括以下： 字符 等价类 含义 . [^\\r\\n] 除了回车符或者换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符（字母、数字下划线） \\W [^a-zA-Z_0-9] 非单词字符 边界 最终表达式还提供了几个常用的边界匹配字符 字符 含义 ^ 以.....开始 $ 以.....结束 \\b 单词边界 \\B 非单词边界 m 处理多行 'This is a boy'.replace(/is/g, '0'); // \"Th0 0 a boy\" 'This is a boy'.replace(/\\bis\\b/g, '0'); // \"This 0 a boy\" 'This is a boy'.replace(/\\Bis\\b/g, '0'); // \"Th0 is a boy\" '@123@abc@'.replace(/@./g, 0); // \"0230bc@\" '@123@abc@'.replace(/^@./g, 0); // \"023@abc@\" '@123@abc@'.replace(/.@/g, 0); // \"@120ab0\" '@123@abc@'.replace(/.@$/g, 0); // \"@123@ab0\" \"@123 @456 @789\".replace(/^@\\d/g, 'X'); // \"X123 // @456 // @789\" \"@123 @456 @789\".replace(/^@\\d/gm, 'X'); // \"X123 // X456 // X789\" 量词 量词表示任意字符出现的次数。 字符 含义 ？ 出现零次或者一次 + 出现一次或者多次 * 出现零次或者多次（人一次） {n} 出现n次 {n,m} 出现n到m次(注意，,与数字之间不要有空格) {n，} 至少出现n次 贪婪模式与非贪婪模式 贪婪模式 正则表达式会尽可能多的匹配，直到匹配结束 '12345678'.replace(/\\d{3,6}/g, 'X') // X78 非贪婪模式 让正则表达式尽可能的少匹配，也就是说一旦成功匹配不在继续尝试。这就是非贪婪模式。 在量词后面加个? '12345678'.replace(/\\d{3,6}?/g, 'X') // \"XX78\" 分组 例如：匹配字符Byron连续出现3次的情景。 使用()可以达到分组的功能，使得量词作用于分组。 'a1b2c3d4'.replace(/([a-z]\\d){3}/g, 'X'); // \"Xd4\" 或 'ByronCasper'.replace(/Byron|Casper/g, 'X'); // \"XX\" 'ByronsperByrCasper'.replace(/Byr(on|Ca)sper/g, 'X'); // \"XX 反向引用 $ 引用 引用的是每个分组内的内容 '2018-09-16'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g, '$1/$2/$3'); // \"2018/09/16\" 忽略分组 不希望捕获某个分子，只需要在分组内加上“？” 、或\":\"就可以了。 如： （？：Byron） 前瞻 正则表达式是从文本头部向文本尾部解析的，文本尾部方向，称为”前“ 前瞻，就是在正则表达式匹配到规则时，向前检查是否符合断言。后顾/后瞻方向相反。 JavaScript不支持后顾。 符合特定断言 称为 肯定/正向 断言。 不符合特定断言 称为 否定/负向 断言。 名称 正则 含义 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 正向后顾 exp(? Js 不支持 负向后顾 exp(? Js 不支持 'a2*3'.replace(/\\w(?=\\d)/g, 'X'); // \"X2*3\" 'a2*34v8'.replace(/\\w(?=\\d)/g, 'X'); // \"X2*X4X8\" 'a2*34vv'.replace(/\\w(?=\\d)/g, 'X'); // \"X2*X4vv\" 'a2*34vv'.replace(/\\w(?!\\d)/g, 'X'); // \"aX*3XXX\" JS 对象属性 global 是否全文搜索，默认值是false ignore case 是否大小写敏感，默认值是false multiline 多行搜索，默认值是false lastIndex 当前匹配到内容的最后一个字符的下一个位置 source 正则表达式的文本字符串 test() 和 exec() 正则表达式常用方法 test() 匹配字符串，如果匹配成功就返回真，匹配失败就返回假。 语法： 正则.test(字符串)。 var str='abcdef'; var re=/b/; //bc一个整体也在字符串中，弹出true，但是写bd，弹出false，因为字符串中没有bd这么一个整体 console.log( re.test(str) ); //true search() 匹配字符串，如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回-1 语法：字符串.search(正则) match() 匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null 语法： 字符串.match(正则) var str = \"dgfhfgh254bhku289fgdhdy675\"; var reg = /\\d/; var reg1 = /\\d/g; console.log( str.match(reg) ); // [\"2\"] console.log( str.match(reg1) ); // [\"2\", \"5\", \"4\", \"2\", \"8\", \"9\", \"6\", \"7\", \"5\"] replace() 正则去匹配字符串，匹配成功的字符去替换新的字符串 语法： 字符串.replace(正则，新的字符串) 第二个参数，可以使字符串 or 回调函数（回调函数的第一个参数，就是匹配成功的字符） var str = \"aaa\"; var re = /a/; str = str.replace(re,\"b\"); alert(str); // 输出baa "},"doc/js/面试题/regExp.html":{"url":"doc/js/面试题/regExp.html","title":"正则面试题","keywords":"","body":"给一个连字符串例如：get-element-by-id转化成驼峰形式。 var str = \"get-element-by-id\"; var reg = /-\\w/g; // 匹配横杆以及之后的一个字符，全局匹配 console.log(str.replace(reg,function($0){ return $0.slice(1).toUpperCase(); // 匹配到到是-e -b -i 形式截取后一个字符转成大写 })); // 改进，使用了分组 str.replace(reg2, function($0, $1) { console.log($0); console.log($1); return $1.toUpperCase(); }); 设想： 由驼峰转成一下划线或连字符的形式； var s = 'getElementById'; s.replace(/[A-Z]/g, function(e) { return '-' + e.toLowerCase(); }); \"get-element-by-id\" 匹配二进制数字 var str = \"10101111\"; var reg = /^[01]+$/g; // 以字符类“01”开头，且出现了一次或多次，结束，全局匹配 reg.test(str); 非零的十进制数字 (有至少一位数字, 但是不能以0开头) var str = \"81\"; var reg = /^[1-9][0-9]?$/g; // 以1-9之间的数开头，整数出现0次或一次，结束，全局匹配 reg.test(str); 匹配一年中的12个月 var str = \"12\"; var reg = /^(0?[1-9]|1[0-2])$/g; // ()类别，0出现0次或1次第二位是1-9，第二种可能：第一位是1，第二位0-2， console.log(reg.test(str)); 匹配qq号，最长为13位 var str =\"10009093283333\"; var reg = /^[1-9][0-9]{4,12}$/g; //首位可能是1~9任意一位，后面是0~9出现4~12次 console.log(reg.test(str)); 匹配常见的固定电话号码 var str = \"000-12344562\"; // \\(? 匹配左括号一次或0次然后以0开头后面加两个数字，再匹配右括号或空格或减号一次或0次，随后匹配8个数字 var reg = /\\(?0\\d{2}[)-]?\\d{8}/g; str.match(reg); 匹配ip地址 var str = \"255.221.221.12\"; // [01]?\\d\\d?表示匹配小于199的数，可以说两位数或一位数，2[0-4]\\d表示从200到249，配合25[0-5]就表示小于255的数了。 var reg = /(([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d\\d?|2[0-4]\\d|25[0-5])/g; console.log(str.match(reg)); 匹配用尖括号括起来的以a开头的字符串 var str = \"\"; var reg = /]+>/g; console.log(str.match(reg)); 分割数字每三个以一个逗号划分 var str = \"12345678901\"; function numSplit(str){ var re = /(\\d)(?=(\\d{3})+$)/g; //(\\d{3})+$ 的意思是连续匹配 3 个数字，且最后一次匹配以 3 个数字结尾。 //要找到所有的单个字符，这些字符的后面跟随的字符的个数必须是3的倍数，并在符合条件的单个字符后面添加, return str.replace(re,'$1,'); } console.log(numSplit(str)); 请使用正则取出：Tech,Sales,内容1,内容2 要求最好返回值是一个二维数组：如：a[0][0] = ‘Tech’;a[0][1] = ‘Sales’; let str = 'Tech,Sales,内容1,内容2'; let regExp = /Tech|Sales|内容1|内容2/g; let myArray; let array = [ [] ]; while ((myArray = regExp.exec(str)) !== null) { array[0].push(myArray[0]); } console.log(array); 待处理写一个正则表达式,匹配 \"\" let str = '待处理'; let regExp = /^/; console.log(regExp.exec(str)[0]); // 如何获取一个字符串中的数字字符，并按数组形式输出 如：dgfhfgh254bhku289fgdhdy675gfh输出[254,289,675] let str = 'dgfhfgh254bhku289fgdhdy675gfh'; let regExp = /\\d+/g; console.log(str.match(regExp)); 敏感词过滤 比如：“我草你妈哈哈背景天胡景涛哪肉涯剪短发欲望” 过滤：‘草肉欲胡景涛’ let str = '我草你妈哈哈背景天胡景涛哪肉涯剪短发欲望'; let regExp = /草|肉|欲|胡景涛/g; let result = str.replace(regExp, function(match) { let len = match.length; let str; switch (len) { case 1: str = '*'; break; case 2: str = \"**\"; break; case 3: str = \"***\"; break; default: str = '****'; } return str; }); console.log(result); //我*你妈哈哈背景天***哪*涯剪短发*望 让2013-6-7 变成 2013.6.7 let str = '2013-6-7'; let regExp = /-/g; console.log(str.replace(regExp, '.')); //2013-6-7 写出正则表达式， 从一个字符串中提取链接地址。 比如下面字符串中 let str = 'IT面试题博客中包含很多 微软面试题'; let regExp = /]*)+href=\"(.*)\"(?: [^>]*)*>/; console.log(regExp.exec(str)[1]); // http://hi.baidu.com/mianshiti/blog/category/微软面试题 判断字符串是否包含数字 let str1 = 'abc9efh'; let str2 = 'abcefg'; let regExp = /\\d/; console.log(regExp.test(str1)); // true console.log(regExp.test(str2)); // false 判断连续重复字母 let str1 = 'abc3d4e5'; let str2 = 'aab2c3'; let regExp = /([a-zA-Z])\\1/; console.log(regExp.test(str1));//false console.log(regExp.test(str2));//true // 补充扩展 // 判断一个字符串中出现次数最多的字符，并统计次数 var s = 'aaaaabbbbccccc'; var reg = /(\\w)\\1*/g; var arr = s.match(reg); arr.sort((a, b) => { return a.length - b.length; }); console.log(arr[0][0] + ': ' + arr[0].length); 判断是否以元音字母结尾 let str1= 'animal'; let str2 = 'li'; let str3 = 'foO'; let regExp = /[a,o,e,i,u]$/i; //$表示结束； i表示忽略大小写 console.log(regExp.test(str1)); //false console.log(regExp.test(str2)); //true console.log(regExp.test(str3)); //true 给定字符串 str，检查其是否包含 3 个连续的数字 1、如果包含，返回最新出现的 3 个数字的字符串 2、如果不包含，返回 false let str1 = 'abc123efg'; function captureThreeNumbers(str) { let res; if (res = str.match(/\\d{3}/)) { //match 如果匹配成功就返回匹配成功的数组，反之，返回null return res[0]; } else { return false; } } let reg = /\\d{3}/g; // \\d表示任意数字 {3}表示出现三次 console.log(captureThreeNumbers(str1)); //123 将单词is替换为IS let str = 'English poetry is one of their great heritages'; console.log(str.replace(/\\bis\\b/,'IS')); let reg = /\\bis\\b/g; // \\b单词边界 // English poetry IS one of their great heritages 去掉http协议的jpg文件的协议头 let imgs = [ 'http://img.host.com/images/fds.jpg', 'https://img.host.com/images/fjlj.jpg', 'http://img.host.com/images/djalsdf.png', 'https://img.host.com/images/adsjfl.png', 'http://img.host.com/image/jasdlf.jpg' ]; imgs = imgs.map((img) => { return img.replace(/http:(\\/\\/.+\\.jpg)/, function(match, p1){ return p1; }); }); var reg = /^http:(\\/\\/.+\\.jpg)/； // .表示任意字符；+ 一个或多个； console.log(imgs); // output [ '//img.host.com/images/fds.jpg', // 'https://img.host.com/images/fjlj.jpg', // 'http://img.host.com/images/djalsdf.png', // 'https://img.host.com/images/adsjfl.png', // '//img.host.com/image/jasdlf.jpg' ] 找出数组中的表示日期的时间字符串，并修改格式为‘月-日-年’ let times= ['2006/02/03', 'test/07/sd', '2016/05/10', '1998-03-07', '12345/23/45678', '1234/23/56789', '12345/23/45'] times = times.map((time)=>{ return time.replace(/^(\\d{4})[/-](\\d{2})[/-](\\d{2})$/,(match,p1,p2,p3)=>{ return `${p2}-${p3}-${p1}` }) }); // var reg = /^[1-2]?[1-9]{3}(-|\\/)[1-9][0-2](-\\/)[0-3]/g; // 记录一次傻逼思路 var reg = /^(\\d{4})[/-](\\d{2})[/-](\\d{2})$/g; // \\d 数字字符；$结束；（）分组； []或 console.log(times); // [ '02-03-2006', // 'test/07/sd', // '05-10-2016', // '03-07-1998', // '12345/23/45678', // '1234/23/56789', // '12345/23/45' ] "},"doc/js/part3/小程序基础.html":{"url":"doc/js/part3/小程序基础.html","title":"第四部分 微信小程序","keywords":"","body":"小程序生命周期 https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0 onLoad() - 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。 onShow() - 页面显示/切入前台时触发。 onReady() - 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 onHide() - 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。 onUnload() - 页面卸载时触发。如redirectTo或navigateBack到其他页面时。 onLaunch() onLaunch() 函数是写在App.js文件中的，它是小程序初始化时执行的。 onLaunch() 和 onLoad() 的区别在于。一个是小程序初始化时执行，一个是页面初始化执行。且前者先执行。 推荐阅读： 小程序onLaunch,onLoad 执行生命周期 创建一个小程序页面 知识点： 小程序文件类型和目录结构 注册小程序(每新建一个页面，都要在app.json配置中注册一个页面)，View、Image、Text等组件的用法。 Flexbox弹性盒子模型 移动端分辨率，以及小程序自适应单位rpx 文件类型和目录结构 新建一个页面： 一个目录 四个文件 目录结构： 随意 Flexbox 弹性盒子模型 /* 弹性盒模型 */ display: flex; /* 垂直方向布局 */ flex-direction: column; /* 居中 */ align-items: center; /* 垂直居中*/ vertical-align: middle; 移动分辨率，小程序自适应单位rpx 没错，小程序的确是使用web技术来开发应用。但是，记住了它是移动端应用。所以，我们必须改变一些惯有的思维。不能因为技术一样，就忘了他移动端的特性。 注意：小程序中，px是指逻辑分辨率，这一点跟web不太一样。设计师给的都是物理分辨率。 分辨率 pt 也称为逻辑分辨率 pt 的大小和屏幕尺寸有关系。简单的可以理解为长度和视觉单位。 px 是物理分辨率。1px指的是物理像素点，和屏幕尺寸没有关系，因为点是不能说大小的？我们只能描述有几个物理点。 pt和px之间的关系。他们通常是一个包含的关系，我们通常这么讲。一个逻辑像素有几个物理像素px构成。实际中1pt可以由1个或多个px构成。 iphone6 下面2px构成一个pt rpx 作用 使用rpx, 小程序会自动在不同分辨率下自动换算。而px不会。 如何做不同分辨率设备的自适应？ 以ip6的物理像素750X1334微视觉稿进行设计。然后，开发人员在小程序中使用rpx ip6下面，1px = 0.5pt = 1rpx 并不是所有地方都适合用rpx 文本使用时注意 总结 同一个样式，在全局和页面目录下的样式文件中都定义了，那么以页面目录下的样式为准。即相同样式，离的越近优先级越高。 .json 配置文件，也有类似的就近原则。 小程序应用程序入口由三个文件控制：app.js、app.json、app.wxss 限制：应用代码压缩后不能超过1M， 超过1M上传不上去。 限制：小程序纵向页面嵌套层级最多只能有五级。 小程序子文件是通过导航来设置的。你可以将子文件写在父文件目录下面，也可以写在与他平级。 一个页面：一个目录、以及下面四个文件。四个文件名必须一致，但是目录名可以不一样。 单位： 使用rpx。以iphone6为准，rpx和px是1：1的关系。也就是使用rpx，在iphone6上查看效果即可。 理解：我们在配置文件配置一个新页面时，是不需要设置后缀的。比如welcome页面，配置时不需要写成welcome.wxml。这是为什么呢？因为我们说了，新建一个页面，里面四个文件名都是一样的。这样小程序就自动将这四个文件关联在一起了，我们不需要在wxml文件中显示引用样式文件。。ok 知识点 swiper组件使用方法 配置 全局配置： app.json文件 { \"pages\":[ \"pages/posts/post\", \"pages/index/index\", \"pages/logs/logs\", \"pages/welcome/welcome\" ], \"window\":{ \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" } } 单个页面配置：只能配置window, 并且，不能显示吧window写出来。 { \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" } 列表循环 小程序是没有DOM的，它是数据驱动的。数据绑定 数据优先。 包装元素 不是一个组件，它仅仅是一个包装元素，只接受控制属性，不会在页面中做任何渲染。 是一个组件，会在页面上做渲染； 上不要绑定事件。 wx:for、wx:for-item、wx:for-index 和 wx:key 模板 模板编程，可以让重复的页面布局样式重复使用。 小程序中如何模板化编程 比如说 下面这个实例。电影页面的电影列表部分的页面结构和样式可以作为模板提取出来单独放在一个模板文件夹下面。 **第一步 新建模板文件夹post-item， 文件夹下面新建连个文件post-item-template.wxml和post-item-template.wxss: post-item-template.wxml: 模板页面结构文件 {{ date }} {{ title }} {{ brief }} {{ collection }} {{ reading }} post-item-template.wxss：模板样式文件 .post-item { display: flex; flex-direction: column; width: 100%; margin-top: 20rpx; margin-bottom: 20rpx; background-color: #fff; border-top:1px solid #ededed; border-bottom: 1px solid #ededed; padding-top: 20rpx; padding-bottom: 20rpx; } ...... 第二步 在页面结构文件中(post.wxml)引入模板文件(post-item-template.wxml) 第三步 在当前页面的样式文件(post.wxss)中引入模板的样式文件(post-item-template.wxss) /* 导入模板样式文件 */ @import './post-item/post-item-template.wxss'; .wrapper { background-color: #EFEFF0; } swiper { width: 100%; height: 540rpx; } swiper image { width: 100%; height: 540rpx; } 到这里，你定义的模板已经生效了。 总结 小程序实现的只是模板化编程，并不是模块化。 模板的JS代码只能写在引用它的页面的.js文件上。单独在模板目录下添加一个js文件是没用的。 上面不能添加事件 自定义属性 自定义属性以data-开头 自定义属性实例 一个组件上可以定义多个自定义属性 自定义属性可以有多个连接符连接构成 在事件处理函数中，将文字id拼接到url中，如： goPostDetail: function(e) { // dataset就是自定义的属性对象 const postId = e.currentTarget.dataset.postid; wx.navigateTo({ url: '../posts/post-detail/post-detail?id=' + postId }); } 获取自定义属性 在文字详情页中，通过onLoad事件函数里面获取url参数。 onLoad: function(params) { console.log(params); const postId = params.id; this.setData({ id: postId }) }, 总结 如果在onLoad方法中，不是异步去执行一个数据绑定，则不需要执行this.setData方法。只需要对this.data赋值即可实现数据绑定。 setData Page.prototype.setData(Object data, Function callback) setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data的值（同步）。 // 把objData中的值，放到data对象中 this.setData(objData); // 首先，向data中新加一个post_key键，然后把objData中的值，设置为post_key的值 this.setData({ post_key: objData }); 绑定事件 微信小程序绑定点击事件： 开启小程序之旅 bind:tap 有冒泡 catch:tap 阻止了事件冒泡 页面跳转 小程序页面跳转需要绑定事件执行指定api来实现 wx.navigateTo({ url: 'xxx' }) wx.redirectTo({ url: 'xxx' }) wx.redirectTo 和 wx.navigateTo 参数都是一样的 使用navigator组件: 在当前页打开 goPost: function() { // 跳转到子页面，当前页面执行的是onhide，即隐藏起来了。子页面有返回按钮 // wx.navigateTo({ // url: '../posts/post' // }); // 跳转到子页面 当前页面执行的是onUnload事件，即卸载了。子页面没有返回按钮 wx.redirectTo({ url: '../posts/post' }); }, "},"doc/js/part5/数据结构与算法.html":{"url":"doc/js/part5/数据结构与算法.html","title":"第五部分 数据结构与算法","keywords":"","body":""},"doc/js/es6/变量的结构赋值.html":{"url":"doc/js/es6/变量的结构赋值.html","title":"变量的结构赋值","keywords":"","body":"Hi~ all, 这篇文章里让我们一起来总结下es6引出的 变量的结构赋值 相关内容。 分类 数组的结构赋值 对象的结构赋值 字符串的结构赋值 数值和布尔值的结构赋值 函数参数的结构赋值 数组的结构赋值 数组根据位置顺序进行结构赋值： let [a, b, c] = ['1', '2']; //默认值 let [a, b = 'x'] = [1, undefined]; // 只有对应的值===等于undefined时，默认值才会有效 // 否则默认值无效 let [a = 'hi'] = [null]; // 如果默认值是个表达式，只有当匹配位置的值为undefined时表达式才会执行 function fn() { console.log(1); } let [a = fn()] = [1]; //此时，fn()并没有被执行 对象的结构赋值 对象 是根据名称进行结构赋值，变量必须跟属性名一致，才能取到正确的值； // 结构失败变量值为undefined let {foo} = {bar: 'baz'}; foo // undefined // 实际上对象解构赋值是下面形式的简写 // 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }; // 默认值 // 默认值生效的条件是，对象的属性值严格等于undefined。 var {x, y = 5} = {x: 1}; x // 1 y // 5 var {x = 3} = {x: null}; x // null "},"doc/js/es6/es6语法.html":{"url":"doc/js/es6/es6语法.html","title":"es6 基本语法","keywords":"","body":"学习帮助 ES 6教程：http://es6.ruanyifeng.com/ Babel： https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015,react,stage-2&targets=&browsers=&builtIns=false&debug=false&code= Default Parameters（默认参数） ES5： var link = function (height, color, url) { var height = height || 50; var color = color || 'red'; var url = url || 'http://azat.co'; ... } ES6: 直接写在参数里 var link = function(height = 50, color = 'red', url = 'http://azat.co') { ... } Template Literals（模板对象） 在字符串里面输出变量 ES5： var name = 'Your name is ' + first + ' ' + last + '.'; var url = 'http://localhost:3000/api/messages/' + id; ES6：，使用新的语法 $ {NAME}，并把它放在反引号里： var name = 'Your name is ${first} ${last}.'; var url = 'http://loalhost:3000/api/messages/${id}'; 好处： 这里的$ {NAME}直接当做字符串用，无需写加号 模板字符串 就是这种形式${varible}, 在以往的时候我们在连接字符串和变量的时候需要使用这种方式'string' + varible + 'string'（即字符串拼接）， 但是有了模版语言后，我们可以使用string${varible}string这种进行连接。基本用途有如下: 基本的字符串格式化，将表达式嵌入字符串中进行拼接，用${}来界定。 //es5 var name = 'lux'; console.log('hello' + name); //es6 const name = 'lux'; console.log(`hello ${name}`); //hello lux 在ES5时我们通过反斜杠(\\)来做多行字符串或者字符串一行行拼接，ES6反引号(``)直接搞定。 //ES5 var template = \"hello \\ world\"; console.log( template ); // hello world //ES6 const template = `hello world`; console.log( template ); // hello // world 拓展：字符串的其他方法 // 1.includes：判断是否包含然后直接返回布尔值 let str = 'hahay' console.log(str.includes('y')) // true // 2.repeat: 获取字符串重复n次 let s = 'he' console.log(s.repeat(3)) // 'hehehe' spread (扩展运算符） console.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 Multi-line Strings （多行字符串） ES5： var roadPoem = 'Then took the other, as just as fair,nt' + 'And having perhaps the better claimnt' + 'Because it was grassy and wanted wear,nt' + 'Though as for that the passing therent' + 'Had worn them really about the same,nt'; var fourAgreements = 'You have the right to be you.n You can only be you when you do your best.'; ES6: 反引号就可以啦！ var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear Though as for that the passing theren Had worn them really about the same,`; var fourAgreements = `You have the right to be you.n You can only be you when you do your best.`; 好处：直接一个反引号，将所有的字符串放进去即可，中介随意换行，好清爽！ Destructuring Assignment （解构赋值） 下边例子中，house 和 mouse是 key，同时 house 和 mouse 也是一个变量。 ES5： var data = $('body').data(), // data has properties house and mouse house = data.house, mouse = data.mouse; 以及在node.js中用ES5是这样： var jsonMiddleware = require('body-parser').jsonMiddleware ; var body = req.body, // body has username and password username = body.username, password = body.password; ES6： var {house,mouse} = $('body').data(); //we'll get house and mouse variables var {jsonMiddleware} = require('body-parser'); var {username,password} = req.body; 在数组中是这样的： var [col1,col2] = $('.column'), [line1,line2,line3, ,line5] = file.split('n'); 好处：使用{}省去了写对象的属性的步骤，当然这个{}中的变量是与对象的属性名字保持一致的情况下。 Enhanced Object Literals （增强的对象字面量） 使用对象文本可以做许多让人意想不到的事情！通过ES6，我们可以把ES5中的JSON变得更加接近于一个类。 下面是一个典型ES5对象文本，里面有一些方法和属性： var serviceBase = {port: 3000, url: 'azat.co'}, getAccounts = function(){return [1,2,3]}; var accountServiceES5 = { port: serviceBase.port, url: serviceBase.url, getAccounts: getAccounts, toString: function() { return JSON.stringify(this.valueOf()); }, getUrl: function() {return \"http://\" + this.url + ':' + this.port}, valueOf_1_2_3: getAccounts() } 如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法： var accountServiceES5ObjectCreate = Object.create(serviceBase) // Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。 var accountServiceES5ObjectCreate = { getAccounts: getAccounts, toString: function() { return JSON.stringify(this.valueOf()); }, getUrl: function() {return \"http://\" + this.url + ':' + this.port}, valueOf_1_2_3: getAccounts() } ES6的对象文本中：既可以直接分配getAccounts: getAccounts,也可以只需用一个getAccounts var serviceBase = {port: 3000, url: 'azat.co'}, getAccount = function(){return [1,2,3]}; var accountService = { __proto__: serviceBase, //通过proto设置属性 getAccount, // 既可以直接分配getAccounts: getAccounts,也可以只需用一个getAccounts toString() { //这里将json形式改为函数形式 return JSON.stringify(super.valueOf()); //调用super防范 }, getUrl() {return \"http://\" + this.url + ':' + this.port}, [ 'valueOf_' + getAccounts().join('_') ]: getAccounts() //使用动态key值(valueOf_1_2_3)此处将getAccounts()方法得到的数组[1,2,3]转化为字符串1_2_3 }; console.log(accountService); 好处：相当于直接将结果写进去，而不再必须 key：value 将toString: function(){}这种json形式转变为 toString() {}这样的函数(类)的形式 既可以直接分配getAccounts: getAccounts这样的json形式，也可以只需用一个getAccounts表达相同的意思 Arrow Functions in（箭头函数） 参考阅读: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions 基本语法 和普通函数的区别 和普通函数相比，箭头函数主要就是以下两个方面的特点： 不绑定this，arguments 更简化的代码语法 不绑定this 什么叫不绑定this，我个人的理解为 箭头函数的this其实在定义的时候就已经确定好了的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this。 function Person () { this.name = 'little bear', this.age = 18 setInterval(() => { console.log('我叫' + this.name + '我今年' + this.age + '岁') },1000) } let p = new Person() 不绑定argumens 箭头函数不绑定arguments 所以，在箭头函数中，你不能直接使用arguments，这样会报undefined错误。 let arrowfunc = () => console.log(arguments.length) arrowfunc() // arguments is not defined 那么，如果我想要像ES 5中一样在函数中有一个arguments参数怎么办。这个时候，你可以使用剩余参数详情 let arrowfunc = (...theArgs) => { console.log(theArgs.length) console.log(theArgs); console.log(theArgs[1]); } arrowfunc(1,2) // 2 // [1, 2] // 2 什么时候不能用箭头函数 作为对象的方法。此时this指向的是调用它的对象。即此时不绑定特性没起作用。 不要在构造函数中使用。以为此时不绑定特性启用。 定义原型方法时。此时this指向的是调用它的对象。即此时不绑定特性没起作用。 function Person(name) { this.name = name } Person.prototype.sayHello = () => { console.log(this) } var p1 = new Person() p1.sayHello() // window对象 总结 箭头函数由于其代码的简洁性和不绑定调用者this的特点，在非方法函数中使用是最合适的。 而在方法函数中使用，需要特别注意它的this绑定问题，如果需要动态的修改this，最好还是不要使用箭头函数了。 所以永远没有一个解决方案能解决所有事情，只有合适的应用场景。 Promises ES5： setTimeout(function(){ console.log('Yay!'); }, 1000); ES6：我们可以用promise重写 var wait1000 = new Promise((resolve,reject)=> { setTimeout(resolve,1000); }).then(()=> { console.log('Yay!'); }); 如果我们有更多的嵌套逻辑在setTimeout()回调函数中，好处会明显一点： ES5： setTimeout(function(){ console.log('Yay!'); setTimeout(function(){ console.log('Wheeyee!'); }, 1000) }, 1000); ES6: 我们可以用promise重写 var wait1000 = ()=> new Promise((resolve,reject)=>{ setTimeout(resolve,1000);}); wait1000() .then(function(){ console.log('Yay!'); return wait1000() }) .then(function(){ console.log('Wheeyee!'); }); promise 的含义（什么是promise） promise 是一种异步解决方案。我们知道传统的异步解决方案是用 回调函数 + 事件 的模式，而 promise 是比回调函数事件更好 更强大的异步解决方案。 Promise 可以看作是一个对象（也可以看作是容器），它里面保存着某个未来才会结束的异步事件结果。从语法上，通过Promise对象可以回去异步操作的消息（状态）。 Promise 提供了一套统一的Api，各种异步操作都可以用同样的方式处理。 async 函数 含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，它就是 Generator 函数的语法糖。 async 函数的返回值是 Promise 对象，进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。 基本用法 http://es6.ruanyifeng.com/#docs/async Block-Scoped(块作用域和构造let和const） let是一种新的变量声明方式，它允许你把变量作用域控制在块级里面。我们用大括号定义代码块，在ES5中，块级作用域起不了任何作用： function calculateTotalAmount (vip) { var amount = 0; if (vip) { var amount = 1; } { // more crazy blocks! var amount = 100; { var amount = 1000; } } return amount; } console.log(calculateTotalAmount(true)); // 1000 ES6: 用let限制块级作用域 function calculateTotalAmount(vip){ var amouont = 0; // probably should also be let, but you can mix var and let if (vip) { let amount = 1; // first amount is still 0 } { // more crazy blocks! let amount = 100; // first amount is still 0 { let amount = 1000; // first amount is still 0 } } return amount; } console.log(calculateTotalAmount(true)); //0 因为块作用域中有了let。 谈到const，就更加容易了；它就是一个不变量，也是块级作用域，就像let一样。 好处 ： 我们用let限制块级作用域。而var是限制函数作用域。 let是更完美的var，不是全局变量，具有块级函数作用域, 大多数情况不会发生变量提升。 const定义常量值，不能够重新赋值，如果值是一个对象，可以改变对象里边的属性值。 let声明的变量具有块级作用域 let声明的变量不能通过window.变量名进行访问 形如for(let x..)的循环是每次迭代都为x创建新的绑定 var带来的不合理场景: var arr = []; for (var i = 0; i 分析： 这是因为 i 是全局的，而每次循环创建的i新值都会覆盖原来的旧值。当循环结束时，i的值是10。并且，arr[i] 函数执行是在循环结束了之后的。所以输出的数据都是10。 使用 let 替代 var : 对循环使用let语句的情况，那么每次迭代都是为x创建新的绑定代码。 var arr = []; // for循环中的 var 改成了 let for (let i = 0; i 下面，来看看传统的、不用let的解决办法： 使用闭包 // 循环产生的每个showNum函数，所传入的参数都是私有的 function showNum(i) { return function () { console.log(i) } } var a = [] for (var i = 0; i 立即执行函数 var a = [] for (var i = 0; i forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。 Set数据结构 文档地址 es6方法, Set本身是一个构造函数，它类似于数组，但是成员值都是唯一的。 Set() 可以用于数组去重。 const set = new Set([1,2,3,4,4]) console.log([...set] ) // [1,2,3,4] console.log(Array.from(new Set([2,3,3,5,6]))); //[2,3,5,6] 知识图谱： 语法概要 // 向set中加入值并不会发生类型转换。 // 多个NaN被视为相等，所以最后只能存在一个； // 多个空对象，不会被视为相等，故可能存在多个空对象。 Class （类） class语法相对原型、构造函数、继承更接近传统语法，它的写法能够让对象原型的写法更加清晰、面向对象编程的语法更加通俗 这是class的具体用法。 class Animal { constructor() { this.type = 'animal' } says(say) { console.log(this.type + 'says' + say) } } let animal = new Animal() animal.says('hello') // animal says hello class Cat extends Animal { constructor() { super() this.type = 'cat' } } let cat = new Cat() cat.says('hello') // cat says hell 可以看出在使用 extend 的时候结构输出是 cat says hello 而不是 animal says hello。说明contructor内部定义的方法和属性是实例对象自己的，不能通过 extends 进行继承。 在 class cat 中出现了super(), 这是什么呢？因为在ES6中，子类的构造函数必须含有super函数，super表示的是调用父类的构造函数，虽然是父类的构造函数，但是this指向的却是cat。 Es6 class 和 传统的构造函数+原型继承 的区别 我觉得es6 class是针对传统构造函数+原型继承方式的一种改进升级，实际上我们可以将前者看做是后者的语法糖。 两者实际功能、所要做的事是一样的。 但是，es6 class语法显然要比传统的构造函数 + 原型继承语法更加清晰。更接近面向对象编程语法； Modules （模块） export import parent.js: const name = \"tom\"; const age = \"20\"; class Parent{ hw(){ console.log(`hello world`) } static obj(){ console.log('obj')/*表示为静态方法不回呗实例继承，而是直接通过类调用。*/ } } var parent = new Parent() parent.hw()//hell world export{name,age,Parent} child.js: import {name,age,Parent} from './parent' class Child extends Parent{ constructor(obj){/*就是new命令自动跳用方法。一个类必须要有constructor，如果没定义，有默认添加一个空的。*/ super()//调用父类的constructor() this._config = obj; console.log(obj.name+\"年龄\"+obj.age) } hw(){ console.log(\"hw\") } set val(value){ this._config.name = value; console.log(`name=${value}`) } get val(){ console.log(this._config.name); } } Child.obj() // obj 继承父类static方法 var model = new Child({name,age}) //tom年龄20 model.hw() // hw model.val = \"jock\"; //name=jock model.val // jock 推荐阅读 ES6 模块化操作 ES6 Class Module模块化 案例 重点“人物”：Promise！ 概念：Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合合理、强大。所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promies是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。处理过程流程图： 【面试套路1】手写一个promise var promise = new Promise((resolve, reject) => { if (操作成功) { resolve(value) } else { reject(error) } }) promise.then(function (value) { // success }, function (value) { // failure }) 【面试套路2】解决请求依赖问题 怎么解决回调函数里面回调另一个函数，另一个函数的参数需要依赖这个回调函数。需要被解决的代码如下： $http.get(url).success(function (res) { if (success != undefined) { success(res); } }).error(function (res) { if (error != undefined) { error(res); } }); function success(data) { if（ data.id != 0） { var url = \"getdata/data?id=\" + data.id + \"\"; $http.get(url).success(function (res) { showData(res); }).error(function (res) { if (error != undefined) { error(res); } }); } 【面试套路3】以下代码依次输出的内容是？ setTimeout(function () { console.log(1) }, 0); new Promise(function executor(resolve) { console.log(2); for (var i = 0; i 解析： 首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。 然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。 因此，应当先输出 5，然后再输出 4 ， 最后在到下一个 tick，就是 1 。 【面试套路4】jQuery的ajax返回的是promise对象吗？ jquery的ajax返回的是deferred对象，通过promise的resolve()方法将其转换为promise对象。 var jsPromise = Promise.resolve($.ajax('/whatever.json')); 【面试套路5】 promise只有2个状态，成功和失败，怎么让一个函数无论成功还是失败都能被调用？\\ 使用promise.all() Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 Promise.all方法接受一个数组作为参数，数组里的元素都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。） 示例： var p = Promise.all([p1,p2,p3]); p的状态由p1、p2、p3决定，分为两种情况。 当该数组里的所有Promise实例都进入Fulfilled状态：Promise.all 返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。 当该数组里的某个Promise实例都进入Rejected状态：Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。 【面试套路6】 分析代码运行结果 一、分析下列程序代码，得出运行结果，解释其原因 const promise = new Promise((resolve, reject) => { console.log(1) resolve() console.log(2) }) promise.then(() => { console.log(3) }) console.log(4) // 1 // 2 // 4 // 3 分析： Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。 二、分析下列程序代码，得出运行结果，解释其原因 const promise1 = new Promise((resolve, reject) => { setTimeout(() => { resolve('success') }, 1000) }) const promise2 = promise1.then(() => { throw new Error('error!!!') }) console.log('promise1', promise1) console.log('promise2', promise2) setTimeout(() => { console.log('promise1', promise1) console.log('promise2', promise2) }, 2000) // promise1 Promise {} // promise2 Promise {} // 2399 原因： promise 有 3 种状态：pending（进行中）、fulfilled（已完成，又称为Resolved） 或 rejected（已失败）。 状态改变只能是 pending->fulfilled 或者 pending->rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。 三、分析下列程序代码，得出运行结果，解释其原因 const promise = new Promise((resolve, reject) => { resolve('success1') reject('error') resolve('success2') }) promise .then((res) => { console.log('then: ', res) }) .catch((err) => { console.log('catch: ', err) }) // then：success1 解析： 构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用。 呼应代码二结论：promise 状态一旦改变则不能再变。 四、分析下列程序代码，得出运行结果，解释其原因 Promise.resolve(1) .then((res) => { console.log(res) return 2 }) .catch((err) => { return 3 }) .then((res) => { console.log(res) }) // 1 // 2 解析： promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。 五、分析下列程序代码，得出运行结果，解释其原因 const promise = new Promise((resolve, reject) => { setTimeout(() => { console.log('once') resolve('success') }, 1000) }) const start = Date.now(); promise.then((res) => { console.log(res, Date.now() - start) }) promise.then((res) => { console.log(res, Date.now() - start) }) // once // success 1001 // success 1001 分析： promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。 六、分析下列程序代码，得出运行结果，解释其原因 Promise.resolve() .then(() => { return new Error('error!!!') }) .then((res) => { console.log('then: ', res) }) .catch((err) => { console.log('catch: ', err) }) // then: Error: error!!! // at Promise.resolve.then (...) // at ... 分析： .then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的.catch 捕获，需要改成其中一种： return Promise.reject(new Error('error!!!')) 或者 throw new Error('error!!!') 因为返回任意一个非 promise 的值都会被包裹成promise 对象，即 return new Error('error!!!') 等价于 return Promise.resolve(new Error('error!!!'))。 七、分析下列程序代码，得出运行结果，解释其原因 const promise = Promise.resolve() .then(() => { return promise }) promise.catch(console.error) // TypeError: Chaining cycle detected for promise # // at // at process._tickCallback (internal/process/next_tick.js:188:7) // at Function.Module.runMain (module.js:667:11) // at startup (bootstrap_node.js:187:16) // at bootstrap_node.js:607:3 分析： .then 或 .catch 返回的值不能是 promise本身，否则会造成死循环。 八、分析下列程序代码，得出运行结果，解释其原因 Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 分析： .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 九、分析下列程序代码，得出运行结果，解释其原因 Promise.resolve() .then(function success (res) { throw new Error('error') }, function fail1 (e) { console.error('fail1: ', e) }) .catch(function fail2 (e) { console.error('fail2: ', e) }) // fail2: Error: error // at success (...) // at ... 分析： .then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。 .catch 是.then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch可以捕获之前的错误。 十、分析下列程序代码，得出运行结果，解释其原因 process.nextTick(() => { console.log('nextTick') }) Promise.resolve() .then(() => { console.log('then') }) setImmediate(() => { console.log('setImmediate') }) console.log('end') // end // nextTick // then // setImmediate 分析: process.nextTick 和 promise.then 都属于 microtask，而 setImmediate属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。 推荐阅读 十道es6的Promise面试题，附答案 总结 ES6十大常用特性 "},"doc/js/es6/Promise 和 Async function.html":{"url":"doc/js/es6/Promise 和 Async function.html","title":"Promise 和 Async函数","keywords":"","body":"异步问题 Promise 是什么 词语本意： 许诺、允诺、（有）可能 从词语本意上来看，它表示将来状态，用在异步操作里面，帮我们处理未来可能发生的什么事就非常合适！从另一方面也能够看出程序员的浪漫！ MDN 解释 Promise 对象用于异步计算。 一个 Promise 表示现在、将来或永远不可能可用的值。 按用途来解释 主要用于异步计算。 可以将异步操作队列化，按照预期的顺序执行，返回符合预期的结果。 可以在对象之间传递和操作 Promise, 帮组我们处理队列（依赖请求）。 为什么会有Promise? 异步产生的原因？ 什么是异步？ 异步，将耗时很长的工作 A 交付给系统之后，就接着去做 B 的交付工作了。然后，等到系统完成之前交付的工作后，再通过回调或者事件，继续 A 剩下的工作。 从观察者的角度来看，AB完成的顺序，和交付他们的顺序无关。所以叫异步。 什么是同步？ 顺序交付的工作1234，必须按照1234的顺序完成。 前端异步请求： 事件 ajax请求 浏览器端异步操作： 事件 + 响应 ajax + 回调 Node.js: 对异步操作依赖进一步加重. 无阻塞和高并发，是Nodejs的招牌。异步操作是其保障。 回调地狱 回调地狱 可以理解为多层会回调嵌套，尤其是异步函数嵌套时，给程序可读性可维护性带来的灾难。 回调的四个问题： 嵌套层次多了，难以维护。 无法正常使用 return 和 throw。 无法正常检索堆栈信息。 多个回调之间难以建立关系。 Promise入门 Promise简介 // 使用promise的时候，要先初始化一个promise实例 // 实例，接受一个函数参数，函数包含两个参数resolve、reject // 实例一经创建，执行器立即执行 new Promise( /* 执行器 executor */ function (resolve, reject) { // 一段耗时很长的异步操作 resolve(); // 数据处理完成 reject(); // 数据处理出错 } ) .then(function A() { // 状态改变之后执行then // 成功，下一步 }, function B() { // 失败，做相应处理 }); promise 是一个代理对象，它和原先要进行的操作并无关系； 它通过引入一个回调，避免更多的回调； Promise 的状态改变之后，就会立即调用 .then() 里面对应的回调函数； Promise 的状态一经改变，就不会再改变； Promise 有三种状态 pending [待定] 初始化状态； fulfilled [实现] 操作成功； rejected [被否决] 操作失败； 演示：两步执行的范例 console.log('here we go'); new Promise( resolve => { setTimeout( () => { resolve('hello'); }, 2000); }) .then( value => { console.log(value); return new Promise( resolve => { setTimeout( () => { resolve('world'); }, 2000); }); }) .then( value => { console.log( value + ' world'); }); Promise 作为队列 意思就是，我们把实例化的promise赋值给一个变量，当一个异步请求操作完成之后，通过变量调用.then() 执行接下来的异步请求，以此类推。 这样就保证了，程序的执行时按照我们所设想的顺序（promise队列的顺序） 执行的； // 假如一个Promise已经完成了，再.then()会怎样？ console.log('start'); let promise = new Promise(resolve => { setTimeout(() => { console.log('the promise fulfilled'); resolve('hello, world'); }, 1000); }); setTimeout(() => { promise.then( value => { console.log(value); }); }, 3000); // start // the promise fulfilled // hello, world 如果 .then 中不返回 promise 会怎样？ // 假如在.then()的函数里面不返回新的Promise，会怎样？ console.log('here we go'); new Promise(resolve => { setTimeout( () => { resolve('hello'); }, 2000); }) .then( value => { console.log(value); console.log('everyone'); (function () { return new Promise(resolve => { setTimeout(() => { console.log('Mr.Laurence'); resolve('Merry Xmas'); }, 2000); }); }()); return false; }) .then( value => { console.log(value + ' world'); }); // here we go // hello // everyone // false world // Mr.laurence .then() .then() 接受两个函数作为参数，分别是 fulfilled 和 rejected。 .then() 返回一个新的 Promise 实例，所以它可以链式调用； 当前面的 Promise 状态改变之后，后面的.then()会根据前面状态的改变，选择执行哪一个状态响应函数。 状态响应函数可以返回新的 Promise, 或其他值； 如果返回新的 Promise, 那么下一级.then()会在新的 Promise 状态发生改变之后执行。 .catch() + .then() .catch() 如果不抛出错误的话，实际上返回的还是promise对象，并且状态是fulfilled。此时后面的 .then()仍然会执行； .catch()`` 如果抛出了错误，后面的.then()就会被跳过不执行而是执行后面的.catch`; Promise 进阶 Promise.all() 与.map()连用 实现队列 实现爬虫 Async 函数 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 我对 Async function 的理解： 异步函数实际上返回的是一个promise对象，它是通过事件循环异步执行的函数。但是异步函数使用上，看起来更像是标准的同步函数； 另外，异步函数可以看成是对promise的升级，我把它看做是promise语法糖； Async 函数有哪些优先？ 赋予 JavaScript 以顺序手法编写异步脚本的能力； 即保留异步运算无阻塞特性，还继续使用同步写法； 还能正常使用 return/try/catch； 为什么还要学 Promise? 既然 Async function 这么吊，为什么我们还要学习 Promise ？这是因为： Async/await 还是基于Promise实现的。await 等待返回的是一个promise对象。 "},"doc/js/es6/新增数据类型.html":{"url":"doc/js/es6/新增数据类型.html","title":"Es6 新增数据类型","keywords":"","body":"ES6 新增了的数据类型有哪些 Symbole、Set、Map http://www.cnblogs.com/buerBlog/p/8675688.html https://blog.csdn.net/theVicTory/article/details/79494017 https://www.jianshu.com/p/61da27746d9a https://www.jianshu.com/p/5360cd3a8e72 https://segmentfault.com/a/1190000018033214 "},"doc/js/es6/ES6面试题.html":{"url":"doc/js/es6/ES6面试题.html","title":"Es6 面试题","keywords":"","body":"for...of可以遍历对象吗？ es6新增的数据类型有哪些？ "},"doc/js/RESTful API/1 简介.html":{"url":"doc/js/RESTful API/1 简介.html","title":"第6部分 RESTful API","keywords":"","body":"背景 随着互联网的发展，尤其是以移动互联网为代表的Web3.0时代，客户端层出不穷（App、Pc、微信等），但是服务端的业务是基本一致的。 那么有没有一种方式可以做到 一次编写，随时接入 呢？ 目前比较流行的方案就是 RESTful API。 RESTful API 什么是 REST REST 是 Representational State Transfer 的简写，字面上翻译就是表现状态迁移，维基百科给的定义是可重新表达的转状态迁移。 是风格，不是标准。 特 性： 资源： 所有的东西都是资源，所有的操作都是对资源的增删改查（CRUD）实现的。 URI: 找到对应的资源。 基于HTTP： 无状态。 无动词 什么是 RESTful RESTful 是一种软件设计风格，主要用于客户端和服务器端交互的软件。一般来说 RESTful API 基于 HTTP协议，通过某个唯一的标识符(URI)请求对应的服务器资源(resource)。通常我们把 RESTful API 编程叫做接口编程。 Q: 什么是URI？ A: 在http协议中 uri 组成如下： Schema://host[:port]/path[?query-string] Schema： 使用协议的类型，如http/https/ftp等。 host: 主机域名或IP. port: 端口号（可选） path: 路径 query-string: 查询参数（可选） Q: 什么是资源? A: 狭义上讲，所有在服务器端的数据（如音乐/视频/文章/个人信息...）都是服务器端的资源。 广义上讲，任何服务器端的对象（如：应用程序/数据库记录/算法...）都可以看做是资源。 什么是 RESTful API 按照 REST 风格设计的API就是RESTful API。 特性： 资源、基于HTTP、无状态。 作用： 让前端可以通过统一简单的方式，请求后端获取数据。不管是App还是Pc, 只要请求的url和http类型相同，都可以实现相同的操作。 示例： URL: http://somehost/tvseries GET /tvseries 获取电视剧列表 POST /tvseries 创建一个新的电视剧 GET /tvseries/101 获取id为101的电视剧详情 PUT /tvseries/101 修改id为101的电视剧信息 DELETE /tvseries/101 删除id为101的电视剧 GET /tvseries/101/characters 获取id为101的电视剧的人物列表 小结 RESTful API 基于 HTTP 协议，实现了通用的前后端交互，前端通过某个 URI 和 action 告诉后端执行对应的操作，并返回需要的资源，可以很好的实现前后端的分离。 "},"doc/js/面试题/js.html":{"url":"doc/js/面试题/js.html","title":"JS 面试题","keywords":"","body":"使用原生JS写个JS请求过程？ 事件循环 JavaScript 运行机制详解：再谈Event Loop：http://www.ruanyifeng.com/blog/2014/10/event-loop.html https://www.cnblogs.com/dong-xu/p/7000163.html https://segmentfault.com/a/1190000010622146 严格模式 严格模式 变量必须先声明，直接给变量赋值，不会隐式创建全局变量，不能用with, 严格模式中 call apply传入null undefined保持原样不被转换为window 严格模式下, delete运算符后跟随非法标识符(即delete 不存在的标识符)，会抛出语法错误； 非严格模式下，会静默失败并返回false 严格模式中，对象直接量中定义同名属性会抛出语法错误； 非严格模式不会报错 严格模式中，函数形参存在同名的，抛出错误； 非严格模式不会 严格模式不允许八进制整数直接量（如：023） 严格模式中，arguments对象是传入函数内实参列表的静态副本；非严格模式下，arguments对象里的元素和对应的实参是指向同一个值的引用 严格模式中 eval和arguments当做关键字，它们不能被赋值和用作变量声明 严格模式会限制对调用栈的检测能力，访问arguments.callee.caller会抛出异常 谈谈javascript数组排序方法sort()的使用,重点介绍参数使用及内部机制? 语法：arrayObject.sort(sortby) 参数sortby可选，规定排序顺序，必须是函数 注：如果调用该方法是没有使用参数，将按字符编码的顺序进行排序，要实现这一点，首先应把数组的元素都转换成字符串，以便进行比较。 如果想按照其他的标准进行排序，就需要两个比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对排序的数字。比较函数应该具有两个参数a和b，其返回值如下： 若a 若a=b，则返回一个0 若a>b，则返回一个大于0的值 json和jsonp的区别? json返回的是一串json格式数据；而jsonp返回的是脚本代码（包含一个函数调用） jsonp的全名叫做json with padding，就是把json对象用符合js语法的形式包裹起来以使其他的网站可以请求到，也就是将json封装成js文件传过去。 举例说明一下什么是事件委托? 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。 111 222 333 444 window.onload = function () { var oUl = document.getElementById('ul1'); oUl.onclick = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li') { alert(target.innerHTML) } } } 说下什么是闭包 闭包就是能够读取其他函数内部变量的函数。 例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包包含自由（未绑定到特定对象）变量，这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。 闭包的作用 用闭包模拟私有方法 编程语言中，比如 Java，它是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。 但是 JavaScript 没有这种原生支持，怎么办呢！我们可以使用闭包来模拟私有方法。 私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 实例： var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); console.log(Counter.value()); /* logs 0 */ Counter.increment(); Counter.increment(); console.log(Counter.value()); /* logs 2 */ Counter.decrement(); console.log(Counter.value()); /* logs 1 */ 以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。 在循环中创建闭包：一个常见错误 在 ECMAScript 2015 引入 let 关键字 之前，在循环中有一个常见的闭包创建问题。参考下面的示例： 看下下面的例子： Helpful notes will appear here E-mail: Name: Age: function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i 运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个input上，显示的都是关于年龄的信息。 原因是赋值给 onfocus 的是闭包。这些闭包是由他们的函数定义和在 setupHelp 作用域中捕获的环境所组成的。这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量item。当onfocus的回调执行时，item.help的值被决定。由于循环在事件触发之前早已执行完毕，变量对象item（被三个闭包所共享）已经指向了helpText的最后一项。 方法一： 解决的办法是使用匿名闭包： function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i 方法二：使用let 避免使用过多的闭包，可以用let关键词： function showHelp(help) { document.getElementById('help').innerHTML = help; } function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i 这个例子使用let而不是var，因此每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。 性能考量 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。 考虑以下例子： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; }; } 上面的代码并未利用到闭包的好处，我们可以修改成如下： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype = { getName: function() { return this.name; }, getMessage: function() { return this.message; } }; 但我们不建议重新定义原型。可改成如下例子： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype.getName = function() { return this.name; }; MyObject.prototype.getMessage = function() { return this.message; }; 在前面的两个示例中，继承的原型可以为所有对象共享，不必在每一次创建对象时定义方法。 什么是闭包？闭包有何优缺点？ 闭包： 能够读取其他函数内部变量的函数。（应用场景：要获取某函数内部的局部变量） 优点： 保护函数内的变量安全,加强了封装性 能够读取函数内部的变量 让这些变量一直存在于内存中，不会在调用结束后，被垃圾回收机制回收 缺点： 闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。解决办法是，退出函数之前，将不使用的局部变量删除。 原型与原型链 什么是原型 任何对象都有一个原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的prototype指向的对象，也就是说任何对象都是由一个构造函数创建的。 但是不是每一个对象都有prototype，只有方法才有prototype。 什么是原型链 原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。 如何分析原型链? 因为_proto_实质找的是prototype，所以我们只要找这个链条上的构造函数的prototype。其中Object.prototype是没有_proto_属性的，它==null。 什么是回调 为响应事件所执行的函数 如何获取一个元素的属性值 element.getAttribute('属性名称') localstorage和sessionstorage是什么?区别是什么? localstorage和sessionstorage一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型对象 localstorage生命周期是永久的，这意味着除非用户在浏览器提供的UI上清除localstorage信息，否则这些信息将永远存在。 sessionstorage生命周期为当前窗口或标签，一旦窗口或标签被永久关闭了，那么所有通过sessionstorage存储的数据也将被清空。 不同浏览器无法共享localstorage或sessionstorage中的信息。相同浏览器的不同页面可以共享相同的localstorage（页面属于相同的域名和端口），但是不同页面或标签间无法共享sessionstorage。这里需要注意的是，页面及标签仅指顶级窗口，如果一个标签页包含多个iframe标签他们属于同源页面，那么他们之间是可以共享sessionstorage的。 什么是事件捕获和冒泡？如何阻止事件冒泡？（js原生和jQuery两种） IE使用的是事件冒泡，其他浏览器则是事件捕获。 事件捕获 自上而下的去触发事件；事件冒泡是自下而上的去触发事件。 绑定事件方法的第三个参数，就是控制事件触发顺序是否为事件捕获。true,事件捕获；false,事件冒泡。默认false,即事件冒泡。 Jquery的e.stopPropagation会阻止冒泡，意思就是到我为止，我的爹和祖宗的事件就不要触发了。 先上结论：他们是描述事件触发时序问题的术语。事件捕获指的是从document到触发事件的那个节点，即自上而下的去触发事件。相反的，事件冒泡是自下而上的去触发事件。绑定事件方法的第三个参数，就是控制事件触发顺序是否为事件捕获。true,事件捕获；false,事件冒泡。默认false,即事件冒泡。Jquery的e.stopPropagation会阻止冒泡，意思就是到我为止，我的爹和祖宗的事件就不要触发了。 https://www.cnblogs.com/cboydream/archive/2017/01/24/6296896.html // 原生写法 var $item = document.getElementById('item'); $item.onclick = function (e) {//阻止冒泡 if (e) { e.stopPropagation(); e.preventDefault(); } else { window.event.returnValue = false; window.event.cancelBubble = true; } } js创建对象，至少用三种方式实现。 简述一下事件穿透，及解决办法。 用三种方式判断变量类型是否是数组 js 实现一个函数判断变量类型 function varType(v){ if ( typeof v=== \"object\" ){ if (v=== null ) return 'null' ; if (v. constructor ) return (v. constructor .toString()).match(/(?: )[/w/$]+/)[ 0 ]; if ( typeof typeof2=== 'undefined' && window .execScript){ window .execScript( 'Function vbsTypeName(o):vbsTypeName=TypeName(o):End Function' , 'vbscript' ); window .execScript( 'function typeof2(o){return vbsTypeName(o)}' , 'jscript' ); } if ( typeof typeof2!== 'undefined' ){ return typeof2(v); } return \"object\" ; } return typeof v; } //对于普通js常量和js对象，各浏览器是基本一致的 alert (varType()); //undefined alert (varType( 100 )); //number alert (varType({})); //Object alert (varType([])); //Array alert (varType(/ /)); //RegExp alert (varType( new Date ())); //Date alert (varType( Date )); //function alert (varType( Object )); //function alert (varType( RegExp )); //function //对于DOM对象，各浏览器可能会有不同值 alert (varType( window )); //IE:HTMLWindow2 FF:Window alert (varType( document )); //IE:HTMLDocument FF:HTMLDocument alert (varType( document .body)); //IE:HTMLBody FF:HTMLBodyElement alert (varType( Option )); //IE:Object FF:function alert (varType( Image )); //IE:Object FF:function alert (varType( navigator )); //IE:DispHTMLNavigator FF:Navigator //以下几个只适用于IE，其他内核浏览器不支持 alert (varType( ActiveXObject )); //IE:function alert (varType( Enumerator )); //IE:function alert (varType( new ActiveXObject ( \"Scripting.Dictionary\" ))); //IE:Dictionary alert (varType( new Enumerator ())); //IE:Enumerator 怎样实现对象的拷贝？（ES5） var cloneObj = function (obj) { var newObj = {}; if (obj instanceof Array) { newObj = []; } for (var key in obj) { var val = obj[key]; //newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; //arguments.callee 在哪一个函数中运行，它就代表哪个函数, 一般用在匿名函数中。 newObj[key] = typeof val === 'object' ? cloneObj(val): val; } return newObj; }; 简述一下ajax请求过程 为什么会有跨域？怎么实现的？简述一下实现原理。 nginx反向代理 webpack js的原始数据类型有哪些？ string boolean number null undefined 写一个函数，判断一个变量是否是字符串(一种数据类型)。 typeof str != \"string\" && str.constructor != String 以下代码有否正确？如不正确，请改正 f = function(){return true;} g = function(){return false;} (function(){ if(g()&&[]==![]){ f = function f(){return false;} function g(){return true;} } })(); console.log(f());//true or false? typeof有哪几种结果？ 6种结果： string || number|| undefined || boolean || function|| objec 请用三种方法实现数组去重 使用空对象，将数组元素作为对象key值，出现次数作为value值，循环数组 使用ES6的Set类型，[...new Set([1,2,3,2,3,1,4,5])];//[1,2,3,4,5]; 普通的for循环，循环之前排序，会高效一点点 检测一个对象是否有prop属性，没有就抛出异常，有的话返回true，并删掉该属性 var o = { age:10, prop:\"prop\" } function hasProperty(pro,obj){ if(obj.hasOwnProperty(pro)){ delete obj.prop; }else{ throw new Error(\"没有该属性\"); } } hasProperty(\"prop\",o) console.log(o) href和src有什么区别？ href是文档之间的跳转 src是资源的引用，将指定资源插入到src所在的位置 怎么解决网络请求相互依赖的问题 1、把ajax请求改成同步方式async:false 2、内嵌回调方法比如在ajax请求A里面的success方法里再调ajax请求B 3、用jquery1.8版本之后推出的promise解决，通过then方法将多个独立的ajax请求链式操作。 4、vue中的话，可以使用axios。 this.$axios.post(\"b接口\") .then((response) => { console.log(response) }).then(() => { this.$axios.post(\"a接口\") .then((response) => { console.log(response) }) .catch((err) => { console.log(err) }); }) ES6 相关 箭头函数和普通函数有什么区别？ 箭头函数没有绑定this指针，普通函数的this指向调用函数的对象（匿名函数的this都指向全局window对象）; 箭头函数没有构造器。 箭头函数没有绑定arguments。 箭头函数需要注意的地方 当要求动态上下文的时候，就不能够使用箭头函数，也就是this的固定化 在使用=>定义函数的时候，this的指向是定义时所在的对象，而不是使用时所在的对象； 不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误； 不能够使用arguments对象； 不能使用yield命令； 看下下面这个例子： // 在这个例子中, 我们没有使用箭头函数 class Animal { constructor() { this.type = \"animal\"; } say(val) { setTimeout(function () { console.log(this); //window console.log(this.type + \" says \" + val); }, 1000) } } var animal = new Animal(); animal.say(\"hi\"); //undefined says hi 《JavaScript高级程序设计》第二版中，写到：“超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined”。也就是说在非严格模式下，setTimeout中所执行函数中的this，永远指向window！！ 把上面的例子改成使用箭头函数： class Animal { constructor() { this.type = \"animal\"; } say(val) { setTimeout(() => { console.log(this); //Animal console.log(this.type + ' says ' + val); }, 1000) } } var animal = new Animal(); animal.say(\"hi\"); //animal says hi 箭头函数特点 不在需要使用 function 关键字来创建函数 省略了 return 关键字 继承当前上下文的 this 关键字 jQuery window.onload和jQuery的ready有什么区别？ window.onLoad() $(document).ready() 加载时机 必须等待网页全部加载完毕（包括图片等），然后再执行JS代码 只需要等待网页中的DOM结构加载完毕，就能执行JS代码 执行次数 只能执行一次，如果第二次，那么第一次的执行会被覆盖 可以执行多次，第N次都不会被上一次覆盖 举例 以下代码无法正确执行：window.onload = function() { alert(“text1”);}; window.onload = function() { alert(“text2”);};结果只输出第二个 以下代码正确执行：$(document).ready(function(){alert(“Hello”)}); $(document).ready(function() { alert(“Hello”)}); 结果两次都输出 简写方案 无 $(function () {}) jQuery 有哪些选择器？ 选择器 描述 $(\"p.intro\") 选取 class 为 intro 的 元素 $(\"p:first\") 选取第一个 元素 $(\"ul li:first\") 选取第一个 元素的第一个 元素 $(\"ul li:first-child\") 选取每个 元素的第一个 元素 $(\"a[target='_blank']\") 选取所有 target 属性值等于 \"_blank\" 的 元素 $(\"a[target!='_blank']\") 选取所有 target 属性值不等于 \"_blank\" 的 元素 $(\":button\") 选取所有 type=\"button\" 的 元素 和 元素 $(\"tr:even\") 选取偶数位置的 元素 $(\"tr:odd\") 选取奇数位置的 元素 $(\"*\") 选取所有元素 $(this) 选取当前的元素 attr()和prop()的区别？ 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。 对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop() 典型应用：用checkbox类型实现radio的功能，有兴趣的话可以实验一把 1 2 3 4 $(\":checkbox\").click(function(){ if($(this).prop(\"checked\")!=undefined) { $(this).prop(\"checked\",true).siblings().prop(\"checked\",false); } }) on和bind有什么区别？js动态添加的DOM元素，用on还是bind绑定？ bind现在基本已经被弃用，不做讨论 on常用于事件委托，如：$(el).on(\"click\",\"subel1,subel2\",function(){}); 之后动态添加的el的同类型子元素自动被绑上此事件！！！ touch和click有何区别？ touch有延迟，等待是否双击事件 JS常见兼容性问题 key up,key down,key press在不同浏览器下有何不同？ 何时使用==？ 何时使用===？ JS基础知识上 >> 何时使用==？何时使用===？ JS中有哪些内置函数 S基础知识上 >> JS按存储方式区分变量类型 S基础知识上 >> 如何理解JSON S基础知识上 >> 推荐阅读 前端常见面试题 "},"doc/js/面试题/js-es5编程题.html":{"url":"doc/js/面试题/js-es5编程题.html","title":"JS es5 编程题","keywords":"","body":"闭包 解释下面这段代码输出： 考点： setTimeout(); 闭包； for (var i=0; i 类型转换 解释下面这段代码的输出： const a = '123'; const b = 123; console.log(a === b); // false console.log(a == b); //true console.log(12>1); //false "},"doc/js/面试题/js-es6.html":{"url":"doc/js/面试题/js-es6.html","title":"JS es6 面试题","keywords":"","body":"let、const 和 var 三者的区别？ var 是es6之前声明变量的方式，特点有： var 的作用域是函数作用域； 存在变量提升；function test(){ console.log(a);//undefined var a=3; //(隐式声明) } test(); 思考： var 关键字重复声明会怎么样。JavaScript中重复的声明和遗漏的声明 let 的特点？ 更完美的var 具有块级作用域（Es6以前，js只存在函数作用域以及全局作用域）； 大多数情况不会发生变量提升（不存在变量声明提前）； 不能重复定义； 存在暂时性死区； 暂时性死区域？ (1) 在一个块级作用域中，变量唯一存在，一旦在块级作用域中用let声明了一个变量，那么这个变量就唯一属于这个块级作用域，不受外部变量的影响； (2) 无论在块中的任何地方声明了一个变量，那么在这个块级作用域中，任何使用这个名字的变量都是指这个变量，无论外部是否有其他同名的全局变量； (3) 本质，变量使用一定要放在声明之后: 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 (4) 暂时性死区的意义：让我们标准化代码。将所有的变量的声明放在作用域的最开始。 const 的特点？ 定义常亮。 不能重新赋值。 如果值是一个对象，可以改变对象里边的属性值。 和let一样，是块级作用域，存在暂时性死区，不存在变量提升； 面试思考题： Es6 块级作用域怎么实现的？说下要你实现的话你的思路？？ 箭头函数 箭头有哪些新特点？ 不需要function关键字来创建函数 省略return关键字 继承当前上下文的 this 关键字 需要注意的地方？ 箭头函数内的this对象，指向的是定义函数时所在的对象。。而不是函数执行时； 不能用箭头函数定义构造函数。否则在 new 的时候回报错； 箭头函数中不能使用 arguments 对象； 不能使用yield命令。 解释下面这段代码输出 考点： 普通函数this指向； es6箭头函数this指向； var a = 10; var foo = { a: 20, b: function() { var a = 30; return this.a; }, c: () => { var a = 40; return this.a; } }; var d = { a: 50 }; console.log(a); console.log(foo.b()); console.log(foo.c()); console.log(foo.b.bind(d)()); console.log(foo.c.bind(d)()); 模板字符串 有哪些新特性？ 基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定 在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。 Promise promise对象的用法,手写一个promise promise是一个构造函数，下面是一个简单实例 var promise = new Promise((resolve,reject) => { if (操作成功) { resolve(value) } else { reject(error) } }) promise.then(function (value) { // success },function (value) { // failure }) promise的原理？jquery的ajax返回的是promise对象吗？ promise 只有2个状态，成功和失败，怎么让一个函数无论成功和失败都能被调用？ Promise.all() 是干什么用的，怎么用？ 题目 解释下面代码依次输出 let promise = new Promise(function(resolve, reject) { console.log('1'); resolve(); }); promise.then(() => { console.log('2'); }, () => { console.log('3'); }); console.log('4'); // 1 // 4 // 2 解释下面这段代码输出 console.log(1); setTimeout(() => { console.log(2); }); const p1 = new Promise(resolve => { console.log(3); resolve(); }); p1.then(() => { console.log(4); }); console.log(5); const p2 = new Promise(resolve => { console.log(6); resolve(); }); p2.then(() => { console.log(7); }); // 1 // 3 // 5 // 6 // 4 // 7 // 2 数据结构 Set Set本身是一个构造函数，它类似于数组，但是成员值都是唯一的. const set = new Set([1,2,3,4,4]) [...set] // [1,2,3,4] Array.from(new Set())是将set进行去重 Map 实现一个twoSum函数： 传入源数组和目标数字，返回数组中两个相加起来等于目标数字的索引。 twoSum([2,7,11,15], 9); //[0, 1] "},"doc/js/面试题/浏览器.html":{"url":"doc/js/面试题/浏览器.html","title":"浏览器篇","keywords":"","body":"有用过浏览器缓存吗？请介绍一下基本的缓存机制。 浏览器缓存有两种：强缓存和协商缓存，强缓存类型不会发送请求到服务器，协商缓存会发送请求到服务器，但不会请求新的响应数据； js禁止缓存：设置请求头 // 在链接后手动添加随机数 cookie，sessionStorage，localStorage的区别是什么？ "},"doc/js/面试题/微信小程序.html":{"url":"doc/js/面试题/微信小程序.html","title":"微信小程序","keywords":"","body":"面试题 简单描述下微信小程序的相关文件类型？ 答：微信小程序项目结构主要有四个文件类型, 如下 .json 后缀的 JSON 配置文件 .wxml 后缀的 WXML 模板文件 .wxss 后缀的 WXSS 样式文件 .js 后缀的 JS 脚本逻辑文件 一、WXML （WeiXin Markup Language） 是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。 二、WXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式， 二、js 逻辑处理，网络请求 三、json 小程序设置，如页面注册，页面标题及tabBar。 app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。 app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。 我们简单说一下这个配置各个项的含义: pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。 window字段 —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。 这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。 如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss 全局配置的样式文件，项目非必须。 你是怎么封装微信小程序的数据请求的？ 1、将所有的接口放在统一的js文件中并导出； 2、在app.js中创建封装请求数据的方法； 3、在子页面中调用封装的方法请求数据。 有哪些参数传值的方法？ 1、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象； 2、设置id 的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值； 3、在navigator中添加参数传值。 你使用过哪些方法，来提高微信小程序的应用速度？ 1、提高页面加载速度； 2、用户行为预测； 3、减少默认data的大小； 4、组件化方案。 小程序与原生App哪个好？ 小程序除了拥有公众号的低开发成本、低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验。 简述微信小程序原理？ 微信小程序采用JavaScript、WXML、WXSS三种技术进行开发，从技术讲和现有的前端开发差不多，但深入挖掘的话却又有所不同。 JavaScript： 首先JavaScript的代码是运行在微信App中的，并不是运行在浏览器中，因此一些H5技术的应用，需要微信App提供对应的API支持，而这限制住了H5技术的应用，且其不能称为严格的H5，可以称其为伪H5。同理，微信提供的独有的某些API，H5也不支持或支持的不是特别好。 WXML： WXML微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。 WXSS： WXSS具有CSS的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。 微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。 小程序分为两个部分webview和appService。其中webview主要用来展现UI，appService有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理。 分析下微信小程序的优劣势？ 优势： 1、无需下载，通过搜索和扫一扫就可以打开。 2、良好的用户体验：打开速度快。 3、开发成本要比App要低。 4、安卓上可以添加到桌面，与原生App差不多。 5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。 劣势： 1、限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。 2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。 3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。 4、依托于微信，无法开发后台管理功能。 微信小程序与H5的区别？ 第一条是运行环境的不同: 传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。 第二条是开发成本的不同: 只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG 第三条是获取系统级权限的不同: 系统级权限都可以和微信小程序无缝衔接 第四条便是应用在生产环境的运行流畅度: 长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立. 怎么解决小程序的异步请求问题？ 答：在回调函数中调用下一个组件的函数： app.js success: function (info) { that.apirtnCallback(info) } index.js onLoad: function () { app.apirtnCallback = res => { console.log(res) } ｝ 小程序的wxss和css有哪些不一样的地方？ 1、wxss的图片引入需使用外链地址； 2、没有Body；样式可直接使用import导入. webview中的页面怎么跳回小程序中？ 答：首先要引入最新版的jweixin-1.3.2.js，然后 wx.miniProgram.navigateTo({ url: '/pages/login/login'+'$params' }) 小程序关联微信公众号如何确定用户的唯一性？ 答：使用wx.getUserInfo方法withCredentials为 true 时 可获取encryptedData，里面有 union_id。后端需要进行对称解密。 如何实现下拉刷新？ 答：用view代替scroll-view， 设置onPullDownRefresh函数实现 使用webview直接加载要注意哪些事项？ 1、必须要在小程序后台使用管理员添加业务域名； 2、h5页面跳转至小程序的脚本必须是1.3.1以上； 3、微信分享只可以都是小程序的主名称了，如果要自定义分享的内容，需小程序版本在1.7.1以上； 4、h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的。 小程序调用后台接口遇到哪些问题？ 1.数据的大小有限制，超过范围会直接导致整个小程序崩溃，除非重启小程序； 2.小程序不可以直接渲染文章内容页这类型的html文本内容，若需显示要借住插件，但插件渲染会导致页面加载变慢，所以最好在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签，然后其它的标签让插件来做，减轻前端的时间。 webview的页面怎么跳转到小程序导航的页面？ 答：小程序导航的页面可以通过switchTab，但默认情况是不会重新加载数据的。若需加载新数据，则在success属性中加入以下代码即可： success: function (e) { var page = getCurrentPages().pop(); if (page == undefined || page == null) return; page.onLoad(); } webview的页面，则通过 wx.miniProgram.switchTab({ url: '/pages/index/index' }) 小程序和Vue写法的区别？ 这个差别就大了吧： 循环遍历的时候：小程序是wx:for=\"list\"，而Vue是v-for=\"infoin list\" 调用data模型的时候：小程序是this.data.uinfo，而Vue是this.uinfo； 给模型赋值也不一样，小程序是this.setData({uinfo:1})，而Vue是直接this.uinfo=1 小程序的双向绑定和vue哪里不一样？ 小程序直接this.data的属性是不可以同步到视图的，必须调用： this.setData({ noBind:true }) 常见问题 rpx（responsivepixel） 微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px =750物理像素，1rpx = 0.5px = 1物理像素。 40013错误 在微信小程序刚出来的时候如果没输入AppID，提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，我们可以通过选择无AppID，即可解决此错误。建议安装官方开发工具。 -4058错误 微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。 我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。 当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。 Page注册错误 这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯. Page route错误 字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用 如下代码： wxml文件： 搜索 js文件事件处理函数： bindtap:function(event){ wx.navigateTo({ url: \"search/search\" }) } 如果,你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码: 搜索 这种也是不允许的，也就是说组件内部不能再嵌套组件。它只能是单层存在的。 Do not have * handler in currentpage. 大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。 bindtap: function(event){ wx.navigateTo({ url:\"search/search\" }) }, tabBar设置不显示 对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种 注册页面即将页面写到app.json的pages字段中，如 \"pages\":[ \"pages/message/message\", \"pages/contact/contact\", \"pages/dynamic/dynamic\", \"pages/dynamic/music/music\", \"pages/index/index\", \"pages/logs/logs\" ] · tabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。 · tabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册 · tabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是\"pages\"中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会显示tabBar了。 · tabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。 生命周期函数 onLoad: 页面加载。一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow: 页面显示。每次打开页面都会调用一次。 onReady: 页面初次渲染完成。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期 onHide: 页面隐藏。当navigateTo或底部tab切换时调用。 onUnload: 页面卸载。当redirectTo或navigateBack的时候调用。 wx.navigateTo无法打开页面 一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo 本地资源无法通过 css 获取 background-image：可以使用网络图片，或者 base64，或者使用标签 页面间数据传递 微信小程序路由（页面跳转）是通过API wx.navigateTo或者wxml中组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在\"?\"后面，多个参数直接用\"&\"符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。 {{item.title}} {{item.message}} {{item.time}} 0}}\">{{item.count}} 而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下 Page({ data:{ // text:\"这是一个页面\" isHiddenToast:true } onLoad:function(options){ // 页面初始化 options为页面跳转所带来的参数 console.log(options.title) console.log(options.message) }, onReady:function(){ // 页面渲染完成 }, onShow:function(){ // 页面显示 }, onHide:function(){ // 页面隐藏 }, onUnload:function(){ // 页面关闭 }, bindtap:function(event){ wx.navigateTo({ url: \"/pages/message/search/search\" }) }, }) 小程序生命周期说一下 生命周期函数 描述 onLoad() 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。 onShow() 页面显示/切入前台时触发。 onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。（注意：对界面内容进行设置的 API 如wx.setNavigationBarTitle，请在onReady之后进行。 onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。 onUnload() 页面卸载时触发。如redirectTo或navigateBack到其他页面时。 你使用过小程序里面的那些组件 view 视图容器 scroll-view 可滚动视图区域 swiper 可滚动视图区域 text 文本 navigator 导航组件 还要一些表单相关的组件 progress 进度条 你用过那些小程序API wx.request() 请求数据时 要发起HTTPs网络请求时使用。 wx.getStorage() 数据缓存，从本地缓存中异步获取指定 key 的内容 wx.getStorageSync() 同步读取本地缓存数据 wx.setStorage() 将数据缓存到本地 wx.setStorageSync() 上面的同步版本 "},"doc/js/面试题/算法面试题.html":{"url":"doc/js/面试题/算法面试题.html","title":"算法面试题","keywords":"","body":"字符串相关 回文 回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生收尾回环的情况，也叫回环。如：mamam,redivider. 实现回文不是我们最常用到的for循环，而是reverse的运用。将字符串转化为数组，将数组顺序颠倒后，再转化为字符串，这个过程就实现的回文。 function back(str) { return str == str.split('').reverse().join(''); } 统计一个字符串出现最多的字母和出现的次数 方法一： var str = 'abcdeddd' var n = {} for(var i = 0; i 方法二： var str = ‘abcdeddd' var n = {} var moreStr = ‘' for(var i = 0;i n[moreStr]) moreStr = more } console.log(moreStr) //“d\" console.log(n[moreStr]) //4 方法三：正则表达式 let str = 'abcdeddd'; let reg = /(\\w)\\1*/g; let arr = str.match(reg); arr.sort((a, b) => { return b.length - a.length; }); console.log(arr[0][0] + ': ' + arr[0].length); 字符串转驼峰 例如：border-bottom-color ----> borderBottomColor var str=\"border-bottom-color\"; function Change(str) { var arr = str.split(\"-\"); for(var i=1; i 正则表达式写法： var str = 'share-javascript'; str.replace(/-(\\w)/g, function (m) { return m.toUpperCase(); }).replace(/-/g, ''); // 变形 let str = 'border-bottom-color'; let reg = /-(\\w)/g; str.replace(reg, function($0, $1) { console.log($0); console.log($1); return $1.toUpperCase() }); 随机生成指定长度的字符串 例如： 比如指定的长度为8 function randomStr(n){ let str = 'abcdefghijkmnopqrstuvwxyz9876543210'; let tmp = '', i = 0, len = str.length; for (i=0; i 无重复字符的最长子串 https://leetcode-cn.com/articles/longest-substring-without-repeating-characters/ // 算法逻辑 // 首先，找出所有可能 // 最后，返回所有可能中长度最大的 var str = \"abcabcbb\"; var longestSubstring = function(s) { // 把字符串转换为数组 let strArr = s.split(''); let len = s.length; let allResult = {}; let tmp = {}; let str; for (var i=0; i maxValue) { maxValue = allResult[key]; maxStr = key; } } return \"最常子字符串是：\" + maxStr + \", 长度为：\" + maxValue; }; longestSubstring(str); //\"最常子字符串是：abc, 长度为：3\" longestSubstring('aaaaaaabcdesfgsjodsfij'); //最常子字符串是：abcdesfg, 长度为：8 极简写法： var str = 'abcabcbb'; function getMaxSubLen(s) { return s.split('').reduce((ret, val, index) => { if (ret.indexOf(val) >= 0) return ret; ret.push(val); return ret; }, []).length; } getMaxSubLen( str ); // 3 最长回文子串 var str = 'ddabbade' var longestPalindrome = function(s) { // 判断是否为回文串 function isPalindrome(s) { let rev = s.split('').reverse().join(''); //字符串反转操作 return rev === s; } let palindromeLongest = '' //最长的回文 let palindromeCur = '' //当前的回文 // 记录当前遍历字符串的开始位置 let i, len = s.length, j; for (i=0; i 数组相关 数组去重 ES5 let arr = [1, 2, 3, 4, 5, 4, 3, 2]; function unique(arr) { let newArr = []; let temp; let i, len = arr.length; for (i=0; i ES6 let arr = [1, 2, 3, 4, 5, 4, 3, 2]; function test(arr) { // from() 方法用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。如果对象是数组返回 true，否则返回 false。 // 简单点，就是将类数组转换成数组； return Array.from(new Set(arr)) } console.log(test(arr)) //[1, 2, 3, 4, 5] set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去重其中的重复项目。但是他返回结果是一个对象。 Array.from 它的作用，就是可以把类数组对象、可迭代对象转化为数组。 数组排序算法 冒泡排序 解析：1.比较相邻的两个元素，如果前一个比后一个大，则交换位置。 　　　2.第一轮的时候最后一个元素应该是最大的一个。 　　　3.按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 var arr = [10,20,5,8,21,100,99] function bubbleSort( arr ) { var tmp; for (var outter=arr.length; outter >= 2; --outter) { for (var inner=0; inner arr[inner + 1]) { tmp = arr[inner]; arr[inner] = arr[inner + 1] arr[inner + 1] = tmp; } } } return arr; } bubbleSort( arr ); // [5, 5, 5, 8, 21, 99, 99] sort() var arr = [10,20,5,8,21,100,99] arr.sort(function(a,b){ return a-b // 由小到大（升序） return b-a // 由大到小（降序） }); 快速排序 快速排序是对冒泡排序的一种改进，第一趟排序时将数据分成两部分，一部分比另一部分的所有数据都要小。然后递归调用，在两边都实行快速排序。 var arr = [10,20,5,8,21,100,99] function qSort(arr) { if (arr.length == 0) { return []; } var left = []; var right = []; var pivot = arr[0]; for (var i = 1; i 随机数组 var a = []; for (var i = 0; i Math.floor() - 对一个数进行下取整。 Math.random() - 返回介于 0（包含） ~ 1（不包含） 之间的一个随机数。 js数组与字符串相互转换 数组转字符串: arr.join(''); 字符串转数组: guments对象和Function是分不开的。因为arguments这个对象不能显式创建，arguments对象只有函数开始时才可用。 var s = \"abc,abcd,aaa\"; ss = s.split(\",\");// 在每个逗号(,)处进行分解 [\"abc\", \"abcd\", \"aaa\"] var s1 = \"helloworld\"; ss1 = s1.split(''); //[\"h\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\"] 找出下列正整数组的最大差值 输入的数组是[10,5,11,7,8,9], 输出 6。 function getMaxPro(arr){ let minPrice = arr[0]; //最小值 let maxProfit = 0; //最大值 let i, len = arr.length; for (i=0; i { return a - b; }); let len = arr.length; return arr[len-1] - arr[0]; } getMaxPro(arr); //6 斐波那契数列（Fibonacci sequence ） function fibarr(n) { let arr = []; let i = 0; while( i 求两个数组集合的中间数 有数组1和数组2，这两个数组都是已经按照从大到小排好序的，然后求两个数组集合的中间数 var arr1 = [19, 27, 10, 8, 2, 0]; var arr2 = [101, 78, 45, 29, 10, 8, 1]; function getCentralNum(arr1, arr2) { var arr = arr1.concat(arr2).sort(function(a, b){ return a-b; }), // 中间数的索引值 i = Math.floor((arr.length-1)/2); // 区分合并后的数组长度是偶数还是奇数，偶数返回两个值，奇数返回一个值 return (arr.length%2 == 0) ? [arr[i], arr[i+1]] : arr[i] } // [0, 1, 2, 8, 8, 10, 10, 19, 27, 29, 45, 78, 101] // 10 两个排序数组的中位数 题目描述： 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。 你可以假设 nums1 和 nums2 不同时为空。 参考 ```js // 示例 1: // nums1 = [1, 3] // nums2 = [2] // 中位数是 2.0 // 示例 2: // nums1 = [1, 2] // nums2 = [3, 4] // 中位数是 (2 + 3)/2 = 2.5 var findMedianSortedArrays = function(nums1, nums2) { for (i=0;i} ## 找出最大差值类 问题描述： 给定一个数组[13, 18, 16, 10, 7, 5, 8, 14, 21, 9, 8, 11, 23, 17], 数组里的数表示当日买卖股价，现在，请问什么时候买入什么时候卖出得到的利润最大，请求出最大值？ ```js 查找算法 二分查找 解析：二分查找，也为折半查找。首先要找到一个中间值，通过与中间值比较，大的放右，小的放在左边。再在两边中寻找中间值，持续以上操作，直到找到所在位置为止。 二分查找的前提为：数组、有序。 逻辑为：优先和数组的中间元素比较，如果等于中间元素，则直接返回。如果不等于则取半继续查找 递归方法 /** * 二分查找，递归实现。 * @param target * @param arr * @param start * @param end * @returns {*} */ function binarySearch(target, arr, start, end) { var start = start || 0; var end = end || arr.length-1; var mid = parseInt( start + (end-start)/2 ); if(target == arr[mid]) { return mid; } else if (target > arr[mid]) { return binarySearch(target, arr, mid+1, end); } else { return binarySearch(target, arr, start, mid-1); } // 没找到返回-1 return -1; } 非递归实现 /** * 有序的二分查找，返回-1或存在的数组下标。不使用递归实现。 * @param target * @param arr * @returns {*} */ function binarySearch(target,arr) { var start = 0; var end = arr.length-1; while (start arr[mid]) { start = mid+1; } else { end = mid-1; } } return -1; } /** * 无序的二分查找。返回true/false * @param target * @param arr * @returns {boolean} */ function binarySearch(target, arr) { while (arr.length>0) { //使用快速排序。以mid为中心划分大小，左边小，右边大。 var left = []; var right = []; //选择第一个元素作为基准元素(基准元素可以为任意一个元素) var pivot = arr[0]; //由于取了第一个元素，所以从第二个元素开始循环 for(var i=1; ipivot ? right.push(item) : left.push(item); } // 得到经过排序的新数组 if(target == pivot) { return true; } else if (target > pivot){ arr = right; } else { arr = left; } } return false; } 其他 不需要借助第三个临时变量，实现两个变量的交换 function swap(a, b) { b = b - a; a = a + b; b = a - b; console.log([a, b]); return [a,b]; } swap(2, 5); 补充 更多算法题Js实现 "},"doc/vue/readme.html":{"url":"doc/vue/readme.html","title":"Vue","keywords":"","body":"目录 Introduction 一、vue 篇 1.1 vue 基础 1.1.1 class 1.1.2 页面跳转 1.1.3 Vue自带的filter列表（v1.0 and v2.0） 1.1.3 条件渲染 1.1.4 vue基础 1.1.5 vue组件 1.1.6 vue生命周期 1.1.7 指令 1.2 vue 进阶 使用样式与字体 1. Vue中使用sass 2. Vue中使用less 3. Vue中使用font-awesome 4. Vue中使用bootstrap 5. Vue中引入样式 Vue各种情况下组件间通信 1. 关于vue组件间通信问题的回答 2. 万金油：vue中央事件总线的使用 3. props：最基础的父子组件间传递数据 4. v-model语法糖：子组件向父组件传递数据 5. .sync修饰符：进行父子组件间相互传递数据 6. 父孙组件间传递数据 7. $on属性：子组件调用父组件方法 9. $refs属性 10. $parent属性 11. $children属性 12. 兄弟组件间相互通信 实现一个自己的MVVM 1 思路（需求）分析 2 实例 $nextTick介绍 动态组件与异步组件 keep-alive 数组与对象的变动检测 混入 1.3 vue 高级 1 vue的数据驱动原理、以及实现 2 vue的数据绑定原理 3 vue数据响应原理 4 vue数据依赖实现原理 二、vue-router 篇 三、Vuex 篇 四、axios 篇 五、实战技巧 六、思考题 6.1 vue相关面试题 6.2 vue-router相关面试题 6.3 vuex相关面试题 6.4 axios面试题 6.5 小程序面试题 七、自我介绍 八、面试提问 "},"doc/vue/Vue篇/":{"url":"doc/vue/Vue篇/","title":"一、vue 篇","keywords":"","body":" 1.1 vue 基础知识 1.1.1 class 1.1.2 页面跳转 1.1.3 Vue自带的filter列表（v1.0 and v2.0） 1.1.3 条件渲染 1.1.4 vue基础 1.2 vue 进阶 1.2.1 Vue中使用sass 1.2.2 Vue中使用less 1.2.3 Vue中使用font-awesome 1.2.4 Vue中使用bootstrap 1.2.5 Vue中引入样式 1.3 vue 高级 1.3.1 vue的数据驱动原理、以及实现 1.3.2 vue的数据绑定原理 1.3.3 vue数据响应原理 1.3.4 vue数据依赖实现原理 "},"doc/vue/Vue篇/1.1.1 class.html":{"url":"doc/vue/Vue篇/1.1.1 class.html","title":"1.1 vue 基础","keywords":"","body":"1.1.1 Vue 基础之class 常见几种动态定义class的方法如下： :class=\"{'is-checked': ai === 1}\" :class=\"{'active': timetyp === 1}\" :class=\"tab2==1?'off':'active'\" :class=\"$index % 2 ? 'oldcom' : 'evencom'\" :class=\"item.showDel?'active':''\" :class=\"{'plus': upanddown.indexOf('+') === 0, 'reduce': upanddown.indexOf('-') === 0}\" 我的收藏 下面具体说下语法： 一、“字符串”拼接写法 看代码： 　 二、对象语法 官网文档 html: 　 　 　 　 　 　 js: 　var vm=new Vue({ 　　el:'#app', 　　　data:{ 　　　　isActive: true, 　　　　hasError: false, 　　　　classObject: { 　　　　　active: true, 　　　　　'text-danger': true 　　　　} 　　　} 　}); 三、数组语法 html: 　 　 　 　 　 　 js: 　var vm=new Vue({ 　　el:'#app', 　　　data:{ 　　　　activeClass: 'active', 　　　　errorClass: 'text-danger', 　　　　isActive:true, 　　　　Active:true 　　　} 　}); "},"doc/vue/Vue篇/1.1.2 页面跳转.html":{"url":"doc/vue/Vue篇/1.1.2 页面跳转.html","title":"1.1.2 页面跳转","keywords":"","body":"1.1.2 Vue router页面跳转 // 不传参 用户列表 //带参数 //多个参数，用逗号隔开 投研资讯 Q. 思考： v-link 如何在新窗口打开。 目前的方法，只能通过window.open(); //html {{ h.fundname }} //js viewFundDetail: function(id) { console.log(id) if (!id) { return; } let url = window.location.origin + '/#!/private/detail/?id=' + id; window.open(url); }, "},"doc/vue/Vue篇/1.1.3 条件渲染.html":{"url":"doc/vue/Vue篇/1.1.3 条件渲染.html","title":"1.1.3 条件渲染","keywords":"","body":"1.1.3 条件渲染（动态绑定内联style的几种方法） 三种方法 一、使用三元表达式 一、使用计算属性 一、使用class 语法 对象语法 数组语法 参考阅读 首先，你需要对Vue的条件渲染有个更深入的了解。 有三种办法可以解决你的问题： 一：使用三元表达式 555 二：使用计算属性 555 computed: { computeStyle() { return { opacity: !this.editableCheckNum ? 0.5 : 1 } } } 三：使用class 555 .this-div-class { opacity: .5 } 语法 对象语法 html: 　 　 color:{{activeColor}} 　 　 text-align:{{textAlign}}, fontSize:{{fontSize}}px 　 　 {{styleObject}} 　 　 {{'{display:[\"-webkit-box\",\"-ms-flexbox\",\"flex\"]}'}} js: 　var vm=new Vue({ 　　el:'#app', 　　　data:{ 　　　　activeColor: 'red', 　　　　fontSize: 30, 　　　　textAlign:'center', 　　　　styleObject:{ 　　　　　color: 'red', 　　　　　fontSize: '13px' 　　　　} 　　　} 　}); 如果style属性中带有中划线-，例如：font-size、background-color等等时，必须用驼峰写法或者是引号引起来，否则在渲染时会出错！ 官方的文档中的详细说明 数组语法 官方的文档中的详细说明 html: 　 　 {{[baseStyles, overridingStyles]}} 　 　 如果isActive==true,背景红色 　 　 {{[{ baseStyles: Active }, overridingStyles]}} js: 　var vm=new Vue({ 　　el:'#app', 　　　data:{ 　　　　activeClass: 'active', 　　　　errorClass: 'text-danger', 　　　　isActive:true, 　　　　Active:true 　　　} 　}); 参考阅读 官方的文档中的详细说明 "},"doc/vue/Vue篇/1.1.4 vue基础.html":{"url":"doc/vue/Vue篇/1.1.4 vue基础.html","title":"1.1.4 vue基础","keywords":"","body":"Vue两大核心思想， 组件化和数据驱动： 组件化就是将一个整体合理拆分为一个一个小块（组件），组件可重复使用。 数据驱动是前端的未来发展方向，释放了对DOM的操作，让DOM随着数据的变化自然而然的变化（尤神原话），不必过多的关注DOM，只需要将数据组织好即可。 数组更新检测 两种方法： 变异方法：引起视图更新（因为他改变了原数组）。 替换方法：不会引起视图更新（创建的是新数组，原数组不变）。 变异方法 push() pop() shift() unshift() splice() sort() reverse() click {{ name }} export default{ // data中的数据改变，会引起视图的改变 data(){ return{ names:[\"iwen\",\"ime\",\"ice\"], nums:[1,2,3,4,5,6,6,7], } }, methods:{ changeArr() { // 变异方法 // this.names.push('hhhh'); //向原数组末尾添加元素 视图更新 // this.names.pop(); //从原数组末尾删除一个元素 视图更新 // this.names.shift(); //从原数组头部删除一个元素 视图更新 // this.names.unshift(\"ceshi\"); //向原数组头部添加一个元素 视图更新 // this.names.splice(1, 0, \"ceshi\"); //向原数组添加一个元素 视图更新 // this.names.splice(1); //向原数组添加一个元素 视图更新 // this.names.sort(); //对原数组排序 视图更新 // this.names.reverse(); //对原数组做翻转操作 视图更新 // 非变异方法 let arr = [1, 2]; this.names.concat( arr ); } }, } 替换数组 filter() contact() slice() 这些不会改变原始数组，但总是返回一个新数组。因此不会引起视图更新。 非变异数组方法，如何使视图更新： 替换原数组 changeArr() { // 变异方法 // this.names.push('hhhh'); //向原数组末尾添加元素 视图更新 // this.names.pop(); //从原数组末尾删除一个元素 视图更新 // this.names.shift(); //从原数组头部删除一个元素 视图更新 // this.names.unshift(\"ceshi\"); //向原数组头部添加一个元素 视图更新 // this.names.splice(1, 0, \"ceshi\"); //向原数组添加一个元素 视图更新 // this.names.splice(1); //向原数组添加一个元素 视图更新 // this.names.sort(); //对原数组排序 视图更新 // this.names.reverse(); //对原数组做翻转操作 视图更新 // 非变异方法 let arr = [1, 2]; let see = this.names.concat( arr ); console.log(see); this.names = this.names.concat( arr ); //替换原数组 } 注意事项 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 第一类的解决办法 // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Vue.set Vue.set(vm.items, indexOfItem, newValue) // or vm.$set(vm.items, indexOfItem, newValue) 第二种解决办法 vm.items.splice(newLength) 对象更新检测 还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： 解决办法： Vue.set(object, key, value) or vm.$set(vm.userProfile, 'age', 27)给对象添加一个新属性。 Object.assign() 给对象一次添加多个属性。 计算属性与观察者 计算属性 对于任何复杂的逻辑，我们都应当使用计算属性，不要在模板中放入太多逻辑。 模板中多次出现的逻辑表达式，应该使用计算属性替代 计算属性默认只有getter，在需要时也可以提供setter 计算属性与方法的区别 计算属性和方法可以达到同样的效果。 那为什么还要使用计算属性而不是方法呢？ 计算属性基于他们的依赖可以进行缓存，计算属性只有在它相关的依赖发生改变时才会重新求值。这就意味着只要message没有发生改变，多次访问reverseMessage计算属性会立即返回之前的计算结果，而不必再次执行函数。（也就是只要计算过一次，只要数据没有变化，当再次访问就直接拿之前缓存的去用） 方法不能缓存，每次访问都需要重新计算。 侦听器 注意：当有一些数据需要随着其他数据变动而变动是，容易滥用watch，通常最好的做法是使用计算属性。 什么时候需要用到侦听属性？ 当需要在数据变化时执行异步或者开销较大的操作时，这个方式最有用。 监听input输入框输入 组件注册 子父级组件通信（交互） 记住，vue组件时单向数据流。 父 -> 子： props 子 -> 父： emit event 父亲给儿子传递数据 通过props传递。 父组件： 子组件： Vue.component('blog-post', { // 在 JavaScript 中是 camelCase 的 props: ['postTitle'], template: '{{ postTitle }}' }) 子级向父级传递数据 是通过自定义事件的形式传递的。 在子组件的执行$emit() Parent.vue: 父组件 {{ info }} import Child from \"./child\" export default{ name:\"parent\", data(){ return{ info:\"\", num:5 } }, computed:{ getNum(){ return this.num - 0; } }, components:{ Child }, methods:{ getMsg(data){ this.info = data; } } } #parent { border: 2px solid red; } Child.vue: 子组件 传递 export default{ name:\"child\", data(){ return{ msg:'我是子组件数据' } }, props:{ num:{ type:Number, default:5 } }, computed:{ addNum(){ return this.num * 5; } }, methods:{ sendMsg(event){ //两个参数：参数1：key 参数2：数据 this.$emit(\"sendmsg\",this.addNum) } } } #child { border: 1px solid #cccccc; } 总结 子组件中定义个事件方法sendMsg(), 触发事件执行该方法中的this.$emit(\"sendmsg\", this.addNum); 之后，父组件中自定义的名为“sendmsg”的事件被触发，执行了方法getMsg(data). data参数就是子组件传递过来的数据啦。 注意：自定义事件是绑定在父组件里面引入的子组件上面的。 自定义指令 全局指令 局部指令 Axios Axios基本使用 中文：https://www.kancloud.cn/yunye/axios/234845github：https://github.com/axios/axios 安装 npm install axios 引入加载 在main.js文件中： import Axios from \"axios\" Vue.prototype.$axios = Axios 3.请求 get请求： this.$axios(\"http://www.wwtliu.com/sxtstu/news/juhenews.php\",{ params:{ type:\"junshi\", count:30 } }) .then(res => { this.newsData = res.data; console.log(res.data); }) .catch(error => { console.log(error); }) post请求： 注意：axios接受的post请求参数的格式是form-data格式, 所以要使用qs库。 this.$axios.post(\"http://www.wwtliu.com/sxtstu/blueberrypai/login.php\", qs.stringify({ user_id:\"iwen@qq.com\", password:\"iwen123\", verification_code:\"crfvw\" })) .then(res => { console.log(res.data) }) .catch(error => { console.log(error); }) axios 拦截器 请求拦截器：在请求发送之前就把它拦截了。参数是个请求config对象 + error对象。 响应拦截器：请求成功了，但是在执行then或catch之前拦截了，执行一些操作。参数是个response + error; 使用方法 // 添加请求拦截器 Axios.interceptors.request.use(function(config) { // console.log( config ); // return false; if (config.method == \"post\") { config.data = qs.stringify(config.data) } return config; }, function(error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 Axios.interceptors.response.use(function(response) { return response; }, function(error) { // 对响应错误做点什么 return Promise.reject(error); }); 为什么需要用axios拦截器？作用？ 比如，我发送一个请求，在请求发送之前，我先判断请求类型是否正确、请求参数是否正确、参数不是form-data类型的话我可以把它转换成form-data类型的（使用qs库的stringify方法）。 响应拦截：如果响应的数据本身就是错误的，那就没有必要在继续执行下去了。那么，我们就可以在拦截器中直接return false; 注意： 请求拦截中不返回config，或者直接返回false。那么，请求不会发出。但是响应拦截中的错误处理部分代码会执行。 只有请求成功，且响应成功之后，才会执行响应拦截的第一个回调。 跨域解决方案 第一步 修改config index.js文件 ```javascript proxyTable: { \"/api\": { target: \"http://localhost:3000\", changeOrigin: true, pathRewrite: { '^/api': '' } } } - 第二步 添加host（main.js文件中） ```javascript Vue.prototype.HOST = '/api' 注意： 此种跨域解决方案，只能适用于开发、测试阶段。 打包之后，不会具备服务器，也就不能跨域了。 打包之后的文件是和服务器放在一起的，也就不存在跨域的问题了。 补充 浏览器同源策略？ 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。 不受同源策略限制的： 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的，，，等。 跨域？ 受前面所讲的浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。 解决跨域的方法 Nginx反向代理 jsonp跨域 PHP端修改header document.domain document.domain 注： 开发测试阶段，可以使用webpack配置反向代理。 常用Vue API vue.use() vue.set() "},"doc/vue/Vue篇/1.1.5 vue组件.html":{"url":"doc/vue/Vue篇/1.1.5 vue组件.html","title":"1.1.5 vue组件","keywords":"","body":" 在 vue 中父组件向子组件传值都是通过属性传递的。 组件之间单向数据流 单向数据流 是指 vue 中组件之间数据传递是单向的，是从父组件 到 子组件传递的。 父组件 通过属性的形式传递数据给子组件，在父组件本身中是可以修改数据的。但是子组件绝对不能反过来去修改父组件传递过来的数据，子组件只可以使用传递给它的数据；子组件要想修改父组件传递过来的数据，需要先clone一个数据副本，然后修改副本； 组件参数校验与非props特性 数组参数校验 将props从数组改为对象，例如： ... // props: [\"content\"], //之前的写法 props: { content: String, //父组件传递的数据必须是字符串 required: true, //必填 default: \"default value\", //默认值 validator: function(value) { return (value.length > 5) } } // 变种 props: { content: [ String, Number ], //父组件传递过来的数据，要么是字符串 要么是数字 required: false, //不必填 default: \"default value\" //默认值 } ... 非props特性 特点： 如果子组件没有定义props接收来自父组件传递过来的值，那么，此时控制台会报错！ 当子组件中没有定义props接收传递过来的数据时，实际渲染出来的dom，会包含父组件传递数据的属性； "},"doc/vue/Vue篇/vue基础知识/1 生命周期.html":{"url":"doc/vue/Vue篇/vue基础知识/1 生命周期.html","title":"1.1.6 vue生命周期","keywords":"","body":"Vue 生命周期 面试题 什么是vue生命周期？ 答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 vue生命周期的作用是什么？ 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 vue生命周期总共有几个阶段？ 答：它可以总共分为8个阶段：创建前/后, 载入前/后, 更新前/后, 销毁前/销毁后。 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 第一次页面加载会触发哪几个钩子？ 答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 DOM 渲染在 哪个周期中就已经完成？ 答：DOM 渲染在 mounted 中就已经完成了。 简单描述每个周期具体适合哪些场景？ 答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom 阅读 https://juejin.im/search?query=vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&type=all https://segmentfault.com/a/1190000010336178?utm_source=tag-newest https://segmentfault.com/a/1190000011381906?utm_source=tag-newest https://segmentfault.com/a/1190000008010666?utm_source=tag-newest "},"doc/vue/Vue篇/vue基础知识/2 指令.html":{"url":"doc/vue/Vue篇/vue基础知识/2 指令.html","title":"1.1.7 指令","keywords":"","body":"指令 https://cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4 v-if 和 v-show的区别 共同点： v-if 和 v-show 都是动态的显示DOM元素。 区别： 本质区别： v-show本质就是标签display设置为none，控制隐藏。 v-if是动态的向DOM树内添加或者删除DOM元素。 编译的区别 v-show其实就是在控制css v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件 编译的条件 v-show都会编译，初始值为false，只是将display设为none，但它也编译了 v-if初始值为false，就不会编译了 性能 v-show只编译一次，后面其实就是控制css， 而v-if不停的销毁和创建，故v-show性能更好一点。 v-if 有更高的切换消耗。v-show 有更高的初始化消耗。 应用场景 v-show 适合频繁切换。 v-if 适合运行时条件很少改版时使用。 如何自定义一个vue指令 Vue.js 自定义指令 | 菜鸟教程 "},"doc/vue/Vue篇/vue各种情况的组件通信/1. 关于vue组件间通信问题的回答.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/1. 关于vue组件间通信问题的回答.html","title":"1. 关于vue组件间通信问题的回答","keywords":"","body":"问题一：vue组件间如何进行通信？ 本章主要讲解的同一个页面 index.vue 下的不同组件间 footer.vue 和 header.vue， header.vue 里面又使用了 headerLeft.vue 组件通信的问题。 例如： 父子组件通信: index.vue与 header.vue 同级组件通信: header.vue 与 footer.vue 父孙组件通信: index.vue 与 headerLeft.vue 回答： 在项目中采用 bus中央事件总线 的方法。参考 下一节：万金油：vue中央事件总线的使用 详解 组件间数据相互传递： 可以通过 props 向子组件中传值。 可以通过 v-model语法糖进行向子组件传值，子组件调用父组件的方法。 可以通过 .sync 修饰符，进行父子组件间数据的相互传递。 可以通过 v-bind=\"$attrs\"，将父组件的值传递到孙组件中。 组件间方法相互调用： 可以通过v-on监听方法，进行子组件调用父组件的方法 可以通过v-on=\"$listeners\"，进行孙组件调用父组件的方法 组件间属性相互查询： 可以通过ref属性，父组件查询子组件的方法 可以通过this.$parennt属性，子组件查询父组件 可以通过this.$children属性，父组件查询子组件 "},"doc/vue/Vue篇/vue各种情况的组件通信/2. 万金油：vue中央事件总线的使用.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/2. 万金油：vue中央事件总线的使用.html","title":"2. 万金油：vue中央事件总线的使用","keywords":"","body":"问题一：vue中父子组件、同级组件间如何通信？ vue中央事件总线这种方法适用于任何情况的父子组件通信，同级别组件通信，相当于组件通信间的万金油。但是碰到多人合作时，代码的维护性较低，代码可读性低（这个缺点可以忽略）。 在vue-cli中使用 集中式事件管理机制： 第一步：在 src 新建 emit/emit.js，.js文件内容： import Vue from 'vue'; var Emit = new Vue({}); export { Emit } 第二步：在 src/main.js 下引入 import { Emit } from './emit/emit.js' Vue.prototype.Emit = Emit; 示例：index.vue 为父组件，两个子组件 header.vue、footer.vue。 在mounted生命周期里通过this.Emit.$on()监听。 在destroyed生命周期里面通过this.Emit.$off()解除绑定。一定要解除绑定事件！！！ 父组件 index.vue： //父组件：index.vue： import header from './header.vue'; import footer from './footer.vue'; export default{ data () { return { index:0 } }, mounted () { this.Emit.$on('fromHeader',this.indexFormHeader); this.Emit.$on('fromFooter',this.indexFromFooter); }, //注意：在组件销毁时，一定要解除绑定事件： destroyed(){ this.Emit.$off('fromHeader'); this.Emit.$off('fromFooter'); }, components : { header }, methods : { indexFormHeader(vlaue){ console.log('from header'); console.log(value) }, indexFromFooter(){ console.log('from footer') } } } 子组件 header.vue: 通过this.Emit.$emit()传递数据 //子组件 header.vue Emit export default{ data () { return { index:0 } }, mounted () { this.Emit.$on('headerTofooter',this.headerFromFoot) }, components : { }, methods : { headerEmit(){ this.Emit.$emit('fromHeader',{value:\"123\"}); //可以传递数据 }, headerFromFoot(){ console.log('from footer'); } } } 子组件 footer.vue: //子组件 footer.vue Emit Emit export default{ data () { return { index:0 } }, mounted () { }, components : { }, methods : { footerEmit(){ this.Emit.$emit('fromFooter'); //不传递数据 }, footerEmitToHeader(){ this.Emit.$emit('headerTofooter'); //不传递数据 } } } 推荐阅读 详解Vue 非父子组件通信方法（非Vuex） "},"doc/vue/Vue篇/vue各种情况的组件通信/3. props：最基础的父子组件间传递数据.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/3. props：最基础的父子组件间传递数据.html","title":"3. props：最基础的父子组件间传递数据","keywords":"","body":"问题一：vue父组件如何向子组件中传递数据？ 参考答案： 可以分为 静态传递 或者 使用 v-bind动态传递。 静态传递 的是字符串。 动态传递 的可以是一个表达式、布尔值、对象等等任何类型的值。 例如： // 1、给 `prop` 传入一个静态的值： // 2、也知道prop可以通过 v-bind 动态赋值 // 动态赋予一个变量的值 // 动态赋予一个复杂表达式的值 在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop。 Child.vue 接受： export default { props : [\"title\"] } //或者 export default { props : { title: { type : string, default: \"\" } } } 详解： 传入一个数字： 传入一个布尔值： 传入一个数组： 传入一个对象： 传入一个对象的所有属性： 如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。 例如，对于一个给定的对象 post： post: { id: 1, title: 'My Journey with Vue' } 下面的模板： 等价于： "},"doc/vue/Vue篇/vue各种情况的组件通信/4. v-model语法糖：子组件向父组件传递数据.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/4. v-model语法糖：子组件向父组件传递数据.html","title":"4. v-model语法糖：子组件向父组件传递数据","keywords":"","body":"问题一：v-model语法糖在组件上的使用 [官方文档]自定义事件： https://cn.vuejs.org/v2/guide/components-custom-events.html 原理： 子组件 $emit 父组件 v-on 需要实现效果： 如果在一个页面中我们需要引入一个弹窗组件，点击按钮 a显示弹窗，然后点击弹窗的关闭按钮，关闭弹窗，用v-model实现。 使用v-model来进行双向数据绑定的时： 它仅仅是下面这种写法的语法糖： 所以，在组件中使用的时候，相当于下面的简写： 所以要组件的 v-model 生效，它必须： 接受一个 value 属性。 在有新的 value 时触发 input 事件。 使用示例： import modelVue from '../../components/model.vue' export default{ data () { return { ifShow: true, } }, components : { modelVue } // 新加 methods() { close: function() { this.ifShow = false; console.log('close'); } } } model.vue组件: showAlert 内容 关闭 export default{ props:{ value:{ type:Boolean, default:false, } }, data(){ return{} }, mounted(){ }, methods:{ closeDialog(){ // this.$emit('input',false);//传值给父组件, 让父组件监听到这个变化 this.$emit('closeDialog', false); } }, } .close{ background:red; color:white; } "},"doc/vue/Vue篇/vue各种情况的组件通信/5 .sync修饰符：进行父子组件间相互传递数据.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/5 .sync修饰符：进行父子组件间相互传递数据.html","title":"5. .sync修饰符：进行父子组件间相互传递数据","keywords":"","body":"问题一：.sync修饰符的作用？ vue 2.3.0+ 新增 简要回答： 允许 prop 进行双向绑定，以this.$emit(update:PropName,newValue)的模式触发事件。 即： 相当于： 示例 以在 index.vue 下引入 childrenOne 子组件为例，使用 .sync 属性，会在 mounted 生命周期里面 alert 弹出 childrenOne，而不是index。 import childrenOne from '../../components/childrenOne.vue' export default{ data () { return { doc:{ title:'index' }, } }, mounted (){ //childrenOne alert(this.doc.title); }, components : { childrenOne } } 在 childrenOne.vue 的生命周期 mounted 里面通过 this.$emit('update:title', this.newTitle); 设置title属值。 {{title}} export default{ props:{ title:\"\" }, data () { return { newTitle:\"childrenOne\" } }, mounted (){ this.$emit('update:title', this.newTitle); }, } "},"doc/vue/Vue篇/vue各种情况的组件通信/6 父孙组件间传递数据.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/6 父孙组件间传递数据.html","title":"6. 父孙组件间传递数据","keywords":"","body":"父孙组件间传递数据 使用 $attr 及 $listeners 可以帮助我们实现跨多级组件的通信，进而解决深层次组件通信的问题。 $attrs 属性 用于父组件向孙组件传递数据。 向下传递数据； 最终，传递到孙组件的数据是——除去被上层组件props后剩余的数据。 $listeners 属性 用于在孙组件中执行父组件中的方法。 向下传递方法； 即把父组件中定义的方法，传到孙组件中，进而孙组件中调用父组件方法，修改父组件中的数据。 最终，传到孙组件的方法是——除去上层已经调用（$emit）过的方法。 实例 A 组件 (Child.vue)： import Child1 from './Child1.vue'; export default { data() { return { child1: 'child1111', child2: 'child2222', }; }, components: { Child1 }, methods: { onTest1() { console.log('test1 running...'); }, onTest2() { console.log('test2 running'); } } }; B组件 (Child1.vue): 点击 import Child2 from './Child2.vue'; export default { props: ['pchild1'], data() { return { msg: '我是B' }; }, inheritAttrs: false, components: { Child2 }, methods: { toParent() { this.$emit('test1', this.msg); } } }; C 组件 (Child2.vue): 点击 export default { props: ['pchild2'], data() { return { msg: '我是C' }; }, inheritAttrs: false, methods: { toParent2() { this.$emit('test2', this.msg); } } }; 参看 https://blog.csdn.net/starleejay/article/details/83658277 https://blog.csdn.net/wanglei1991gao/article/details/80228342 "},"doc/vue/Vue篇/vue各种情况的组件通信/9 $refs属性.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/9 $refs属性.html","title":"9. $refs属性","keywords":"","body":"$refs https://cn.vuejs.org/v2/api/#vm-refs 特性： $refs 只在组件渲染完成之后有效。 非响应式的。 这种方式，仅仅作为我们去直接操作 子组件 的备用选项。 尽可能避免在模板 或 计算属性中使用 $refs。 总结： ref 用在子组件上，指向的是 组件实例 ，可以理解为是为子组件添加的 id。 $refs 用来获取子组件实例，即进而获取子组件的里定义的属性或方法，也就可以修改子组件data 和 调用子组件的方法等。 ref 在普通的 DOM 元素上使用，引用指向的就是 DOM 元素。 通过 $ref 可能获取到该 DOM 的属性集合，轻松访问到 DOM 元素，作用与 JQ选择器 类似。 实例： 我是父组件！ import Child from '../components/child.vue' export default { components: {Child}, mounted: function () { console.log( this.$refs.msg); this.$refs.msg.getMessage('我是子组件一！') } } {{message}} export default { data(){ return{ message:'' } }, methods:{ getMessage(m){ this.message=m; } } } props 和 $refs 的区别 prop 着重于数据的传递，它并不能调用子组件里的属性和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。 $ref 着重于索引，主要用来调用子组件里的属性和方法，其实并不擅长数据传递。另外ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。 "},"doc/vue/Vue篇/vue各种情况的组件通信/12 兄弟组件相互通信.html":{"url":"doc/vue/Vue篇/vue各种情况的组件通信/12 兄弟组件相互通信.html","title":"12. 兄弟组件间相互通信","keywords":"","body":"兄弟组件之间的通信 我们可以实例化一个vue实例，相当于一个第三方。 let vm = new Vue(); //创建一个新实例 组件他哥: methods: { ge() { vm.$emit('blur','sichaoyun'); //触发事件 } } 组件小弟接受大哥命令: created() { vm.$on('blur', (arg) => { this.test= arg; // 接收 }); } "},"doc/vue/Vue篇/实现一个自己的MVVM/":{"url":"doc/vue/Vue篇/实现一个自己的MVVM/","title":"实现一个自己的MVVM","keywords":"","body":" 实现一个自己的MVVM 1 思路（需求）分析 2 实例 "},"doc/vue/Vue篇/实现一个自己的MVVM/1 思路分析.html":{"url":"doc/vue/Vue篇/实现一个自己的MVVM/1 思路分析.html","title":"1 思路（需求）分析","keywords":"","body":"思路分析 首先，我们根据流程图来理一下实现一个MVVM的思路， 下面这是个更详细流程图： 如上图所示，我们可以看到，整体实现分为四步： 1、实现一个Compile，对指令进行解析，初始化视图，并且订阅数据的变更，绑定好更新函数 2、实现一个Observer，对数据进行劫持，通知数据的变化 3、实现一个Watcher，将其作为以上两者的一个中介点，在接收数据变更的同时，让Dep添加当前Watcher，并及时通知视图进行update 4、实现MVVM，整合以上三者，作为一个入口函数。 流程解读 第一步：创建MVVM、Compile类，并且利用createDocumentFragment将下的标签放到JS文档碎片中去。 第二步：对标签进行编译，将带有 v- 指令的标签和 双层大括号 的标签解析出来。 第三步：创建Observer类进行数据劫持、深度递归劫持，当data中设置值或者修改值的时候，利用Object.defineProperty对值进行监控。 第四步：创建Watch类观察者，用新值和老值进行比对，如果发生变化，就调用更新方法，进行视图更新。 第五步：将输入框v-model和视图绑定起来，输入框的值变化，同时页面中通过双层大括号绑定的值也变化，实现双向数据绑定。 第六步：在MVVM类中，设置proxyData代理，将vm.$data的值代理到vm上，即可以直接通过 vm。 参考 看完这篇关于MVVM的文章，面试通过率提升了80% 问起Vue的原理时不要再只说defineProperty了 剖析Vue实现原理 - 如何实现双向绑定mvvm 自己动手实现一个MVVM库 JS设计模式2-发布／订阅模式和观察者模式 js设计模式之发布/订阅模式模式 "},"doc/vue/Vue篇/实现一个自己的MVVM/2 实例.html":{"url":"doc/vue/Vue篇/实现一个自己的MVVM/2 实例.html","title":"2 实例","keywords":"","body":""},"doc/vue/Vue篇/$nextTick介绍.html":{"url":"doc/vue/Vue篇/$nextTick介绍.html","title":"$nextTick介绍","keywords":"","body":"$nextTick 介绍 原理 Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 Vue 是异步执行 DOM 更新的。 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 思考：说说$nextTick是怎么实现的 参考 Vue.nextTick 的原理和用途 全面解析Vue.nextTick实现原理 vue中nextTick和$nextTick的区别 "},"doc/vue/Vue篇/动态组件与异步组件.html":{"url":"doc/vue/Vue篇/动态组件与异步组件.html","title":"动态组件与异步组件","keywords":"","body":"动态组件 什么是动态组件？为什么需要动态组件？ 什么是动态组件？ 动态组件 就是具备缓存功能的组件。 为什么需要动态组件？ 当内容没有改变的时候，我们更希望切换tab不是重新创建组件，而是第一次被创建的时候就别缓存下来。 实例 Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 异步组件 什么是异步组件？为什么需要异步组件？ 参考 Vue动态组件和异步组件 极简Vue的异步组件函数 Vue动态异步组件实现思路及其问题 vue.js 异步组件 "},"doc/vue/Vue篇/keep-alive.html":{"url":"doc/vue/Vue篇/keep-alive.html","title":"keep-alive","keywords":"","body":" 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。 "},"doc/vue/Vue篇/数组和对象的变动检测.html":{"url":"doc/vue/Vue篇/数组和对象的变动检测.html","title":"数组与对象的变动检测","keywords":"","body":"数组检测 由于 JavaScript 的限制，Vue 不能检测以下形式数组的变动： this.data[index] = res.data; this.data.length = 0; 正确的操作方式是： Vue.$set(this.data, 1, {name:\"huangenai\",age:\"22\"}) vm.items.splice(0) Vue提供了如下的数组的变异方法，可以触发视图更新 push() pop() shift() unshift() splice() sort() reverse() 对象检测 还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： export default { data(){ return { userProfile: { name: 'Anika' } user: { name: \"huangenai\", age: 12 } } }, mounted() { this.$set(this.userProfile, 'age', 27) this.user = Object.assign({}, this.user, { age: 22, name: \"huangenai\" }); } } 参考 vue 关于数组和对象的更新 Vue为什么不能检测数组变动 "},"doc/vue/Vue篇/混入.html":{"url":"doc/vue/Vue篇/混入.html","title":"混入","keywords":"","body":"混入 面试题： 你了解 vue 里面的混入？实际中使用过吗？解释一下什么是混入？ 结果、表现：如果从我们实际使用看，也就四结果上看。其实混入就是把项目中多组件重复使用定义的数据也好 逻辑操作也好，都给统一提取到一个或几个混合文件中。最后，哪个组件需要用到这里面的选项对象，我们就在组件下引入混合文件然后使用它。使用混合后，混合文件中的对象就会合并到组件原选项对象里面。 Vue为什么要设计混合这个概念 肯定有用: 解决了组件化开发过程中，多组件内部 重复编码 的问题。通过引入 混入 这个概念来解决优化了这个问题。这样一来，再遇到项目中多组件内重复的选项对象就可以提取到混合文件里，只需要编写和维护一份代码，后续的问题就是在需要用到的组件里引入使用就可以了。这样才是更合理的解决方案。 实例： 在我之前项目里面搜索有深度搜索、和普通搜索两种，然后还要分享功能，它们都不只在一个组件中使用。最后，我们就把分享相关的封装到一个 shareMix.js 混合文件里，然后把搜索相关的封装成一个 searchMix.js 文件里；还有，针对用户相关的写在一个 userMix.js 文件下； 混入规则 下面我们来看看，混入后，混合文件选项 和 组件自己选项对象 是如何合并的，有以下几个规则： 数据对象合并: 数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先; 钩子函数合并: 同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 methods, components 和 directives合并: methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 全局混入: 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。 参考 Vue 混入 | 简书博客 混入 | vue官方文档 "},"doc/vue/Vue篇/Vue 高级/1 vue的数据驱动原理、以及实现.html":{"url":"doc/vue/Vue篇/Vue 高级/1 vue的数据驱动原理、以及实现.html","title":"1 vue的数据驱动原理、以及实现","keywords":"","body":"Vue 数据驱动原理、以及实现 数据驱动：DOM是数据的一种自然(自动的)映射 我们先设想一下，如果没有ViewModel那么视图和model是怎么样交互的呢？ 比如我们通过ajax从后台获取数据，为了让视图改变我们要手动触发DOM的改变，或者通过前端交互改变数据，为了让视图也发生变化，仍然需要手动触发这些DOM的改变，手动改变DOM是一个繁琐的过程，也比较容易出错。 而使用view之后就省去了手动操作DOM变化的步骤了。在vue里，你只需要改变数据，vue.js通过 directive（指令）去对DOM做一层封装，当数据发生变化，会通知指令去修改对应的DOM。数据驱动DOM变化，DOM是数据的一种自然映射。 vue.js还会对数据做一些监听，当我们修改视图的时候，vue.js监听到这些变化，从而改变数据，这样也就形成了数据的双向绑定。 "},"doc/vue/Vue篇/Vue 高级/2 vue的数据绑定原理.html":{"url":"doc/vue/Vue篇/Vue 高级/2 vue的数据绑定原理.html","title":"2 vue的数据绑定原理","keywords":"","body":"vue的数据绑定原理 vue的双向绑定原理及实现 剖析Vue原理&实现双向绑定MVVM "},"doc/vue/Vue篇/Vue 高级/3 vue数据响应原理.html":{"url":"doc/vue/Vue篇/Vue 高级/3 vue数据响应原理.html","title":"3 vue数据响应原理","keywords":"","body":"vue数据响应原理 Vue数据响应依赖于 Object.defineProperty, 这也是Vue不支持IE8的原因。Vue通过设定对象属性的setter/getter 方法来监听数据的变化。通过 getter 进行依赖收集，而每个 setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 数据响应原理： 看看数据改变是如何驱动数据自动更新的 假如我们有一份数据a.b，在一个vue对象实例化的过程中，会给a.b这份数据通过es5的 Object.defineProperty() 属性，添加了一个 Setter 和 Getter，同时 vue.js 会对模板做编译，解析生成一个指令对象，这里是一个 v-text 指令， 每个指令对象都会关联一个 Watcher，当我们对指令对应的表达式 a.b 做求值的时候，就会触发了Getter，这里我们就会把依赖收集到这个 Watcher 里面，当我再次改变了 a.b 的时候，就会触发它的Setter，会通知到被关联的Watcher，然后Watcher就会再次对a.b求值，计算对比新旧值。当发现值改变了，Watcher又会通知到指令，调用指令的Updata方法，由于指令是对DOM的封装，所以会调用原生DOM的方法，去更新视图，这样我们就完成了数据改变到视图更新的一个自动过程。 "},"doc/vue/Vue篇/Vue 高级/4 vue数据依赖实现原理.html":{"url":"doc/vue/Vue篇/Vue 高级/4 vue数据依赖实现原理.html","title":"4 vue数据依赖实现原理","keywords":"","body":""},"doc/vue/Axios篇/axios使用基础.html":{"url":"doc/vue/Axios篇/axios使用基础.html","title":"四、axios 篇","keywords":"","body":"Axios Axios基本使用 中文：https://www.kancloud.cn/yunye/axios/234845github：https://github.com/axios/axios 安装 npm install axios 引入加载 在main.js文件中： import Axios from \"axios\" Vue.prototype.$axios = Axios 3.请求 get请求： this.$axios(\"http://www.wwtliu.com/sxtstu/news/juhenews.php\",{ params:{ type:\"junshi\", count:30 } }) .then(res => { this.newsData = res.data; console.log(res.data); }) .catch(error => { console.log(error); }) post请求： 注意：axios接受的post请求参数的格式是form-data格式, 所以要使用qs库。 this.$axios.post(\"http://www.wwtliu.com/sxtstu/blueberrypai/login.php\", qs.stringify({ user_id:\"iwen@qq.com\", password:\"iwen123\", verification_code:\"crfvw\" })) .then(res => { console.log(res.data) }) .catch(error => { console.log(error); }) axios 拦截器 请求拦截器：在请求发送之前就把它拦截了。参数是个请求config对象 + error对象。 响应拦截器：请求成功了，但是在执行then或catch之前拦截了，执行一些操作。参数是个response + error; 使用方法 // 添加请求拦截器 Axios.interceptors.request.use(function(config) { // console.log( config ); // return false; if (config.method == \"post\") { config.data = qs.stringify(config.data) } return config; }, function(error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 Axios.interceptors.response.use(function(response) { return response; }, function(error) { // 对响应错误做点什么 return Promise.reject(error); }); 为什么需要用axios拦截器？作用？ 比如，我发送一个请求，在请求发送之前，我先判断请求类型是否正确、请求参数是否正确、参数不是form-data类型的话我可以把它转换成form-data类型的（使用qs库的stringify方法）。 响应拦截：如果响应的数据本身就是错误的，那就没有必要在继续执行下去了。那么，我们就可以在拦截器中直接return false; 注意： 请求拦截中不返回config，或者直接返回false。那么，请求不会发出。但是响应拦截中的错误处理部分代码会执行。 只有请求成功，且响应成功之后，才会执行响应拦截的第一个回调。 跨域解决方案 第一步 修改config index.js文件 ```javascript proxyTable: { \"/api\": { target: \"http://localhost:3000\", changeOrigin: true, pathRewrite: { '^/api': '' } } } - 第二步 添加host（main.js文件中） ```javascript Vue.prototype.HOST = '/api' 注意： 此种跨域解决方案，只能适用于开发、测试阶段。 打包之后，不会具备服务器，也就不能跨域了。 打包之后的文件是和服务器放在一起的，也就不存在跨域的问题了。 补充 浏览器同源策略？ 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。 不受同源策略限制的： 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的，，，等。 跨域？ 受前面所讲的浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。 解决跨域的方法 Nginx反向代理 jsonp跨域 PHP端修改header document.domain document.domain 注： 开发测试阶段，可以使用webpack配置反向代理。 "},"doc/vue/思考题/":{"url":"doc/vue/思考题/","title":"六、思考题","keywords":"","body":" 6.1 vue相关面试题 6.2 vue-router相关面试题 6.3 vuex相关面试题 "},"doc/vue/思考题/6.1 vue相关面试题.html":{"url":"doc/vue/思考题/6.1 vue相关面试题.html","title":"6.1 vue相关面试题","keywords":"","body":"vue 哪个生命周期进行数据请求 不考虑服务器端渲染，一般选在 mounted 周期内请求数据，因为这个周期开始时，当前组件已经被挂载到真实的元素上了。 vue-loader是什么？使用它的用途有哪些？ 解析 .vue文件 的一个加载器。跟 template/js/style 转换成js模块。 用途：js 可以写es6、style样式可以scss或less、template可以加jade等。 请列举出3个Vue中常用的生命周期钩子函数 created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见 mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 activated: keep-alive组件激活时调用 vue.js是什么 Vue.js是一个轻巧、高性能、可组件化的MVVM库，它用来构建数据驱动的Web界面。同时拥有非常容易上手的API； Vue.js是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。数据驱动+组件化的前端开发。 简而言之：Vue.js是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 vue响应式原理（双向绑定原理）是什么？ Vue的双向数据绑定原理是什么？ vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。 这题答案同样适合”vue data是怎么实现的？”此面试题。 如何理解Vue核心是数据驱动？ 数据驱动： Vue.js 一个核心思想是数据驱动。所谓数据驱动是指视图是由数据驱动生成的，对视图的修改，不会直接操作 DOM，而是通过修改数据。 相比传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，1）大大简化了代码量，特别是当交互复杂的时候，2）只关心数据的修改会让代码的逻辑变的非常清晰，3）因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用触碰 DOM，这样的代码非常利于维护。 Vue的特点有哪些？和jQuery有何区别？ 为什么要选vue？与其它框架对比的优势和劣势？ 轻量级的框架 双向数据绑定 指令 插件化 优雅简洁 官方文档详细 vue如何实现父子组件通信，以及非父子组件通信？ 父子组件：props、emit 非父子组件：vuex 简述一下Vue的生命周期及其特点 请详细说下你对vue生命周期的理解？ 什么是vue生命周期 分8个阶段 vue生命周期的作用是什么 第一次页面加载会触发哪几个钩子 DOM 渲染在 哪个周期中就已经完成 简单描述每个周期具体适合哪些场景 什么是vue生命周期 Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 分8个阶段 总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后: 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 vue生命周期的作用是什么 它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 第一次页面加载会触发哪几个钩子 第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 DOM 渲染在 哪个周期中就已经完成 DOM 渲染在 mounted 中就已经完成了。 简单描述每个周期具体适合哪些场景 答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom methods、计算属性、watch的区别 计算属性的实现 数组和对象的什么操作不会在vue反映 什么是MVVM？ MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？ mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷 vue的优点是什么？ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 组件之间的传值？ 父组件与子组件传值: 父组件通过标签上面定义传值 子组件通过props方法（属性数组）接受数据 子组件向父组件传递数据 子组件通过$emit方法传递参数 vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？ 第一步：在components目录新建你的组件文件（indexPage.vue），script一定要export default {} 第二步：在需要用的页面（组件）中导入：import indexPage from '@/components/indexPage.vue' 第三步：注入到vue的子组件的components属性上面,components:{indexPage} 第四步：在template视图view中使用，例如有indexPage命名，使用的时候则index-page 组件命名规则： 组件文件本身，驼峰命名法 在引入组件的组件中，短横线命名法 vue如何实现按需加载配合webpack设置 webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。 不进行页面按需加载引入方式： import home from '../../common/home.vue' 进行页面按需加载的引入方式： const home = r => require.ensure( [], () => r (require('../../common/home.vue'))) v-show和v-if指令的共同点和不同点 v-show指令 是通过修改元素的display的CSS属性让其显示或者隐藏；切换开销小； v-if指令 是直接销毁和重建DOM达到让元素显示和隐藏的效果；切换开销大； v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 如何让CSS只在当前组件中起作用 将当前组件的修改为 的作用是什么? 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。 Vue中引入组件的步骤? 采用ES6的import ... from ...语法或CommonJS的require()方法引入组件。 对组件进行注册,代码如下:// 注册 Vue.component('my-component', { template: 'A custom component!' }) 使用组件 指令v-el的作用是什么? 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例. 在Vue中使用插件的步骤 组件中：采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件 全局：使用全局方法Vue.use( plugin )使用插件, 可以传入一个选项对象Vue.use(MyPlugin, { someOption: true }) 出至少4种vue当中的指令和它的用法？ v-if：判断是否隐藏；v-for：数据循环；v-bind:class：绑定一个属性；v-model：实现双向绑定 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？ 答：css的预编译。 使用步骤： 第一步：先装css-loader、node-loader、sass-loader等加载器模块 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss 第三步：在同一个文件，配置一个module属性 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss” 特性: 可以用变量，例如（$变量名称=值）； 可以用混合器，例如（） 可以嵌套 为什么使用key？ 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。 为什么避免 v-if 和 v-for 用在一起 当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。 VNode是什么？虚拟 DOM是什么？ Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。 “虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。 v-model是什么？怎么使用？ vue中标签怎么绑定事件？ 答： 可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。 vue的model层的data属性。 绑定事件： 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？ 自定义指令的方法: 全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。 组件内定义指令：directives 钩子函数： bind（绑定事件触发） inserted(节点插入的时候触发) update（组件内相关更新） 钩子函数参数： el binding 请说下封装 vue 组件的过程？ 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。 子组件需要数据，可以在props中接受定义。 而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。 请说出vue.cli项目中src目录每个文件夹和文件的用法？ assets文件夹是放静态资源； components是放组件； router是定义路由相关的配置; view视图； app.vue是一个应用主组件； main.js是入口文件 聊聊你对Vue.js的template编译的理解？ 答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点） 详情步骤： 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等） 简述一下$nextTick的用法 我们经常会遇到一种场景，比如数据更新了，我们紧接着对重新渲染后的视图做dom操作。但是，发现这个时候本以为能拿到dom元素但是事实上却不是。 这个时候就需要$nextTick()了。他的作用是等待视图更新完成之后在执行其中的回调函数。 性能优化 不要在模板里面写过多的表达式与判断 v-if=\"isShow && isAdmin && (a || b)，这种表达虽然功能上完全没问题，但是这样写并不好，首先 看着不舒服时。把过多逻辑表达式写在模板中日后代码修改可能也会是个麻烦。 适当的写到 methods 和 computed 里面封装成一个方法，这样的好处是 代码可以复用，减少重复的代码。同时，使用计算属性，由于他有缓存的功能。这个在vue底层实现上就已经是性能的提升了。 v-if 和 v-show的使用？ 我总结的一个使用原则是这样的： 当涉及到权限相关展示的话，那么就使用v-if 在没有权限问题下，根据点击频率来选择。频繁切换的话就使用v-show， 否则使用v-if。 其实吧，你说他们使用存在性能问题。。肯定是有点，但是基本上大多数时候这种性能差别我们用肉眼都是分辨不出来的，通常也不会影响到用户体验。我说更合理的使用的话，优化的点在于减少页面中dom数量，比如说，我倾向于使用v-if的话，因为减少了生成dom的数量，也就在一定程度上加快了首屏渲染。 对路由组件进行懒加载 懒加载是指在访问到对应的组件时才加载它，首屏的时候不加载。 这里实现的方法很简单，只要将以前直接import组件的方式改为下面这样既可： const Login = () => import('@/pages/Login’); 官网文档： https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E6%8A%8A%E7%BB%84%E4%BB%B6%E6%8C%89%E7%BB%84%E5%88%86%E5%9D%97 针对第三方库文件使用cdn方式 为什么要使用cdn 我们搭建vue项目时，都是使用官方提供的项目构建脚手架工具（vue-cli）。 在项目打包时，它是把所有的代码都合并生成新文件。这里面就包括了我们自己写的组件代码、以及其他各种库（vue、vue-router）。这样就导致打包出来很大。 虽然最后打包压缩生成的是一个文件，但是因为是放在自己的服务器上。 问题：当我们加载页面时，需要将我们所需要的一些依赖加载到当前会话中然后再开始执行，如果我们首屏，模块比较多是，需要等待的时间会比较长，而且。浏览器内存最多执行四十个进程，需要等到加载完前面的才能执行后面的代码。(在Vue项目中，引入到工程中的所有js、css文件，编译时都会被打包进vendor.js，浏览器在加载该文件之后才能开始显示首屏。若是引入的库众多，那么vendor.js文件体积将会相当的大，影响首开的体验。) 解决： 如果我们使用cdn 引入第三方的资源，就可以缓解我们服务器的压力，原理就是把压力分配给了其他服务器上了。 vue中怎么使用cdn 之前，我是使用npm先安装 之后再import方式，这样就相当于一起打包到了vendor文件里了。 按照bootstrap官网引入相应的cdn文件后（包括jquery和bootstrap），我的项目最大文件大小变成了680kb，加载速度从8.5s变成了5.8s。 然后，试图引入element-ui theme-chalk之后，最大文件大小没多大变化，但是加载速度从5.8s变成了4.2s。接着又引入了vue和element-ui cdn文件，这下网站有了巨大突破，最大文件竟然降到了37kb，自己都被惊讶到了，加载速度也从4.2s变成了80ms，整个网站加载完成只花了1.5s，终于达到了秒开的效果，美滋滋...哈哈哈 具体实现步骤 引入资源 在index.html中，添加CDN资源，例如bootstrap上的资源： 添加配置 在bulid/webpack.base.conf.js文件中，增加externals，将引用的外部模块导入，如下： module.exports = { entry: { app: './src/main.js' }, externals:{ 'vue': 'Vue', 'vue-router': 'VueRouter', 'vuex':'Vuex' } 注意一点：格式为 'aaa' : 'bbb', 其中，aaa表示要引入的资源的名字，bbb表示该模块提供给外部引用的名字，由对应的库自定。例如，vue为Vue，vue-router为VueRouter. webpack的文档,是这样说的: 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。 去掉原有的引用 去掉import，如： // import Vue from 'vue' // import Router from 'vue-router' 去掉Vue.use(XXX)，如： // Vue.use(Router) 测试 重新npm run build，会看到 vendor.js体积有所下降了。我自已的个人主页中，将所有的外部模块，使用CDN引入之后，vendor.js从1M，降为30k左右。 通过开发者模式的Network工具，可以看到vue.js、vuex.js、vendor.js等文件会分别由一个线程进行加载。且因为使用了CDN，减轻了带宽压力。 for循环时始终提供key（track-by） vue1.x track-by=\"$index\" vue2.x v-bind:key=\"\"`` / :key=\"\" https://cn.vuejs.org/v2/guide/list.html 推荐阅读 关于VUE性能问题优化的几个点 浅谈 Vue 项目优化 程序员总结的那些Vue性能优化经验 Vue笔记六：Vue项目的性能优化之路 说下你对mvvm的理解？双向绑定的理解? mvvm就是，vm框架视图、m模型就是用来定义驱动的数据、v经过数据改变后的html、vm就是用来实现双向绑定； 双向绑定: 一个变了另外一个跟着变了，例如：视图上一个绑定了模型的节点有变化，模型对应的值会跟着变； 补充 Vue面试题汇总 Vue nextTick 机制 "},"doc/vue/思考题/6.2 vue-router相关面试题.html":{"url":"doc/vue/思考题/6.2 vue-router相关面试题.html","title":"6.2 vue-router相关面试题","keywords":"","body":" Vue Router： https://router.vuejs.org/zh/ 本文参考总结于： 1、vue-router原理分析 - https://www.cnblogs.com/yanze/p/7644631.html 2、location.hash详解 - http://blog.csdn.net/baidu_31333625/article/details/54288223 3、使用HTML5的History API - https://www.cnblogs.com/chaoyuehedy/p/5758143.html 4、HTML5 History 模式 - https://router.vuejs.org/zh-cn/essentials/history-mode.html 我们都知道，单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面;vue-rouetr在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。 那为什么这两种方式能够实现试图更新不跳转，其原因在于： 1、Hash模式： hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置； 2、History模式： HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面； 通常情况下，我们会选择使用History模式，原因就是Hash模式下URL带着‘#’会显得不美观；但实际上，这样选择一不小心也会出问题；比如： 但当用户直接在用户栏输入地址并带有参数时： Hash模式：xxx.com/#/id=5 请求地址为 xxx.com,没有问题; History模式: xxx.com/id=5 请求地址为 xxx.com/id=5，如果后端没有对应的路由处理，就会返回404错误； 为解决这一问题，vue-router提供的方法是： 在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。 路由之间跳转 声明式（标签跳转） 编程式（ js跳转） 声明式（标签跳转） User User User User register 编程式 (js跳转） router.push() // 字符串 router.push('home') // 对象 router.push({ path: 'home' }) // 命名的路由 router.push({ name: 'user', params: { userId: 123 }}) // 带查询参数，变成 /register?plan=private router.push({ path: 'register', query: { plan: 'private' }}) 注意 如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path： const userId = 123 router.push({ name: 'user', params: { userId }}) // -> /user/123 router.push({ path: `/user/${userId}` }) // -> /user/123 // 这里的 params 不生效 router.push({ path: '/user', params: { userId }}) // -> /user 同样的规则也适用于 router-link 组件的 to 属性 router.replace() 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似window.history.go(n)。 // 在浏览器记录中前进一步，等同于 history.forward() router.go(1) // 后退一步记录，等同于 history.back() router.go(-1) // 前进 3 步记录 router.go(3) // 如果 history 记录不够用，那就默默地失败呗 router.go(-100) router.go(100) active-class是哪个组件的属性？ vue-router模块的router-link组件。 怎么定义vue-router的动态路由以及如何获取传过来的动态参数？ 在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id。 vue-router有哪几种导航钩子？ 三种: 第一种：全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。 第二种：组件内的钩子； 第三种：单独路由独享组件 vue-router是什么？它有哪些组件？ vue用来写路由一个插件。 router-link、router-view 导航钩子有哪些？它们有哪些参数？ 导航钩子有： 全局钩子和组件内独享的钩子。 beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave 参数(最常用的就这几种)： to（去的那个路由） from（离开的路由） next（一定要用这个函数才能去到下一个路由，如果不用就拦截） "},"doc/vue/思考题/6.3 vuex相关面试题.html":{"url":"doc/vue/思考题/6.3 vuex相关面试题.html","title":"6.3 vuex相关面试题","keywords":"","body":"vuex是什么？怎么使用？哪种功能场景使用它？ 是什么？ vue框架中的状态管理插件。 怎么用？ 在main.js引入store，注入。新建一个目录store，….. export 。 哪些功能场景使用？ 场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 单页面应用，每个组件都是一个视图。一旦应用组件结构、数据传递变得复杂起来之后，那么简单的父组件向子组件传递，或者子组件向父组件传递数据就变得非常混乱模糊。 vuex能够解决这个问题。 vuex有哪几种属性？ 有五种，分别是 State、 Getter、Mutation 、Action、 Module vuex的State特性 A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新 C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中 vuex的Getter特性 A、getters 可以对State进行计算操作，它就是Store的计算属性 B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用 C、 如果一个状态只在一个组件内使用，是可以不用getters vuex的Mutation特性 Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。 不用Vuex会带来什么问题？ 一旦项目组件规模和组件之间数据传递变得复杂一点之后。那么数据传递就变得异常混乱。 项目代码可维护行变得糟糕。 代码可读行下降。可能换个团队中的其他人，又或者一段时间之后，你再看看之前的代码，都对感觉很头疼。 你是怎么认识vuex的？ 答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。 通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。 应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 子组件之间如何共享数据 使用vuex。 "},"doc/vue/思考题/6.4 axios面试题.html":{"url":"doc/vue/思考题/6.4 axios面试题.html","title":"6.4 axios面试题","keywords":"","body":"axios是什么？怎么使用？描述使用它实现登录功能的流程？ 答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中 axios的特点有哪些 axios是一个基于promise的HTTP库,支持promise的所有API 它可以拦截请求和响应 它可以转换请求数据和响应数据,并对响应回来的内容自动转换为json类型的数据 它安全性更高,客户端支持防御XSRF "},"doc/vue/思考题/6.5 小程序-相关面试题.html":{"url":"doc/vue/思考题/6.5 小程序-相关面试题.html","title":"6.5 小程序面试题","keywords":"","body":""},"doc/vue/思考题/自我介绍.html":{"url":"doc/vue/思考题/自我介绍.html","title":"七、自我介绍","keywords":"","body":"自我介绍 （各位）面试官，大家下午（上午）好！ 很荣幸有机会参加此次面试。希望今天我能有好的表现，希望我今天能面试成功。 现在，请允许我自我介绍一下。我叫高龙，今年25岁，出生于安徽省，毕业于南京工业大学计算机科学与技术专业。今天我要应聘的职位是web前端开发工程师岗位。2017年毕业之后我一直从事前端开发工作，这份工作不仅仅是因为跟我大学所学的专业对口，同时也是我特长和兴趣所在。 在大学生涯的最后一学年，我先是在南京焦点科技前端开发实习岗位实习了一段时间。中间因学校统一安排又到南通培训安卓开发一个月。 后自2017年四月初至今我一直工作于南京讯之智网络科技公司，担任的职位是前端开发工程师。在讯之智, 我主要负责公司产品前端业务开发工作。 在讯之只这一年里，不论是技术，或是心智、思维我都得到了很大提升，当然，对于这个我要感谢我的leader、我的boss、以及讯之智这个团队的照顾。但是，天下没有不散的延熹，即便我已经熟悉了哪里的环境、那个团队、我也喜欢那里。但是，现在因为一些私人原因，最后我不得不想了很久之后下定决心离开南京来苏州这边工作发展。甚至接下来很可能就在这边定居下来了。 我觉得我是一位具有很强集体荣誉感、有着良好团队精神、并且诚恳、有想法、喜欢不断视图尝试去挑战自我的年轻人。那么，我也非常有信心胜任这个工作岗位。 最后，再次感谢给我此次面试机会。 职业规划 全栈、架构、安全: 我想以后逐渐的去学习点架构、安全方面的东西。 前端开发也是软件工程: 可能一开始并没有想太多，其实到现在啊 我不太喜欢说前端开发，我觉得前端开发就是软件开发，没必要去限制自己； 一直单纯做前端业务 逐渐视野太窄: 我觉得一直 或者没有以后的大致方向的话，一直做着前端业务开发，不想多去尝试的话可能真的 视野相对是比较窄的； 伪全栈: 其实，刚出来工作后就想以后做全栈工程师。可能那个时候也没想清楚为什么要做全栈。现在想想可能就是那个时候做前端页面做类了吧，加上对后端的好奇，好奇数据库怎么操作的，前端调用的接口怎么写的等等吧。后来自己学过数据库 mysql 然后也租了一个阿里云服务器，搞了一个前后端分离的玩玩，弄了个后管理系统。也学了简单的怎么维护。。但是没意思，你说数据库增删改查有什么意思。所以，对于过去自己一点不了解的，简单的学习了知道怎么跑的 然后看到效果了。没意思的。这不是全栈，另外视野也太窄了； 会搬砖 意义不大: 我觉就得这就像开始因为不了解一个新出的框架，很好奇，后来看了文档，用着做了一个有十几个静态页面的小网站一样。只是熟悉了怎么用它搬砖，意义不大的。 难的是要问为什么: 要做架构，首先，基本功扎实要的吧。一个应用的架构，你对流程中每个环节得真正的理解吧，线上报一个问题，要看下日志就能定位到哪里的问题吧。 短期目标: 不管什么时候，都不要忘了基础吧。框架嘛就任务驱动吧。大概半年时间内把。工作之余 结合视频把vue框架源码看看，之前已经看过一点，同时红皮书看看； 请给点意见: 其实说到全栈我连半吊子都算不上，你可能比我有资历聊聊这个。那么我能问一下，从你的角度看我的这份职业规划你会给点什么建议吗。 修订-02： 因为喜欢而做: 首先，我想说我是因为真的喜欢做前端所以决定一直深入的在这个方向做下去的。在这里插入一个事，其实，我大学时被调剂到这个专业的，一开始自己想学建筑专业的，后来被调剂到这个专业我能有什么办法呢。再后来大一下进来社团跟着学长开始做前端，一直就没变过。这里说多了。继续回到这个问题啊。 定位: 我觉得自己 短时间内努力一下很会有很快的进步。所以，我其实还是抱着很大激情来上海的。就是想未来3-5年在这边在一个地方，好好干提升自己的能力的； 3-5年、一个地方: 我希望在这边找到一个合适的公司，比如像这家公司一样，我觉得我当前的情况是匹配这个岗位的。如果我能在这里3-5年的话，我有信心我能达到自己的要求。 计划分阶段: 然后，让我现在对整个职业规划进行阶段分隔的话，我可能会分成下面介个阶段。 中级->高级: 首先，接下来一年或者一年半时间里由初级提 升到 高级的前端developer。这段时间内，我要做的是继续不断的深挖基础，把最基础的东西如js打牢。 做资深的前端工程师: 接着，再用一到两年由高级提 升到 资深的前端developer。 架构: 再接着，我想往架构方面去转，具备架构的能力，对应用每个环节都很清楚，拥有比别人更宽的视野 大局观；要学的东西有：后端技术、DBA、Platform等。 为什么想换工作（离职）？为什么要来上海？ 其实，为什么离职吧，我想大概有两个原因吧： 我已开始是带着很大激情渠道一个大公司，我希望在这里面拼命的学习然后成为更好的前端工程师。我不能否认它的优点吧，毕竟在刚到那里的时候，对我的影响还是很大的。只不过后来当我熟悉了之后，越来越发现我可能不适合那么大的公司。 太安逸了、温水煮鱼: 首先，同程在苏州虽然是个比较大的公司了，待遇在苏州也算不错的，但是总的来说我觉得氛围过于安逸了。就拿我们度假研发中心来说吧，184号人号人，可能工作十年的一抓一大把，你说五六年的那就更不用说了。大家可能都是在外面打拼过了后来去到苏州按了家有家有口的。所以，我该怎么说呢 可能站在我现在的角度看就是有点温水煮鱼的感觉了。 大公司好与坏: 其次，大公司有它的好的地方，对些细节要求比较严格，教你怎么做事，通过严格的代码走审来影响你培养你写代码质量的意识。但是，当你熟悉了他们自己的框架之后，那么不好的地方就发现了，大公司一个萝卜一个坑，我觉得我能接触到东西不多。 现在还有机会出来，一线城市成长更快: 还有，按我现在的工作经历来说，我觉得我应该出来的，短期三年四年内我还能出来还有机会。可能以后结婚了就在某一个地方定死了。所以，我觉得趁现在有机会出来，在上海待几年我会比在那里学到更多东西。 北上广，对我们这代人尤其男生还是有吸引力的: 另外，除技术以外的东西，我现在的想法是，一个男生出去多经历一些没什么不好的。我们这代人从小就从各种渠道听说北上广北上广，如果还有机会去北上广锻炼一下都没去是不是也算是一种遗憾。 "},"doc/vue/思考题/提问环节.html":{"url":"doc/vue/思考题/提问环节.html","title":"八、面试提问","keywords":"","body":"面试提问： 虽然投简历之前，我从网上也了解到了一些关于我们公司的信息。但是，我还是希望您能帮我介绍下当前我们的主要业务。具体点说下做什么。 我想了解下公司当前的主要业务，以及接下来的发展方向或者规划。 我们公司前端的话，目前所使用的技术栈有哪些。 工作时间呢？ 技术部门的话，会有一些活动吗？比如：前端组每个月会有定期的技术分享活动吗。 是我们自己的产品吗？ 技术人员： 前端组多少人？ 前端用到哪些技术栈？ 形式组内会有什么活动吗？（谨慎点问，小公司知道没有的就不要问了） 老板： 能再帮我介绍下我们公司的业务吗 有哪些产品 "},"doc/React/":{"url":"doc/React/","title":"Introduction","keywords":"","body":"Introduction 参考学习项目 React, Redux, React Router, Ant Design, Webpack 电商后台管理项目 React全家桶后台管理框架 react16+react-router4 打造企业电商管理后台 react-elm 在线视频 React源码深度解析 高级前端工程师必备技能-2018年M课网 React16+Redux 实战企业级大众点评Web App "},"doc/React/React/hello world.html":{"url":"doc/React/React/hello world.html","title":"入门","keywords":"","body":"什么是React? react其实就是一个2013年被facebook开源了的，用于构建前端用户页面的javascript库（UI框架）。 JSX JSX 中写注释 {/* 这是注释 */} { // 注释 } JSX 中写label 请输入 JSX 如何对输入的 html 不转义 dangerouslySetInnerHTML: 用于指定对显示的内容不做转换。 { // item } ); 数据传递 父组件向子组件传值 父组件向子组件传递数据，通过属性传递 子组件通过this.props拿取数据 子组件向父组件传递数据 props、state 和 render()之间的关系 react是一个数据驱动的框架。但是 它背后的原理是怎么样的呢？为什么数据发生变化，页面就会跟着变化？那么，弄明白props、state和render()三者之间的关系就明白了！ 数据和页面时如何联动的呢？ 当组件的state或者props发生改变时，render()函数就会被重新执行。render()函数就会拿到最新的数据去重新渲染页面。 虚拟DOM 我们上面说了，当数据发生改变时，react 的render()函数重新渲染页面。那么，如果没有react 我们该怎么做呢？ 版本 - 1： state 数据 JSX 模板 数据 + 模板 结合。生成真实的 DOM, 来显示。 state 改变 数据 + 模板 结合，生成真实的 DOM, 替换原始的 DOM。 这种实现的致命缺陷： DOM替换性能消耗太大。 改进： state 数据 JSX 模板 数据 + 模板 结合。生成真实的 DOM, 来显示。 state 改变 数据 + 模板 结合，生成真实的 DOM, 并不直接替换真实的DOM。 对比新生成的DOM 和 页面原来的DOM。找出不同(更新、改动)的地方。 只替换需要更新的dom, 没有更新的不动。 缺陷：性能提升并不明显。 改进2： state 数据 JSX 模板 数据 + 模板 结合。生成真实的 DOM, 来显示。 生成虚拟DOM（模拟DOM的一个JS对象，用它来描述真实的DOM）（损耗了性能） state 数据发生变化。 生成新的虚拟DOM。（极大的提升了性能） 比较原始虚拟DOM 和 新的虚拟DOM，找出区别。（极大的提升了性能） 直接操作DOM，更新改变的DOM。 什么是虚拟 DOM ? 虚拟 DOM 就是用JS来模拟的DOM。即虚拟DOM就是一个JS对象，真实的DOM有什么，我们都可以用这个JS对象来模拟（如，标签名，属性、文本节点）。 深入理解虚拟 DOM JSX -> createElement -> 虚拟DOM (JS对象) -> 真实的DOM state 数据 JSX 模板 数据 + 模板 结合，生成虚拟DOM（模拟DOM的一个JS对象，用它来描述真实的DOM）（损耗了性能）。 用虚拟DOM结构生成真实的DOM, 来显示。 state 发生改变。 数据 + 模板 生成新的虚拟DOM（极大的提升了性能）。 比较原始虚拟DOM 和 新的虚拟DOM，找出区别。（极大的提升了性能）。 直接操作 DOM。修改变化的DOM。 虚拟 DOM 的优点 性能提升了。 使得跨端应用得以实现。（在浏览器里面，虚拟DOM最终被转化成真实的DOM；在原生应用里面，虚拟dom，最终被转换成可以被原生应用识别的元素应用组件。这样一来，同一份虚拟DOM, 就可以在不同设备上重复使用） 虚拟 DOM 中的Diff算法 diff算法提升了比对两个虚拟dom的效率。 setState() 是异步的。这么设计的初衷是为了提高react底层的性能。 diff 算法有个很重要的概念：同级(层)比较。 当一层的虚拟DOM不同时，那么，下面的虚拟DOM就不会比较了。而是直接替换掉。 虽然，这样DOM替换上性能有所消耗，但是，简化了diff算法比对的复杂度和提升了比对的性能。 提升比对性能 和 为什么key值不要用index。 为什么要给每个循环项添加key呢？为了提高对比虚拟DOM的效率。key值 就是我们给循环生成的虚拟节点起得别名。 我们假设一下，循环生成一组dom节点（上），当数据改变之后，重新生成一组新的虚拟DOM（下）。 为什么要尽量不用index作为key值呢？因为，我们使用key有个前提，就是不能改变之前原有的值（就不能保证，在原有的虚拟dom树上的key值，和新的虚拟dom树上的key值是对应的了）。如果使用index, 如，把新数据插入到数组中间，那么就新的index和旧的虚拟dom key对应的就不是一个dom了。 总结： key的值可以使用item ref 的使用 在 react 中 ref 是用来直接获取 DOM 元素用的。但是，一般不太建议这么做。除非非要要到它不可。 {this.input = input}} /> handleInputChange() { // this.setState({ // inputValue: e.target.value // }); // const value = e.target.value; // 当使用ref直接获取dom时 const value = this.input.value; this.setState(() => ({ inputValue: value })); } 但是，我们说了setState() 是一个异步函数。所以，当你修改了数据之后，如果获取不到更新后的dom, 那么，你可以在setState()第二个参数函数中获取dom操作。 handleInputChange() { // this.setState({ // inputValue: e.target.value // }); // const value = e.target.value; // 当使用ref直接获取dom时 const value = this.input.value; this.setState(() => ({ inputValue: value }, () => { console.log( this.ul.querySelector('div').length ); })); } React 组件生命周期 注意：我们所说的生命周期是指组件的生命周期。即一个应用里面所以组件都有生命周期。 组件的生命周期可分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 生命周期的方法有： (1) componentWillMount 在渲染前调用, 在客户端也在服务端。 (2) componentDidMount: 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过 this.getDOMNode() 来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送 AJAX 请求等操作(防止异步操作阻塞UI)。 (3) componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用。 (4) shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 可以在你确认不需要更新组件时使用。 (5) componentWillUpdate 在组件接收到新的 props 或者state但还没有render时被调用。在初始化时不会被调用。 (6) componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。 (7) componentWillUnmount 在组件从 DOM 中移除之前立刻被调用。 React 生命周期函数使用场景演示 在constructor 中绑定作用域。在一定程度上提升了性能。 虚拟dom，同层比对，key值，来提升性能。 用于优化组件树更新，提升应用性能。 统一在 componentDidMount 中发送 ajax 请求。 使用axios 在 constructor 中绑定函数作用域 constructor(props) { super(props); this.state = { inputValue: '', list: ['学习英语', '学习react'] }; // 绑定函数作用域 this.handleInputChange = this.handleInputChange.bind(this); this.handleBtnClick = this.handleBtnClick.bind(this); this.handleLiDelete = this.handleLiDelete.bind(this); } 优化组件树，提升应用性能 因为，react中，默认情况下，当父组件数据更新导致父组件中的render()函数更新之后，其子组件也会被更新。即便子组件内的数据没有变化也会被更新。这样一来，就导致了一个性能问题。 怎么解决 提升性能呢？我们在组件生命周期的shouldComponentUpdate 函数中添加判断逻辑 —— 只有当传入子组件的props或者state发生改变时才更新组件。 通过使用 shouldComponentUpdate 函数，就可以避免无谓的 render 函数的执行。从而提升性能。使用 shouldComponentUpdate \"询问\"组件是否要更新，需要才更新。 // React内置的 setState 已经做了性能优化。它是异步的，当你做连续的多次数据操作时，这样就能在一次进行操作。这样做也就减少了虚拟dom的比对评率。提升了性能。 /** * shouldComponentUpdate * @param { Object } nextProps 组件更新时, 新的props * @param { Object } nextState 组件更新时，新的state */ shouldComponentUpdate(nextProps, nextState) { // 如果传给组件的content改变了， 重新渲染组件 if ( nextProps.content != this.props.content) { return true; } else { return false; } } 在 componentDidMount 生命周期函数中发送ajax请求 因为 componentDidMount 只执行一次。 第三方模块 axios, 来发送ajax请求 在组件中，引入axiox（埃克塞死），并使用。 // 在组件中引入 import axios from 'axios' // 使用 componentDidMount () { axios.get('/api/todolist') .then(() => {}) .catch(() => {}); } "},"doc/React/React/开发工具配置.html":{"url":"doc/React/React/开发工具配置.html","title":"开发环境搭建","keywords":"","body":" vscode 插件安装 插件 描述 React Native Tools 微软官方出的ReactNative插件,非常好用 Reactjs code snippets react的代码提示，如componentWillMount方法可以通过cwm直接获得 Auto Close Tag 自动闭合标签 Auto Rename Tag 自动重命名标签，配合上面的插件使用，基本上能赶上IDEA系的功能了 Path Intellisense 文件路径提示补全 Debugger for Chrome 可以支持使用chrome内核debug elint 用来执行代码检测 参考 visual studio code + react 开发环境搭建 "},"doc/React/围绕着React的几点思考.html":{"url":"doc/React/围绕着React的几点思考.html","title":"围绕着React的几点思考","keywords":"","body":"声明式开发 命令式式开发 传统的使用js、jquery直接操作 dom 就命令式的编程方式，我们要一步步的告诉程序怎么做。 声明式的开发 打个比方，以前我们要盖一栋楼，就要一步步打地基、盖好骨架、砌墙、到顶、粉刷、装修等等。。每一步都要你操心都要你亲手去做。 但是，React开发不是这样的，React开发中你只要关心数据就行了，React会根据数据自动帮你搭建好站点界面。这里数据就是图纸，只要把图纸设计好就行了，后面自动图纸帮你构建整个大厦。 可以与其他框架并存 React 应用最后会被挂在到某个dom上。所以，只要其他框架不改react挂在的这个dom就不会有问题。同样，对于其他框架操作的dom, React 不去动也不会有问题。 组件化 组件化开发应用，像是搭积木一样，将应用分隔成一个个小的模块，最后在组合起来成一个完整的应用。 组件化开发的好处是：易于维护、组件重用、提高了开发效率。 单向数据流 单向数据流： 就是指数据只能又外向内传递，只能父组件传递给子组件，而子组件中不能 直接操作 父组件的数据。子组件操作父组件的数据也是要通过父组件传递给子组件方法，又子组件触发。但是实际上最终还是在父组件中执行方法并修改数据的。 为什么要这么设计？ 这么设计的好处： 逻辑简单清晰 方便调试bug 加入，数据时双向传递的，那么一旦出错，我们很难定位到是哪个组件中操作出的问题，因为同一个数据很可能被多个不同组件使用，在使用了这个数据的组件中都有可能执行了操作。但是单向数据流的话就没有这个问题了，一旦操作某个数据出错了，找到数据定义的那个组件即可。 视图层框架 React 只做前太UI开发。 针对很小的项目，例如写个 todoList 的话单独使用 React 时足够的，但是对于复杂的大型项目来说单纯仅仅使用 React 是绝对不够的, 如：管理状态要使用flux/Redux等框架。 如下图所示： 大型项目组件嵌套会是很复杂的，如果我们还是仅仅使用 React props进行数据传递的话，那么会很难！而且逻辑会极其难懂！ 函数式编程 这点从我们的组件代码中能够体现出来，在组件代码中定义的都是一个接着一个函数，对于复杂的操作也只要进行拆分成不同的函数就可以了。 "},"doc/React/React/组件之间数据传递/父传子.html":{"url":"doc/React/React/组件之间数据传递/父传子.html","title":"父组件传递给子组件","keywords":"","body":"props 父组件通过属性向子组件传值。子组件如果想操作父组件中的数据的话，则是父组件通过属性将方法传给子组件，然后子组件调用这个方法间接的修改父组件中的数据。 传递父组件数据 传递父组件方法 "},"doc/React/React/常用软件包/react-dom.html":{"url":"doc/React/React/常用软件包/react-dom.html","title":"react-dom","keywords":"","body":"React-DOM react-dom是什么？ React-DOM 是react的一个核心软件包，里面封装了针对DOM操作的方法。比如，最核心的一个render()方法，该方法用于将react生成的vdom转换成真是的dom并渲染的指定容器节点上。 "},"doc/React/React/常用软件包/prop-types.html":{"url":"doc/React/React/常用软件包/prop-types.html","title":"prop-types","keywords":"","body":"prop-types： 类型检查 学习文档 npm 官网文档 React 官方文档 "},"doc/React/React/常用软件包/react-hot-loader.html":{"url":"doc/React/React/常用软件包/react-hot-loader.html","title":"prop-types","keywords":"","body":""},"doc/React/React/常用软件包/react-loadable.html":{"url":"doc/React/React/常用软件包/react-loadable.html","title":"prop-types","keywords":"","body":""},"doc/React/React/理解JSX.html":{"url":"doc/React/React/理解JSX.html","title":"JSX","keywords":"","body":"再理解 JSX 非必须的。但是，推荐使用它； JSX, 不是字符串也不是HTML, 它是一种 JavaScript 的语法扩展。是在 JavaScript 内部实现的； 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。 注意: 由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。 可以使用 JavaScript 表达式 样式: 建议使用内联样式 数组 JSX 允许在模板中插入数组，数组会自动展开所有成员： 注释 注释需要写在花括号 ({/*注释...*/})中。 "},"doc/React/React/diff算法.html":{"url":"doc/React/React/diff算法.html","title":"diff算法","keywords":"","body":""},"doc/React/Redux/什么是Redux.html":{"url":"doc/React/Redux/什么是Redux.html","title":"Redux是什么","keywords":"","body":"什么是Redux 阅读 Redux 中文文档 Redux Tutorial 中文翻译 "},"doc/React/Router/开始.html":{"url":"doc/React/Router/开始.html","title":"开始","keywords":"","body":"文档 官方文档 react-router 针对不同的使用场景衍生了不同的路由包: RN项目用：react-router-native web项目用：react-router-dom React Router 中文文档（一） React Router 中文文档（二） 并且，不需要再重复引入react-router了。如果你搭建的是web环境项目，就直接用react-router-dom。 Package Version Docs Description react-router The core of React Router react-router-dom DOM bindings for React Router react-router-native React Native bindings for React Router react-router-config Static route config helpers react-router和react-router-dom的区别 参考: react-router和react-router-dom的区别 | csdn。 总结归纳就是： react-router-dom 依赖 react-router(它是react框架的核心路由包)。 react-router-dom 包的内部已经引用了react-router, 事实上react-router-dom提供的很多组件都是react-router的（引用了再输出的）。 使用时直接安装 react-router-dom 即可，不需要再另行安装 react-router 了。这是因为 react-router-dom 包装引用着react-router, 所以在安装前者的同时也就吧把它依赖的包下载下来了。 react-router-native 同理； "},"doc/React/Router/react-route-dom.html":{"url":"doc/React/Router/react-route-dom.html","title":"react-router-dom","keywords":"","body":"react-router针对不同的使用场景衍生了不同的路由包: RN项目用react-router-native web项目用react-router-dom 并且，不需要再重复引入react-router了。如果你搭建的是web环境项目，就直接用react-router-dom。 安装使用 npm install --save react-router-dom "},"doc/React/面试题.html":{"url":"doc/React/面试题.html","title":"面试题","keywords":"","body":"概念 vue和react的区别 1、react严格上针对的是mvc模式的view层，vue则是mvvm模式。 2、操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。 3、数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。 4、react中state是不能直接改变的，需要使用setState改变。vue中的state不是必须的，数据主要是由data属性在vue对象中管理的。 描述对react理解？ react是一个用于构建用户界面的JS库。react主要用于构建UI。很多人认为 React 是 MVC 中的 V（视图）。 react起源于Facebook的内部项目，用来架设instagram网站，后来在2013年5月份被开源。 调用 setState 之后发生了什么？ 在代码中调用 setState 函数之后： React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation） 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染 react 生命周期函数 - 初始化阶段： - getDefaultProps:获取实例的默认属性 - getInitialState:获取每个实例的初始化状态 - componentWillMount：组件即将被装载、渲染到页面上 - render:组件在这里生成虚拟的 DOM 节点 -componentDidMount:组件真正在被装载之后 - 运行中状态： - componentWillReceiveProps:组件将要接收到属性的时候调用 - shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了） - componentWillUpdate:组件即将更新不能修改属性和状态 - render:组件重新描绘 - componentDidUpdate:组件已经更新 - 销毁阶段： - componentWillUnmount:组件即将销毁 shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？） shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 为什么虚拟 dom 会提高性能?(必考) 虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。 react diff 原理 把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的 key 属性，方便比较。 React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字） 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。 refs 的作用是什么？ Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回： class CustomForm extends Component { handleSubmit = () => { console.log(\"Input Value: \", this.input.value) } render () { return ( this.input = input} /> Submit ) } } 上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值： function CustomForm ({handleSubmit}) { let inputElement return ( handleSubmit(inputElement.value)}> inputElement = input} /> Submit ) } React 中有三种构建组件的方式 React.createClass()、ES6 class 和无状态函数。 createElement 和 cloneElement 有什么区别？ React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。 React.createElement( type, [props], [...children] ) React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。 React.cloneElement( element, [props], [...children] ) 开发 性能优化 React 中 keys 的作用是什么？ Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。 render () { return ( {this.state.todoItems.map(({item, key}) => { return {item} })} ) } 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中会借助元素的 Key 值来判断该元素是新近创建的还是之前就存在的，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。 参考 常见react面试题汇总（适合中级前端） 2018-09-21 React面试题 React专题：react，redux以及react-redux常见一些面试题 【react面试题】不可错过的react 面试题 「务必收藏」 "},"doc/Regular_expression.html":{"url":"doc/Regular_expression.html","title":"正则表达式","keywords":"","body":"目录 什么是正则表达式 开始 正则表达式图形化工具 总结 JS RegExp对象 字面量法 构造函数写法 修饰符 元字符 字符类 字符类取反 范围类 预定义类 边界 量词 贪婪模式与非贪婪模式 贪婪模式 非贪婪模式 分组 或 反向引用 忽略分组 前瞻 JS 对象属性 test() 和 exec() 正则表达式常用方法 test() search() match() replace() 什么是正则表达式 Regular Expression 使用单个字符串来描述 匹配一系列符合某个句法规则的字符串。 说简单了，就是按照某种规则去匹配复合条件的字符串。 开始 正则表达式图形化工具 https://regexper.com/#%2F%5Ba-z%5D%2F 总结 \\b 单词边界 \\d 数字 + 一个或多个 {2} 重复两个 {2, 5} 两到五个 . 任意字符 \\ 转义字符 [] 或者，例如：[/-]表示/或者-。 ^ 开始 $ 结束 JS RegExp对象 JavaScript通过内置对象RegExp支持正则表达式 两种方式实例化RegExp对象：字面量、构造函数。 Js replace(正则表达式，替换后的字符传)，常备用来替换字符。 字面量法 var str = \"He is a boy, This is a dog. Where is she?\"; var reg = '/\\bis\\b/'; //只匹配第一个 str.replace(reg, 'IS'); //He IS a boy, This is a dog. Where is she? var reg2 = '/\\bis\\b/g'; //全部匹配 str.replace(reg2, 'IS'); //He IS a boy, This IS a dog. Where IS she? 构造函数写法 var str = \"He is a boy, This is a dog. Where is she?\"; var reg = new RegExp('/\\bis\\b/'); //只匹配第一个 str.replace(reg, 'IS'); //He IS a boy, This is a dog. Where is she? var reg2 = new RegExp('/\\bis\\b/', 'g'); //全部匹配 str.replace(reg2, 'IS'); //He IS a boy, This IS a dog. Where IS she? 修饰符 g: global 全文搜索，不添加，搜索到第一个匹配停止。 i: ignore case 忽略大小写，默认大小写敏感。 m: mutiple lines 多行搜索。 \"He is a boy, This Is a dog. Where is she?\".replace(/\\bis\\b/g, 0); // \"He 0 a boy, This Is a dog. Where 0 she?\" \"He is a boy, This Is a dog. Where is she?\".replace(/\\bis\\b/gi, 0); // \"He 0 a boy, This 0 a dog. Where 0 she?\" 元字符 正则表达式由两种基本字符类型组成： 原义文本字符： 如“a”, \"abc\" 元字符： 如：\"\\b\" 元字符 是正则表达式中有特殊含义的非字母字符 \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 \\cX 与X对应的控制字符（Ctry + X） 字符类 一般情况下，正则表达式一个字符对应字符串的一个字符。 但是，某些时候我们需要的是匹配满足一系列某个特征的字符，那么怎么办呢？对，这个时候就是用到字符类的时候了。 元字符[]构建一个简单的类 所谓类，是指符合某些特性的对象，一个泛指，而不是特质某个字符。 表达式[abc]把字符a或者b或者c归为一类，表达式可以匹配这类字符。 'a1b2c3d4'.replace(/[abc]/g, 'X'); // \"X1X2X3d4\" 字符类取反 使用字符类^ 创建反向类/负向类 反向类的意义是指不属于某类的内容 表达式[^abc]表示不是字符a或者b或者c的内容。 'a1b2c3d4'.replace(/[^abc]/g, 'X'); // \"aXbXcXXX\" 范围类 我们可以使用[a-z]两个字符，从a到z的任意字符。 这是闭区间，也就是包含a和z。 'a1b2c3d4z5'.replace(/[a-z]/g, 'Q') // \"Q1Q2Q3Q4Q5\" // 同时匹配大小写 'a1b2c3d4z5'.replace(/[a-zA-Z]/g, 'Q') '2016-01-09'.replace(/[0-9]/g, 'A') // \"AAAA-AA-AA\" '2016-01-09'.replace(/[0-9-]/g, 'A') // \"AAAAAAAAAA\" 预定义类 正则表达式提供预定义类 来匹配常见的字符类 预定义类包括以下： 字符 等价类 含义 . [^\\r\\n] 除了回车符或者换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符（字母、数字下划线） \\W [^a-zA-Z_0-9] 非单词字符 边界 最终表达式还提供了几个常用的边界匹配字符 字符 含义 ^ 以.....开始 $ 以.....结束 \\b 单词边界 \\B 非单词边界 m 处理多行 'This is a boy'.replace(/is/g, '0'); // \"Th0 0 a boy\" 'This is a boy'.replace(/\\bis\\b/g, '0'); // \"This 0 a boy\" 'This is a boy'.replace(/\\Bis\\b/g, '0'); // \"Th0 is a boy\" '@123@abc@'.replace(/@./g, 0); // \"0230bc@\" '@123@abc@'.replace(/^@./g, 0); // \"023@abc@\" '@123@abc@'.replace(/.@/g, 0); // \"@120ab0\" '@123@abc@'.replace(/.@$/g, 0); // \"@123@ab0\" \"@123 @456 @789\".replace(/^@\\d/g, 'X'); // \"X123 // @456 // @789\" \"@123 @456 @789\".replace(/^@\\d/gm, 'X'); // \"X123 // X456 // X789\" 量词 量词表示任意字符出现的次数。 字符 含义 ？ 出现零次或者一次 + 出现一次或者多次 * 出现零次或者多次（人一次） {n} 出现n次 {n,m} 出现n到m次(注意，,与数字之间不要有空格) {n，} 至少出现n次 贪婪模式与非贪婪模式 贪婪模式 正则表达式会尽可能多的匹配，直到匹配结束 '12345678'.replace(/\\d{3,6}/g, 'X') // X78 非贪婪模式 让正则表达式尽可能的少匹配，也就是说一旦成功匹配不在继续尝试。这就是非贪婪模式。 在量词后面加个? '12345678'.replace(/\\d{3,6}?/g, 'X') // \"XX78\" 分组 例如：匹配字符Byron连续出现3次的情景。 使用()可以达到分组的功能，使得量词作用于分组。 'a1b2c3d4'.replace(/([a-z]\\d){3}/g, 'X'); // \"Xd4\" 或 'ByronCasper'.replace(/Byron|Casper/g, 'X'); // \"XX\" 'ByronsperByrCasper'.replace(/Byr(on|Ca)sper/g, 'X'); // \"XX 反向引用 $ 引用 引用的是每个分组内的内容 '2018-09-16'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g, '$1/$2/$3'); // \"2018/09/16\" 忽略分组 不希望捕获某个分子，只需要在分组内加上“？” 、或\":\"就可以了。 如： （？：Byron） 前瞻 正则表达式是从文本头部向文本尾部解析的，文本尾部方向，称为”前“ 前瞻，就是在正则表达式匹配到规则时，向前检查是否符合断言。后顾/后瞻方向相反。 JavaScript不支持后顾。 符合特定断言 称为 肯定/正向 断言。 不符合特定断言 称为 否定/负向 断言。 名称 正则 含义 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 正向后顾 exp(? Js 不支持 负向后顾 exp(? Js 不支持 'a2*3'.replace(/\\w(?=\\d)/g, 'X'); // \"X2*3\" 'a2*34v8'.replace(/\\w(?=\\d)/g, 'X'); // \"X2*X4X8\" 'a2*34vv'.replace(/\\w(?=\\d)/g, 'X'); // \"X2*X4vv\" 'a2*34vv'.replace(/\\w(?!\\d)/g, 'X'); // \"aX*3XXX\" JS 对象属性 global 是否全文搜索，默认值是false ignore case 是否大小写敏感，默认值是false multiline 多行搜索，默认值是false lastIndex 当前匹配到内容的最后一个字符的下一个位置 source 正则表达式的文本字符串 test() 和 exec() 正则表达式常用方法 test() 匹配字符串，如果匹配成功就返回真，匹配失败就返回假。 语法： 正则.test(字符串)。 ```javascript var str='abcdef'; var re=/b/; //bc一个整体也在字符串中，弹出true，但是写bd，弹出false，因为字符串中没有bd这么一个整体 console.log( re.test(str) ); ## search() - 匹配字符串，如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回-1 - **语法：** 字符串.search(正则) var str=\"Visit W3School!\" str.search(/W3School/); // 6 var str2 = \"Visit W3School!\"; str2.search(/w3school/); // -1 var str3 = \"Visit W3School!\" str3.search(/w3school/i); // 6 ## match() - 匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null - **语法：** 字符串.match(正则) ```javascript var str = \"dgfhfgh254bhku289fgdhdy675\"; var reg = /\\d/; var reg1 = /\\d/g; console.log( str.match(reg) ); // [\"2\"] console.log( str.match(reg1) ); // [\"2\", \"5\", \"4\", \"2\", \"8\", \"9\", \"6\", \"7\", \"5\"] replace() 正则去匹配字符串，匹配成功的字符去替换新的字符串 语法： 字符串.replace(正则，新的字符串) 第二个参数，可以使字符串 or 回调函数（回调函数的第一个参数，就是匹配成功的字符） var str = \"aaa\"; var re = /a/; str = str.replace(re,\"b\"); alert(str); // 输出baa "},"doc/http/readme.html":{"url":"doc/http/readme.html","title":"Http","keywords":"","body":" 阅读 图解HTTP-看云 http协议面试必读 "},"doc/http/chapter1/1.内容介绍.html":{"url":"doc/http/chapter1/1.内容介绍.html","title":"内容介绍","keywords":"","body":" 看下上面这张图。在浏览器的API里面有一个叫performance的接口。这个performance会给我们记录所有的每一个时间点，那么这个时间点就是http协议，在每个时间点都有它发挥作用的地方。 然后，它的一个时间过程的消耗会通过那个API进行记录，那么 对于我们开发者来说，我们就可以知道每一个时间点他的耗时特别的长，那么我们就可以去优化它。 第一步 Redirect： 然后简单的讲一下，在最开始我们要去发起一个请求的时候，我们比如说是在浏览器里面输一个url，然后按一下回车的时候 那么最开始它会去做一个Redirect, 为什么一开始就做Redirect呢？因为我们的浏览器可能记录了你这个地址, 以及永久跳转成一个新的地址，所以一开始永远就要先去判断一下我需不需要redirect，以及我要redirect到哪里。 第二步 应用缓存： 然后是要去看缓存。因为你请求的这个资源可能已经缓存过了，所以呢，我们要去看app里面的缓存是否有。那么如果没有缓存，那这个时候呢，我就要去实际的服务器那边请求资源。 第三步 DNS解析： 因为我们输入的是域名，那个域名要对应成IP之后我们才能真正的访问到服务器，所以呢，这个时候要先去查找一个域名对应的ip地址，所以这过程叫DNS解析。 第四步 TCP连接：获得ip之后，我们就要去创建tcp连接，那么创建tcp连接我们要经过一个tcp的三次握手之后才能真正的把连接创建起来，而且同时如果我们这个请求是https的都要创建一个https连接。它跟tcp的三次握手又不一样，因为它中间要有一个保证安全的数据传输的过程。 第五步 发送请求：这个时候创建好了TCP连接之后，我们才真正开始发送http请求的数据包。 第六步 接收响应： 我们请求的数据包发送完成之后 服务器接受到这个数据，它进行一个数据操作之后返回我们这个请求想要的内容。那么它就是开始返回数据，反而数据之后这一个http请求才真正的完成。 以上就是从我们打开浏览器输入url之后整个有关于数据加载的过程所会经历的每一个时间点. 了解以上知识，并且把这些东西都能够很深入的掌握之后, 你就知道哪个点可以去优化可以去做更多的事情，让我们的http服务可以做得更好。 "},"doc/http/chapter2/2.1五层网络模型介绍.html":{"url":"doc/http/chapter2/2.1五层网络模型介绍.html","title":"2.1 五层网络模型介绍","keywords":"","body":" 在详细讲解具体http协议之前， 我们会看一些基础的网络通讯相关的知识概念。通过理解基本的网络通讯相关的知识能够让我们对网络协议整体上面的一些简单的认识。这样的话有利于我们在之后更好的去理解http协议与其他的一些内容。 在网络协议当中，我们一般在说整个网络信息传输的过程的时候都会套用一个经典的五层模型的。五层模型分为应用层、传输层、网络城、数据链路层和物理层。这个在每一台电脑上、每台服务器上他都是有这么一个相应的层级关系来维护我们整个网络数据传输的一个过程。所以在你自己的电脑上 在一台远程的物理服务器上 可能上面放着一个外部服务器来提供一个网站的服务。 那么这些经典的计算机模型都会有这么一个网络的过程。所以你自己的计算机也是可以作为一台web服务器来提供网络服务的。 对于web开发， 我们的http协议是在应用层面去实现。但是呢它要基于传输层里面的一个非常重要的一个协议，叫tcpip协议。这个协议是现在网络模型当中最最最重要的一个协议，在我们应用的过程当中， 比如说 我们创建一个app的服务或者ftp服务或者是email的服务，那么这些服务他们都是基于tcpip协议实现的。 所以, tcpip协议在后面有些地方我们会讲解到因为他会涉及到一些像http求情的一个性能或者是它过程的一个消耗。这些内容都会涉及到tcpip协议相关的东西。那么下面这三层，因为我们主要做的是web服务,所以基本上不会去碰到相关的东西。我们顶多顶多会稍微涉及一些tcpip协议。 接下来，了解下下三层主要去做一些事情。 下三层 物理层 主要的作用就是定义物理设备如何去传输数据。简单的说物理层是什么呢，就是我们电脑的硬件 我们的网卡端口网线，以及我们网线连出去之后有一套光缆来为我们把数据传输到互联网可能经过好几千公里呢，这种情况下，把数据传输到对面的一个服务器上面。所以这些物理的内容是必须要有的，没有物理 我们的软件是没有办法去使用的。所以呢，物理层就是这些硬件设备相关的东西。 数据链路层 是在通信的实体之间建立数据链路连接。就是我们最基本的电脑的传输数据，就是0101这些东西。 数据链路层 是为数据节点之间的传输创建一个逻辑链路，那么逻辑电路图会包含一些 比如说我们从我的电脑要去访问百度的服务器，那么我们如何去寻找百度的服务器他所在的地址，它就是一个逻辑关系。那么这个关系是在网络层为我们创建了的。 这三层大家如果不是特别的能理解那没人没有什么关系，因为这些会相对非常的底层，如果大家有兴趣的话可以自己去学，如果没有什么兴趣，也不一定要非常了解才能做好一个web应用。因为我们基本上是在http协议相关的里面进行一些操作，最多偶尔会学习一些TCP相关的一些东西来提高我们使用http协议的时候技能相关的一些内容。 传输层 我们来讲一下什么是传输层，传输层主要有两个协议：tcpip协议 和 upd协议。在更多的情况下我们使用的基本上是tcpid协议，因为他是一个更可靠的帮我们去传输数据的协议。 传输层为我们提供了 端到端（end-to-end） 的一个服务, 这个服务是什么概念呢! 就是我们建立起来从我们自己的电脑到百度的服务器之间的这么一个连接之后，他们两端如何去传输一个数据的 传输数据的方式都是在这一层进行一个定义的。 我们传输的数据有可能很小有可能很大，那么如果传输的数据很大。一次性我们不能把这么大的数据传输过去，那么我们要分包、要分片。这些分片之后数据传输到那边之后要进行一个组装，组装的过程就是这些协议的定义，他如何去组装如何去传输都是在传输层进行一个定义的。 传输层向高层屏蔽了下层数据通信的细节。 什么概念呢, 因为http协议是实现在tcpip协议的基础上的。http协议要传输一个数据， 我们只需要非常简单的 比如说在浏览器里面输入url它就会自动去发送相关的一些数据到服务器端，然后服务器能够解析这些数据返回给我们的浏览器，最好把页面显示出来。我们输入url这个过程其实涉及到了一系列的数据的拼装与传输，那么这个过程我们作为浏览器端、我们作为用户或者说我们作为网页的开发者不需要知道它里面到底是怎么去分片、它怎么去跟服务器创建一个链接的关系。这些内容我们是完全不需要知道的，因为这是传输层已经帮我们封装掉了。 还有就是比如说我们创建一个ajax请求, 那么ajax请求也是一个http的请求，我们使用ajax的post方式去传输一些数据，那么这个数据如果比较大的时候，他也是一次性的传输不完的，那么它如何去进行一个传输？如何能够可靠地把我们想要的信息传输给服务器？服务器返回的信息又如何可靠的被我们拿到？那么这个过程都是传输层这边他已经帮我们实现的，所以我们使用httpt协议时不需要关心这些的。 虽然说不需要关心，但是如果你能更好的去理解传输层传输的过程，那这个时候可能对于在某一些细节上面去实现一个性能更高的，而且对协议的使用方式，可能会是一个非常大的帮助的。 应用层 http协议是在这个层级上去实现的。它们为我们应用软件提供了很多服务。我们写网页的时候，我们使用http协议发送请求，我们非常方便的，只要去new一个request然后就可以去把一些数据通过get or post的方式去发送到服务端, 这个是应用层在http协议上面它帮我们实现了http协议, 然后我们只要去使用http协议相关的一些工具就可以帮我们去传输一些数据。 他那是构建于tcp协议之上的，所以它的传输的方式最终都是要落实于在tcpip协议上面。 它屏蔽了网络传输相关的一些细节，那么就跟tcp帮我们屏蔽了http协议它数据是如何去发送的这些细节一样, 我们在使用http协议的时候，具体的网络传输的细节也是不需要我们去深入的理解的。 "},"doc/http/chapter2/2.2http协议发展的历史.html":{"url":"doc/http/chapter2/2.2http协议发展的历史.html","title":"2.2 HTTP 协议发展历史","keywords":"","body":" HTTP/0.9 只有一个命令get。 没有HEADER等描述数据的信息。 服务器发送完毕，就关闭tcp连接。 HTTP/1.0 增加了很多命令。 增加了status code 和header。 多字符集、多部分发送、权限、缓存等。 HTTP/1.1 相对于上一个版本，增加了些功能，优化了网络连接。 持久连接 持久连接什么意思呢？在 HTTP 1.1 版本里面，我们的一个http请求就要在客户端和服务端之间创建一个tcp连接，创建这个tcp连接之后在服务端返回完内容之后这个tcp链接就关闭掉了。那么这个成本是相对比较高的，因为在建立一个http连接的过程当中，我们要进行一个http的三次握手，那么这一部分是在tcp协议里面做的，我们不需要关心。但是，我们要知道 在这个创建链接的过程当中它的消耗是比较高的，延迟也会比较高。所以如果我们建一个链接之后可以不关闭，然后我们以后新的HTTP请求可以一直在这个连接里面进行一个发送的话，那么它的性能肯定会高很多。 pipeline 我们可以在同一个连接里面发送多个请求，但是服务器端对于进来的请求是要按照顺序进行一个内容反馈的，所以如果前一个请求处理的时间非常长而后一个请求处理的时间比较快，这个时候，后一个请求它不能先发送，它要等第一个请求数据全部发送完成之后它才能进行发送。所以这部分时间就相当于我们的一个串行和一个并行它里面的低性能差异就体现出来了。（这个在http2里面就会进行一个优化） 增加了host和其他一些命令 增加了host后，我们就可以在同一台服务器(我指的是物理服务器)上同时跑多个不同的服务。比如说一个nodejs的web服务一个java的web服务，然后通过host这个字段来表示都是请求的这一台物理服务器上面的，但是我要请求的是里面哪一个软件服务，是nodejs服务还是我们的java服务就是通过host来进行判断的。这个头增加的好处就是我们在同一个物理服务器或者同一个机器里面，我们可以部署很多不同的web服务来进行一个使用，这样的话提高我们物理服务的一个使用效率。 HTTP2 所有的数据都是以二进制进行传输的 在 HTTP 1.1 里面我们大部分的数据传输是通过字符串传输的，所以它们数据的分片方式是不太一样的。在 HTTP2 里面我们所有的数据都是以帧进传输的。 同一个连接里面发送多个请求不再需要安装顺序来返回数据 而同样是因为有了上一个好处，所以我们同一个连接里面发送了请求不再需要按照顺序来进行一个返回处理了。它可以同时返回第一个请求里面的数据和第二个请求里面的数据。这样的话他就是并行的一个效率，能够更大限度的去让整个web应用的传输效率有一个质的提升。 头信息压缩以及推送等提高效率的内容 HTTP2其实整体上就是为了解决HTTP 1.1里面它的一些性能低下的问题。头信息压缩什么概念呢，在 HTTP 1.1 里面我们每一次发送请求和返回请求差的很多http头都是必须要进行一个完整的发送和返回的，但其实这一部分头信息里面很多的内容是以字符串的形式保存了，所以它的占用带宽的量是比较大的，在 HTTP2 里面头信息进行了压缩，就可以有效的减少带宽。 第二个是推送的功能。我们知道http请求是只能够我这边发起请求，然后服务器端响应我的请求。就是说客户端永远是主动方，服务器端永远是被动方。HTTP2里面有了推送的功能之后，服务器端是可以主动发送一些数据传输的。 那它解决了什么问题呢？举一个最简单的例子，我们知道html，我们的web页面，因为现在我们在外面都会去要求有一些css/js文件，那么它们都是以链接的方式在html文本信息里面显示着 通过浏览器解析里面的内容之后，然后再根据我这个链接里面它包含的这个url地址，再去请求对应的是css、js文件。那这里面就会包含一个顺序的问题，我们需要去先请求到html文本，然后在浏览器里面运行解析的这个文本之后，我们才能去发送css的请求和js的请求。 HTTP2里面有了推送的功能之后，我们请求这个html的同时，我们可以主动把这个html里面所需要用到的css文件和js文件推送到我们的客户端。这样的话就是我们html、css、js发送顺序是并行的，而不是串行的。这样一想大家应该都能理解了， 就是它整体的一个传输效率和性能肯定是要高非常多的。 OK，这就是我们的HTTP协议发展的一个历史。那么其中当然还包含了HTTPS协议，就是一个安全版本，但是实际使用内容跟HTTP1.1其实没有特别大的区别。 "},"doc/http/chapter2/2.3HTTP的三次握手.html":{"url":"doc/http/chapter2/2.3HTTP的三次握手.html","title":"2.3 HTTP 的三次握手","keywords":"","body":"先弄清楚一个概念 —— HTTP请求和TCP连接之间的关系 这个概念什么概念呢，就是在客户端和服务器之间进行一个http请求的发送和返回的过程当中，需要去创建一个叫做tcp connection的一个东西，因为http是不存在连接这么一个概念，它只有请求和响应的概念。那么，请求和响应都是数据包，它们之间是要经过一个传输的通道，这个传输的通道在哪里呢，就在TCP里面去创建的。就是一个从客户端发起和服务端接收的这么一个连接。 这个连接是可以一直保持在那边的，我们的http请求是在这个连接的基础上面去发送的。那么，这里面就有一个概念，就是在TCP连接上面是可以发送多个http请求的。不同的HTTP版本里面这个模式是不一样的。 在HTTP 1.0里面，这个连接是在一个HTTP请求创建的时候它就去创建这个TCP连接，然后连接创建完之后请求发送过去，在服务器响应了之后，这个TCP连接它就关闭了。 在http1.1里面，这个连接可以通过某种方式去声明，这个链接是可以一直保持在那边，意思就是我们这个请求发送完了之后这个连接没有关闭。然后，第二个请求进来的时候它还可以在这个连接上面进行一个发送。 那么这有什么好处呢？ TCP连接在创建的过程当中是有三次握手的，三次握手就是代表着有三次网络传输和三次消耗。客户端发送过去是、然后服务端返回也是、最后客户端再发送一次，这个时候才创建了这个tcp连接。连接建立之后才能去发送http请求。所以，如果我们在这个TCP连接把它保持在那边，后面的第二个http请求就没有三次握手的开销。 在HTTP2里面还有一个好处，就是 http2里面 TCP连接 上面的http请求是可以并发的。这就导致在同一个用户对同一个服务器发起一个网页请求的时候它只需要一个TCP连接。 三次握手 第一次 首先,客户端它发起一个创建连接的这么一个数据包的请求，发送到服务端。数据包里面会有一个标志位，叫做SYN=1，它是一个标志位。就是说我就是一个创建请求的一个数据包。然后，后面他会发送一个叫Seq=X（x是数字，一般来说都等于1）。 第二次 然后，当服务端接收到这个数据包之后，它知道了有一个客户要跟它创建一个连接。那么创建这个连接之后，服务器端就会开启一个TCP的socket的一个端口。当这个端口开启之后，它返回给客户端一个数据包，在返回的客户端数据里面也是一个SYN=1的标志位，还返回一个ACK。ACK就等于客户端发送过来的这个Seq的值加一。另外，还发送一个Seq，这个是服务端的一个Seq。 第三次 然后，客户端拿到之后说服务端已经允许我去打开这个创建这个tcp连接了，它再去发送它的Ack = y + 1，以及Seq。它的Seq等于一个新的数字。 ok 这就是创建一个tcp连接的过程。 那么为什么要进行这样的一个三次握手呢？ 这是为了防止服务端这边它开启一些无用的连接。因为我们知道网络传输是有延迟的，因为我们中间（客户端和服务器）可能隔的非常远的距离，比如要通过一个光纤 然后还有各种中间的代理服务器来进行一个传输。那么传输的过程中 比如说客户端这边它发起了一个SYN=1这个创建连接的请求，如果服务端这边就直接创建了这个连接，然后服务器端返回了这个内容给客户端。但是这个数据包可能因为网络传输的原因丢失了，客户端一直没有接收到服务器返回的这个东西，客户端这边它可能又设置了一个超时时间，超过了这个时间之后这个连接创建就关闭了。 那么，客户端可能又发起一个新的创建连接的请求，但是这个时候服务是不知道的。因为没有第三次握手在这里的话，服务端是根本不知道客户端它到底有没有接收到它返回的信息。并且它没有给服务端一个确认说要去创建还是要关闭这个请求。那么，服务器端这边的这个端口就一直开在那边等待着客户端来发送实际的请求数据了，这个时候服务端这个开销就浪费了。 因为服务器端不知道这个连接已经创建失败了，可能客户端已经去创建一个新的连接去了。所以，我们需要这个三次握手来确认这个过程，让客户端和服务端能够及时的察觉到说我们因为网络原因的一些问题导致内容没有查到，然后这个端口这个连接就可以关闭了。我们不需要一直等在那边。 所以，针对这种情况三次握手主要是为了就是规避网络传输延时导致服务器开销的问题。 "},"doc/http/chapter2/2.4URI、URL和URN.html":{"url":"doc/http/chapter2/2.4URI、URL和URN.html","title":"2.4 URI、URL和URN","keywords":"","body":"URI Uniform Resource Indentifier / 统一资源标志符 URI 就是为了去定位某一个特定的资源而且设计的。用来标识互联网上的唯一的资源的一个方式。它包含了 URL 和 URN。 URL Uniform Resource Licator / 统一资源定位器 URL 用来找到这个资源它所在的位置，并且去访问它得到它。 URL 的组成部分： http://user:pass@host.com:80/path?query=string#hash http://: 定义了以什么样的方式、什么样的协议访问资源。 user:pass@: 这一部分代表我们去访问了这个资源之后，如果这个资源需要有特定的身份才能去访问，那么你可以在前面加入user:pass@指定说我就是这个用户，并且你的服务可以通过我的用户名跟密码来进行一个认证来表示我这个用户我是真的是这个用户而不是一个虚假的。这种方式在我们现在的web开发里面基本是不太用的到的了。因为更好的方式去做用户认证，如果你每一次需要用户认证的一个内容都需要在url里面去输入用户名密码，肯定是一个非常不安全的，而且是非常麻烦的一个操作。现在的web开发商都基本上用不到，大家只要知道有这种方式，在URL定义里面，它是有这一块区域留给用户认证的就可以了。 host.com: 域名或IP地址。用来定位我们这个资源她所在的服务器在互联网中的一个位置，因为我们知道互联网中定位一台机器最基础的，那就是他的IP。使IP可以直接通过IP找到这台机器。如果是域名，要通过DNS的服务去解析成IP，然后才能定位到哪台服务。所以，他就是用来找到这一台服务器所在的互联网位置。 :80: 端口。为什么要有端口呢？因为每一台服务器都有非常非常多的端口，在这台服务器上，你可以跑很多的软件，就是web服务。它可以监听各种不同的端口。那么，如果我们要找的是这台物理服务器上面某一个web服务里面存放的这些资源的话，我们就要指定我们是要找的哪个web服务。也就是说端口就是用来定位我们host找到的那台物理服务器上面它存放的许多个web服务当中的某一个web服务。因为整个http协议它其实就是一个用来定位的。所以，我们先要找到这台物理服务器，然后再找到它的一个web服务器，再然后我们才能再根据后面的一些内容去定位的这个web服务器下面存放的内容。其实相当于我们的搜索范围从大的往小的一点一点精确精确，最后精确到我们真正想要找到这个内容。 path: 路由。路由是什么意思呢？因为一个web里面可能存放了非常多的内容，我们具体要如何找到这个内容，那么我们可以通过路由这个东西来进行确定。 从 HTTP 的定义上来讲，我们这个路径应该是直接对应的我们这个web服务的一个目录结构下面的路径。很多时候，因为现在我们的web应用变得越来越复杂，我们的很多数据都是存在数据库里面的，而不是对我们某一个磁盘上的一个文件它所在的位置。所以我们更多的时候是直接把它用来辨别我们现在这个url索要请求的数据，在程序里面去判断而不是直接对一个目录结构的一个映射关系。 query=string: 搜索参数。就是说我们要请求的资源，我们如何去进行一个搜索进行一个查找或者一些操作的一个方式。基本上现在web服务就是用它来传参。 #hash: 这个哈希是干嘛用的呢，在 HTTP 的定义里面，我们请求的前面的整个url找到了一个文档，但是如果这个文档非常的大，比如说有好几兆的内容，然后又都是文字，这个时候如果一下子返回这么多内容，我并不需要。作为用户来讲，我只是想看一下其中一个段落，那么这个时候就可以用到这个。现在，前端页面开发的时候，我们经常使用哈希来作为一个锚点的一个定位的工具。 此类格式的都叫URL， 比如ftp协议。 域名方便记忆、方便传播。 URN URN这个东西，因为现在使用的不多，所以大家只要了解一下定义就可以了。 首先，它是一个 永久统一资源定位符。什么意思呢，因为我们作为于l就是我们HP的服务，如果我们某一个资源他这个链接我们这个资源呢，把它搬了一个位置，那么可能导致就是这个链接访问的时候请求不到具体的内容。一般情况下，比如说我们现在服务访问的如果是一个我们不存在的链接，都会返回404。但是，这个URL是不会告诉你这个资源被搬到了哪个地方的。 你怎么样才能访问到你想要返回的这个东西的。URN就解决这个问题，很多这方面的一些专家都在研究。如何去在出现了这种情况的时候，即便资源搬了一个新的位置，但是它还可以通过URN访问的这个地方。就是说，只要你把这个URN指向了这个资源，即便你把这个资源搬来搬去 换了很远的一个地方，它还是能够找到这资源的。URL不具备这个能力的。 然后呢，目前还没有非常成熟的一个使用方案，业界也没有什么非常好的一个使用场景。 "},"doc/http/chapter2/HTTP报文格式.html":{"url":"doc/http/chapter2/HTTP报文格式.html","title":"2.5 HTTP报文格式","keywords":"","body":"HTTP 报文格式 "},"doc/http/重点思考/常见Http状态码.html":{"url":"doc/http/重点思考/常见Http状态码.html","title":"常见Http状态码","keywords":"","body":"常见的HTTP状态码 2开头 （请求成功） 表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足\"期望\"请求标头字段的要求。 5开头（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 参考 前端面试校招问题准备（总结） "},"doc/http/重点思考/不同请求类型的区别.html":{"url":"doc/http/重点思考/不同请求类型的区别.html","title":"不同请求类型的区别","keywords":"","body":"不同请求类型的区别 当使用RESTful web服务的时候，每一种HTTP请求方法的含义如下： GET：从服务器取回数据（只是取回数据，而不会产生其他的影响）。这是一个幂等的方法（译者注：使用相同的参数重复执行，应该能够获取到相同的结果）。下面是一个使用GET请求从服务器获取id为123的书的例子。 GET /books/123 POST：POST请求通常用来创建一个实体，也就是一个没有ID的资源。一旦这个请求成功执行了，就会在HTTP请求的响应中，返回这个新创建的实体的id。我们通常用它来上传文件或者表单。 POST /books/ PUT：PUT请求和POST请求类似，但是一般用来更新一个已有的实体。通过把已经存在的资源的ID和新的实体用PUT请求上传的服务器，来更新资源。 PUT /books/123 DELETE: DELETE方法用来从服务器上删除资源。和PUT类似，你需要把要删除的资源的ID上传给服务器。 DELETE /books/123 TRACE: 提供一种方法来测试当一个请求发生的时候，服务器通过网络收到的内容。所以，它会返回你发送的内容。 HEAD: HEAS请求和GET请求资源类似，但是仅仅返回响应的头部（没有具体的响应体）。同时，和GET请求类似，HEAD也是幂等的，不会在服务器上造成其他影响。 OPTIONS: OPTIONS方法允许客户端请求一个服务所支持的请求方法。它所对应的响应头(response header)是Allow, 它非常简单地列出了支持的方法。 CONNECT: 主要用来建立一个对资源的网络连接（通常请求一些能够把HTTP连接转发成为TCP连接并保持的代理）。一旦建立连接后，会响应一个200状态码和一条“Connection Established”的消息。 "},"doc/http/重点思考/缓存方案以及如何实现.html":{"url":"doc/http/重点思考/缓存方案以及如何实现.html","title":"缓存方案以及如何实现","keywords":"","body":"No1: 为什么？是什么？本质？使用？ 什么是缓存？ 缓存分类？ 什么是http缓存？ 为什么要使用Http缓存？ 如何使用Http缓存？ 本地浏览器中缓存的资源存储在哪里了？ 参考 面试精选之http缓存 | 掘金 http的缓存机制面试版 | csdn 一文读懂http缓存（超详细）| 掘金 彻底弄懂HTTP缓存机制及原理 | cnblog 彻底弄懂HTTP缓存机制及原理 | csdn 记一次前端面试的全过程 一年半经验，百度、有赞、阿里前端面试总结 "},"doc/http/面试题/mst.html":{"url":"doc/http/面试题/mst.html","title":"五、面试题","keywords":"","body":"HTTP url请求所经历的过程有哪些？ 判断请求类型，是否用缓存，是否是异步数据交互等几种情况， 详见https://blog.csdn.net/u014600626/article/details/78720763 从服务器端安全考虑，请求方式用get还是post？ get！！ 因为get方式是查询操作，而post可能会恶意修改数据 http和https的区别？ Nginx "},"doc/flutter/material.html":{"url":"doc/flutter/material.html","title":"Material","keywords":"","body":"FlatButton 用于创建一个 material 风格的 “扁平按钮”。 属性 animationDuration → 持续时间 指形状和高度变化动画持续时间。 autofocus → bool child → Widget 按钮的label。 colorBrightness → Brightness 按钮的主题亮度。 clipBehavior → Clip color → Color 在其默认（未按下，启用）状态下，按钮的填充颜色。 disabledColor → Color 禁用按钮时按钮的填充颜色。 disabledElevation → double 未启用按钮时，相对于其父项的层级高度。 disabledTextColor → Color 按钮被禁用时，文本颜色。 elevation → double 相对于其父级放置此按钮的z坐标 enabled → bool 该按钮是启用还是禁用。 focusColor → Color 获取焦点时，按钮的颜色。 focusElevation → double 获取焦点时，按钮相对父级的 Z 坐标。 focusNode → FocusNode 焦点节点（可选）。 hashCode → int 该对象的哈希码 height → double 按钮的垂直范围 highlightColor → Color highlightElevation → double hoverColor → Color 当鼠标指针悬停在按钮上时的按钮颜色。(pc端有效) hoverElevation → double 鼠标悬停在按钮上时，按钮的Z坐标。 materialTapTargetSize → MaterialTapTargetSize 设置点击目标的最小大小。 minWidth → double 按钮将占据的最小水平范围。 onHighlightChanged → ValueChanged onLongPress → VoidCallback 长按按钮时调用的回调。 onPressed → VoidCallback 轻击或激活按钮时调用的回调。 padding → EdgeInsetsGeometry 按钮子级的内部填充。 runtimeType → Type 对象的运行时类型的表示形式。 shape → ShapeBorder 按钮形状。 splashColor → Color 按钮InkWell的初始颜色 textColor → Color 按钮文本颜色 textTheme → ButtonTextTheme 定义按钮的基本颜色，以及按钮最小尺寸，内部填充和形状的默认值。 方法 build(BuildContext context) → Widget 描述这个部件表示的界面部分。 "},"doc/flutter/widget.html":{"url":"doc/flutter/widget.html","title":"常用Widgets","keywords":"","body":"Align 设置child的对齐方式，例如居中、居左居右等，并根据child尺寸调节自身尺寸。 布局行为 当widthFactor和heightFactor为null的时候，当其有限制条件的时候，Align会根据限制条件尽量的扩展自己的尺寸，当没有限制条件的时候，会调整到child的尺寸； 当widthFactor或者heightFactor不为null的时候，Aligin会根据factor属性，扩展自己的尺寸，例如设置widthFactor为2.0的时候，那么，Align的宽度将会是child的两倍。 Align为什么会有这样的布局行为呢？原因很简单，设置对齐方式的话，如果外层元素尺寸不确定的话，内部的对齐就无法确定。因此，会有宽高因子、根据外层限制扩大到最大尺寸、外层不确定时调整到child尺寸这些行为。 示例 // 例子依旧很简单，设置一个宽高为child两倍区域的Align，其child处在正中间。 new Align( alignment: Alignment.center, widthFactor: 2.0, heightFactor: 2.0, child: new Text(\"Align\"), ) 属性解析 属性 描述 alignment 对齐方式，一般会使用系统默认提供的9种方式，但是并不是说只有这9种，例如如下的定义。系统提供的9种方式只是预先定义好的。Alignment实际上是包含了两个属性的，其中第一个参数，-1.0是左边对齐，1.0是右边对齐，第二个参数，-1.0是顶部对齐，1.0是底部对齐。根据这个规则，我们也可以自定义我们需要的对齐方式，例如。static const Alignment rightHalfBottom = alignment: const Alignment(1.0, 0.5), widthFactor 宽度因子，如果设置的话，Align的宽度就是child的宽度乘以这个值，不能为负数。 heightFactor 高度因子，如果设置的话，Align的高度就是child的高度乘以这个值，不能为负数。 AspectRatio 宽高比控件。 属性： aspectRatio 设置要是使用的长宽比，长宽比表示为宽高比。比如16:9宽高比的值为16.0/9.0； child 子元素； Baseline Baseline 即根据 child 的 baseline 定位 child 的小部件，即使得不同的child都处在规定的基线位置，尤其是多用在文字排版中，比如使得不同大小的文字处于同一水平线。 属性： baseline 基准线位置，像素为基本单位 baselineType 定位child的基线类型，分为两种：alphabetic -用于对齐字母字符的字形底部的水平线；ideographic-用来对齐表意文字的水平线 Center Center继承自Align，只不过是将alignment设置为Alignment.center，其他属性例如widthFactor、heightFactor，布局行为，都与Align完全一样，在这里就不再单独做介绍了。Center源码如下，没有设置alignment属性，是因为Align默认的对齐方式就是居中。 class Center extends Align { /// Creates a widget that centers its child. const Center({ Key key, double widthFactor, double heightFactor, Widget child }) : super(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child); } Column 垂直排列组件； 属性解析 mainAxisAlignment 主轴布局方式，column主轴方向是垂直的方向。 默认值：MainAxisAlignment.start；其他属性值还有： 1) start ，沿着主轴方向(垂直方向)顶部对齐； 2) end，沿着主轴方向(垂直方向)底部对齐；3)center，沿着主轴方向(垂直方向)居中对齐； 4) spaceBetween ，沿着主轴方向(垂直方向)平分剩余空间； 5) spaceAround，把剩余空间平分成n份，n是子widget的数量，然后把其中一份空间分成2份，放在第一个child的前面，和最后一个child的后面； 6) spaceEvenly，把剩余空间平分n+1份，然后平分所有的空间，请注意和spaceAround的区别；| crossAxisAlignment: 交叉轴的布局方式，对于column来说就是水平方向的布局方式。 默认值：CrossAxisAlignment.center，默认是水平居中。 start ，垂直主轴方向(水平方向)左侧对齐； end，垂直主轴方向(水平方向)右侧对齐； center，垂直主轴方向(水平方向)居中对齐； stretch ，垂直主轴方向(水平方向)拉伸子child； baseline，这个要和textBaseline一起使用， textBaseline：字体的基线（基线这东西一直没搞懂，具体详见下一章Row，效果更明显，垂直方向没啥用，不明显）。 默认值：是空的。 1）alphabetic ，用于对齐字母字符底部的水平线； 2）ideographic，用于对齐表意字符的水平线； textDirection：文字布局方向。 默认值：没有，但在row的布局上是左到右的，请看Row的章节。 TextDirection.ltr ，从左到右； TextDirection.rtl，从右到做布局； verticalDirection： 就是字child的垂直布局方向，向上还是向下。 默认值：VerticalDirection.down 也就是从上到下的布局。 down ，从上向下布局，上图示例我的代码是红、蓝、黄； up，反过来从下向上布局，反过来就是黄、蓝、红； Container 官方给出的简介，是一个结合了绘制（painting）、定位（positioning）以及尺寸（sizing）widget的widget。 可以得出几个信息，它是一个组合的widget，内部有绘制widget、定位widget、尺寸widget。后续看到的不少widget，都是通过一些更基础的widget组合而成的。 https://www.jianshu.com/p/366b2446eaab GestureDetector 检测手势组件； 属性 描述 behavior 此手势检测器在命中测试期间应如何表现 child 子组件 dragStartBehavior 确定拖动开始行为的处理方式 excludeFromSemantics 是否从语义树中排除这些手势。例如，用于显示工具提示的长按手势被排除在外，因为工具提示本身直接包含在语义树中，因此具有显示该工具提示的手势将导致信息重复。 onDoubleTap 用户连续两次在同一位置用主按钮敲击屏幕 onForcePressEnd 指针不再与屏幕接触 onForcePressPeak 指针与屏幕接触并以最大的力按下。力的大小至少为ForcePressGestureRecognizer.peakPressure。 onForcePressStart 指针与屏幕接触，并用足够的力进行按压以启动压力按压。力的大小至少为ForcePressGestureRecognizer.startPressure。 [...] onForcePressUpdate 指针与屏幕接触，之前已通过ForcePressGestureRecognizer.startPressure，并且正在屏幕平面上移动，以变化的力按压屏幕或同时出现这两种情况。 onHorizontalDragCancel 先前触发onHorizo​​ntalDragDown的指针未完成。 onHorizontalDragDown 指针已通过主按钮接触屏幕，并且可能开始水平移动。 onHorizontalDragEnd 以前通过主按钮与屏幕接触并水平移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动。 onLongPress 当识别出带有主按钮的长按手势时调用。 onLongPressEnd 用主按钮触发长按的指针已停止接触屏幕。 onLongPressMoveUpdate 长按主按钮后，指针已被拖动移动 onLongPressStart 当识别出带有主按钮的长按手势时调用 onPanCancel 先前触发onPanDown的指针未完成 onPanDown 指针已通过主按钮接触屏幕，并且可能开始移动 onPanEnd 以前使用主按钮与屏幕接触并移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动 onPanStart 指针已通过主按钮接触屏幕并开始移动。 onPanUpdate 通过主按钮与屏幕接触并移动的指针再次移动 onScaleEnd 指针不再与屏幕接触。 onScaleStart 与屏幕接触的指针已建立焦点和1.0的初始比例。 onScaleUpdate 与屏幕接触的指针已指示新的焦点和/或刻度。 onSecondaryTapCancel 先前触发onSecondaryTapDown的指针不会最终导致轻击 onSecondaryTapDown 可能导致用辅助按钮轻击的指针已接触到特定位置的屏幕。 onSecondaryTapUp 将使用辅助按钮触发轻击的指针已停止接触特定位置的屏幕。 onTap 发生了带有主按钮的点击。 onTapCancel 先前触发onTapDown的指针不会最终导致轻击 onTapDown 可能导致用主按钮轻击的指针已接触到特定位置的屏幕 onTapUp 将通过主按钮触发点击的指针已停止接触特定位置的屏幕 onVerticalDragCancel 先前触发onVerticalDragDown的指针未完成。 onVerticalDragDown 指针已通过主按钮接触屏幕，并且可能开始垂直移动 onVerticalDragEnd 以前通过主按钮与屏幕接触并且垂直移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动 onVerticalDragStart 指针已通过主按钮接触屏幕并开始垂直移动 onVerticalDragUpdate 通过主按钮与屏幕接触并垂直移动的指针已沿垂直方向移动 Offstage padding 给子节点设置padding属性。 Flutter中并没有单独的Margin控件，在Container中有margin属性，看源码关于margin的实现。 if (margin != null) current = new Padding(padding: margin, child: current); 不难看出，Flutter中淡化了margin以及padding的区别，margin实质上也是由Padding实现的。 Position 绝对定位组件； Row ScaleTransition 缩放动画组件； 属性 描述 alignment 缩放比例的坐标系原点相对于盒子尺寸的对齐方式： child 该组件下的子组件 scale 控制子部件缩放动画 方法 描述 build(BuildContext context) → Widget 重写这个方法来构建部件 —— 依赖监听的状态 Scaffold 定义app结构和导航； SizedBox 用于指定宽高, 主要用在对子控件的大小约束； 构造函数 const SizedBox({ Key key, this.width, this.height, Widget child }) 属性解析 用途 1、用作 ConstrainedBox 的 SizedBox SizedBox.expand( child: Card( child: Text('Hello World!'), color: Colors.yellowAccent, ), ), 2、用作内边距的 SizedBox Column( children: [ Icon(Icons.star, size: 50), const SizedBox(height: 100), Icon(Icons.star, size: 50), Icon(Icons.star, size: 50), ], ), 3、用作不可见对象的 SizedBox Widget build(BuildContext context) { bool isVisible = ... return Scaffold( appBar: AppBar( title: Text('isVisible = $isVisible'), ), body: isVisible ? Icon(Icons.star, size: 150) : const SizedBox(), ); } // 更简单的解决方案是使用 Opacity 部件，然后将 opacity 的值改成 0.0。这个方案的缺点是虽然组件不可见，但是它依旧占据空间。 Stack flutter中使用stack实现层叠布局。 层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。 "},"doc/flutter/painting.html":{"url":"doc/flutter/painting.html","title":"painting","keywords":"","body":"Alignment 矩形内的一个点； 常量： bottomCenter bottomLeft bottomRight center centerLeft centerRight topCenter topLeft topRight 属性 描述 x 水平方向的距离值 y 垂直方向的距离值 方法 描述 add(AlignmentGeometry other) → AlignmentGeometry -- alongOffset(Offset other) → Offset -- alongSize(Size other) → Offset -- inscribe(Size size, Rect rect) → Rect -- resolve(TextDirection direction) → Alignment -- toString() → String -- withinRect(Rect rect) → Offset -- "},"doc/build_tool/":{"url":"doc/build_tool/","title":"开始","keywords":"","body":"前端构建工具学习 grunt 中文网 gulp 中文网 其他 我们是如何做好前端工程化和静态资源管理 关键词： 模块化、 工程化、构建工具、自动化。 📦 🎓 📕 📖 "},"doc/build_tool/webpack/1 开始.html":{"url":"doc/build_tool/webpack/1 开始.html","title":"开始","keywords":"","body":"webpack视频课程 2019最新Webpack4.0教程4.x 成仙之路 | 文档地址 珠峰webpack 4.0成神之路 webpack 3 零基础入门视频教程 阅读 从基础到实战 手摸手带你掌握新版Webpack4.0详解 | 视频内容文档 webpack中文文档 webpack学习笔记 webpack 中文文档 前端模块管理器简介-阮一峰 webpack-demos-阮一峰 详解前端模块化工具-Webpack 搜罗一切webpack的好文章好工具 "},"doc/build_tool/webpack/2 什么是webpack.html":{"url":"doc/build_tool/webpack/2 什么是webpack.html","title":"什么是webpack","keywords":"","body":"什么是webpack webpack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其他一些浏览器不能直接运行的拓展语言（Scss, TypeScript）,并将其打包为合适的格式以供浏览器使用。 可以做的事情：代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布。 "},"doc/build_tool/webpack/3 webpack的工作原理.html":{"url":"doc/build_tool/webpack/3 webpack的工作原理.html","title":"webpack的工作原理","keywords":"","body":"webpack的工作原理 核心（基本）概念 在了解Webpack原理前，需要掌握以下几个核心概念，以方便后面的理解： entry 一个可执行模块或库的入口文件。 module：模块，在Webpack里一切皆模块，一个模块对应着一个文件。Webpack会从配置的Entry开始递归找出所有依赖的模块。 chunk: 代码块，一个Chunk由多个模块组合而成，用于代码合并与分割。多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合成一个 chunk 这体现了webpack的打包机制。 loader 文件(模块)转换器，例如把es6转换为es5，scss转换为css。 plugin 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能（在Webpack构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情）。 webpack构建流程 从启动webpack构建到输出结果经历了一系列过程，它们是： 解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。 递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。 输出所有chunk到文件系统。 需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如UglifyJsPlugin会在loader转换递归完后对结果再使用UglifyJs压缩覆盖之前的结果。 "},"doc/build_tool/webpack/webpack面试题.html":{"url":"doc/build_tool/webpack/webpack面试题.html","title":"webpack面试题","keywords":"","body":"概念问题 什么是webpack和grunt和gulp有什么不同？ Webpack是一个模块打包器，他可以递归的打包项目中的所有模块，最终生成几个打包后的文件。他和其他的工具最大的不同在于他支持code-splitting、模块化(AMD，ESM，CommonJs)、全局分析。 什么是bundle,什么是chunk，什么是module? bundle是由webpack打包出来的文件，chunk是指webpack在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块。 什么是Loader?什么是Plugin? 1）Loaders是用来告诉webpack如何转化处理某一类型的文件，并且引入到打包出的文件中 2）Plugin是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个对象，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。 什么 是模块热更新？ 模块热更新是webpack的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。 什么是Tree-shaking? CSS可以Tree-shaking吗 Tree-shaking是指在打包中去除那些引入了，但是在代码中没有被用到的那些死代码。在webpack中Tree-shaking是通过uglifySPlugin来Tree-shaking JS。Css需要使用Purify-CSS。 几个常见的loader file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 几个常见的plugin define-plugin：定义环境变量 terser-webpack-plugin：通过TerserPlugin压缩ES6代码 html-webpack-plugin 为html文件中引入的外部资源，可以生成创建html入口文件 mini-css-extract-plugin：分离css文件 clean-webpack-plugin：删除打包文件 happypack：实现多线程加速编译 loaders和plugin的加载顺序 webpack有哪些优点 专注于处理模块化的项目，能做到开箱即用，一步到位 可通过plugin扩展，完整好用又不失灵活 使用场景不局限于web开发 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展 良好的开发体验 webpack的缺点 webpack的缺点是只能用于采用模块化开发的项目 平时如何使用webpack的？一般用webpack的哪个版本？ webpack 和 gulp 的区别 webpack是一个模块打包器，基于入口的，强调的是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源都看成是模块，通过loader和plugin对资源进行处理。 grunt和gulp是基于任务和流 gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。 webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全 Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果 配置问题 如何可以自动生成webpack配置？ webpack-cli /vue-cli /etc ...脚手架工具 开发问题 webpack-dev-server和http服务器如nginx有什么区别? webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，他比传统的http服务对开发更加简单高效。 优化问题 什么是长缓存？在webpack中如何做到长缓存优化？ 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器去下载新的代码，最方便和简单的更新方式就是引入新的文件名称。在webpack中可以在output纵输出的文件指定chunkhash,并且分离经常更新的代码和框架代码。通过NameModulesPlugin或是HashedModuleIdsPlugin使再次打包文件名不变。 什么是Tree-shaking? CSS可以Tree-shaking吗 Tree-shaking是指在打包中去除那些引入了，但是在代码中没有被用到的那些死代码。在webpack中Tree-shaking是通过uglifySPlugin来Tree-shaking JS。Css需要使用Purify-CSS。 如何提高webpack的构建速度 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 要注意的第一点是，它对file-loader和url-loader支持不好，所以这两个loader就不需要换成happypack了，其他loader可以类似地换一下 使用Tree-shaking和Scope Hoisting来剔除多余代码 使用fast-sass-loader代替sass-loader babel-loader开启缓存 https://cloud.tencent.com/developer/article/1356611 https://cloud.tencent.com/developer/article/1356611 https://www.jianshu.com/p/e80d38661358 "},"doc/algorithm/src/算法复杂度.html":{"url":"doc/algorithm/src/算法复杂度.html","title":"算法复杂度计算","keywords":"","body":" 写代码一定要记住：一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 时间复杂度 算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。 如果，一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。 时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。 十分钟搞定时间复杂度（算法的时间复杂度） 空间复杂度 空间复杂度(Space Complexity) 是对一个算法在运行过程中临时占用存储空间大小的量度，记做 S(n)=O(f(n))。 空间复杂度 | 百度百科 关于算法空间复杂度的问题 阅读 算法的时间复杂度和空间复杂度 "},"doc/algorithm/src/二叉查找树.html":{"url":"doc/algorithm/src/二叉查找树.html","title":"二叉查找树","keywords":"","body":"二叉查找树(Binary Search Tree) 首先，在编写实现代码之前，要先清楚二叉树有哪些特点： 每个节点最多只有两个子节点 若左子树存在，则左子树的值不能小于根节点的值 若右子树存在，则右子树的值大于左子树的值 任意节点的左右子树也分别为二叉树 没有键值相等的节点 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。 二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。 Js实现代码 // 节点类 class Node { constructor(data, left, right) { this.data = data; this.left = left; this.right = right; } } // 二叉搜索树 class BinarySearchTree { // 构造函数 constructor() { this.root = null; } // 向二叉树中插入新数据 insert(data) { let n = new Node(data, null, null); if (!this.root) { return this.root = n; } let currentNode = this.root; while (1) { if (data "},"doc/algorithm/src/链表.html":{"url":"doc/algorithm/src/链表.html","title":"链表","keywords":"","body":"参考 Computer science in JavaScript: Linked list "},"doc/algorithm/面试题/array.html":{"url":"doc/algorithm/面试题/array.html","title":"数组相关","keywords":"","body":"算法面试题 —— 数组相关 求最大差值 题目： 假如有这么一个数组，数组中每一项代表最近一段时间内股票价格变动。现在，给你买入、卖出各一次机会，求最大获利的情况？ let arr = [13, 18, 16, 10, 7, 5, 8, 14, 21, 9, 8, 11, 23, 17, 18, 18, 20]; // 1 // 时间复杂度： O(n^2) // 空间复杂度：4 + n^2 = n^2, O(n^2) function getMaxSub(arr) { let i, j, len = arr.length, res = []; for (i=0; i tmp) { tmp = res[i]; } } return tmp; } console.log(getMaxSub(arr)); // 2 // 双重 for 循环 // 时间复杂度 O(n^2) // 空间复杂度 f(n) = 5, S(n) = O(1) function getMaxSub(arr) { let tmp; let i, j, len = arr.length; for (i=0; i tmp) { tmp = arr[j] - arr[i]; } } } return tmp; } console.log(getMaxSub(arr)); // 3 //想一下 能不能把时间复杂度降低到O(n) //think: 循环一次，每次迭代都计算一次i-1前最小项，用当前项减去最小项。再用结果和最小差值比较。 //时间复杂度：O(n) //空间复杂度：O(1) let arr = [13, 18, 16, 10, 7, 5, 8, 14, 21, 9, 8, 11, 23, 17, 18, 18, 20, 3, 90]; function getMaxSub(arr) { if (arr.length { if (index == 1) { minVal = item; maxSub = item - arr[index-1]; } if (index > 1) { if (arr[index-1] maxSub) { maxSub = item - minVal; } } }); return maxSub; } console.log(getMaxSub(arr)); 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 题目： 两数之和 let nums = [2, 7, 11, 15]; let target = 9; // 方法1： 双重for循环，先找出所有可能结果。最后再遍历结果数组（一个二元数组）; // 分析： 时间复杂度和空间复杂度都相对比较大； // 时间复杂度：O(n^2) // 空间复杂度：O(n^2) var twoSum = function(arr, target) { let result = []; let i, j, len = arr.length; for (i=0; i { arr2Map.set(elem, index); }); for (var key of arr2Map.keys()) { console.log(key); if (arr2Map.has(target - key)) { result.push([arr2Map.get(key), arr2Map.get(target - key)]); arr2Map.delete(key); arr2Map.delete(target - key); } } return result; } console.log(twoSum(nums, 9)); "}}